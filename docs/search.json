[
  {
    "objectID": "R/strep_only/communities/machine_learning_pipelines/01_machine_learn_home_env.html",
    "href": "R/strep_only/communities/machine_learning_pipelines/01_machine_learn_home_env.html",
    "title": "Machine learning evolutionary history from community structure",
    "section": "",
    "text": "Loads required libraries and sets global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/strep_only/communities/machine_learning_pipelines/01_machine_learn_home_env.html#classes-ancestral-b-bs",
    "href": "R/strep_only/communities/machine_learning_pipelines/01_machine_learn_home_env.html#classes-ancestral-b-bs",
    "title": "Machine learning evolutionary history from community structure",
    "section": "5.1 3 classes (ancestral, B, BS)",
    "text": "5.1 3 classes (ancestral, B, BS)\nFirst were going to try and predict all 3 different home evolution environments. We are going to train and analyze the performance of many different types of models\n\n5.1.1 Spliting\nSplit the data using the default 3:1 ratio of training-to-test. Here we also set the strata argument. This argument makes sure that both sides of the split have roughly the same distribution for each value of strata. If a numeric variable is passed to strata then it is binned and distributions are matched within bins. In this case there will be roughly the same distribution of the 3 classes within each side of the test/train split.\n\n\nShow/hide code\nbalclr_3c &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_ae, -home_env_sns) %&gt;% \n  tidyr::drop_na()\n\ntable(balclr_3c$home_env_3c)\n\n\n\n       anc       bact bact_strep \n        36         35         36 \n\n\nThe data is balanced\n\n\nShow/hide code\nset.seed(1501)\nbalclr_3c_split &lt;- rsample::initial_split(balclr_3c, strata = home_env_3c)\nbalclr_3c_train &lt;- rsample::training(balclr_3c_split)\nbalclr_3c_test  &lt;- rsample::testing(balclr_3c_split)\n\n\nResample the training set using five repeats of 10-fold cross-validation\n\n\nShow/hide code\nset.seed(1502)\nbalclr_3c_folds &lt;- rsample::vfold_cv(balclr_3c_train, strata = home_env_3c)\n\n\n\n\n5.1.2 Recipe\nFirst we need to preprocess the data so that it is in optimal format for Ml. Some useful steps include:\n\nstep_novel(): converts all nominal variables to factors and takes care of other issues related to categorical variables.\nstep_normalize(): normalizes (center and scales) the numeric variables to have a standard deviation of one and a mean of zero. (i.e., z-standardization).\nstep_dummy(): converts our factor column ocean_proximity into numeric binary (0 and 1) variables.\n\nNote that this step may cause problems if your categorical variable has too many levels - especially if some of the levels are very infrequent. In this case you should either drop the variable or pool infrequently occurring values into an “other” category with step_other. This steps has to be performed before step_dummy.\n\nstep_zv(): removes any numeric variables that have zero variance.\nstep_corr(): will remove predictor variables that have large correlations with other predictor variables.\n\nEdit: data is already in centered log-ratio transform and further normalization doesn’t really help.\n\n\nShow/hide code\nbalclr_3c_rec &lt;- recipes::recipe(home_env_3c ~ ., data = balclr_3c_train) %&gt;% \n  recipes::step_normalize(od600) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_zv(od600)\n\n\nYou can take a peek at the what the preprocessing recipe does using prep and bake\n\n\nShow/hide code\nbalclr_3c_rec %&gt;% \n  # perform the recipe on training data\n  recipes::prep() %&gt;% \n  # extract only the preprocessed dataframe \n  recipes::bake(new_data = NULL)\n\n\n\n  \n\n\n\n\n\n5.1.3 Model specifications\nThe process of specifying models is:\n\nPick a model type\nSet the engine\nSet the mode: regression or classification\n\n\n\nShow/hide code\nlibrary(rules)\nlibrary(baguette)\n\nsvm_r_spec &lt;- \n   parsnip::svm_rbf(cost = tune(), rbf_sigma = tune()) %&gt;% \n   parsnip::set_engine(\"kernlab\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nsvm_p_spec &lt;- \n   parsnip::svm_poly(cost = tune(), degree = tune()) %&gt;% \n   parsnip::set_engine(\"kernlab\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\ncart_spec &lt;- \n   parsnip::decision_tree(cost_complexity = tune(), min_n = tune()) %&gt;% \n   parsnip::set_engine(\"rpart\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nbag_cart_spec &lt;- \n   parsnip::bag_tree() %&gt;% \n   parsnip::set_engine(\"rpart\", times = 50L) %&gt;% \n   parsnip::set_mode(\"classification\")\n\nrf_spec &lt;- \n   parsnip::rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %&gt;% \n   parsnip::set_engine(\"ranger\", importance = \"impurity\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nxgb_spec &lt;- \n   parsnip::boost_tree(tree_depth = tune(), learn_rate = tune(), loss_reduction = tune(), \n              min_n = tune(), sample_size = tune(), trees = tune()) %&gt;% \n   parsnip::set_engine(\"xgboost\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nnnet_spec &lt;- \n   parsnip::mlp(hidden_units = tune(), penalty = tune(), epochs = tune()) %&gt;% \n   parsnip::set_engine(\"nnet\", MaxNWts = 2600) %&gt;% \n   parsnip::set_mode(\"classification\")\n\nfda_spec &lt;- \n   parsnip::discrim_flexible(prod_degree = tune()) %&gt;%  #&lt;- use GCV to choose terms\n   parsnip::set_engine(\"earth\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\n\n\n\n5.1.4 Create workflow set\nNow we need to specify the workflows that will be followed for the different model types\n\n\nShow/hide code\nbalclr_3c_wf &lt;- \n   workflowsets::workflow_set(\n      preproc = list(balclr_3c = balclr_3c_rec), \n      models = list(\n        SVM_radial = svm_r_spec, \n        SVM_poly = svm_p_spec, \n        CART = cart_spec, \n        CART_bagged = bag_cart_spec,\n        NNET = nnet_spec,\n        boosting = xgb_spec,\n        fda = fda_spec,\n        RF = rf_spec)\n   )\n\nbalclr_3c_wf\n\n\n\n  \n\n\n\n\n\n5.1.5 Tune\nTrain and test performance for all the different models over the different train/test and 5-fold cv splits. This takes a long time to run…\n\n\nShow/hide code\nbalclr_3c_grid_results &lt;-\n   workflowsets::workflow_map(balclr_3c_wf, \n      seed = 1578,\n      resamples = balclr_3c_folds,\n      grid = 15,\n      control = tune::control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nreadr::write_rds(balclr_3c_grid_results, here::here(data_ml, \"model_tune_3_class.rds\"))\n\n\n\n\n5.1.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best according to area under the reciever operator curve\n\nShow/hide code\nmymetric &lt;- \"roc_auc\"\n\ntune::autoplot(\n  # bart fails must filter out\n  filter(balclr_3c_grid_results, wflow_id != \"balclr_3c_bart\"),\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Mean and standard deviation across train-test splits of the areas under the receiver operator curves for the different models. SVM_radial = Radial kernel Support Vector Classifier, SVM_poly = Polynomial kernel Support Vector Classifier, CART = classification and regression tree, CART_bagged = classification and regression tree with bootstrap aggregation (bagging), NNET = Neural Network Classifier, boosting = Gradient Boosted Trees Classifier (XGBoost), FDA = Flexible discriminant analysis (FDA) using MARS features, RF = Random Forest Classifier (Ranger).\n\n\n\n\n5.1.6.1 Peformance metrics\nDefines a function for easily extracting metrics of interest\n\n\nShow/hide code\ngetmymetrics &lt;- function(gridresults, myworkflow, mymetric, mysplit){\n  best_results &lt;- gridresults %&gt;% \n   workflowsets::extract_workflow_set_result(myworkflow) %&gt;% \n   tune::select_best(metric = mymetric)\n  \n   gridresults %&gt;% \n     hardhat::extract_workflow(myworkflow) %&gt;% \n     tune::finalize_workflow(best_results) %&gt;% \n     tune::last_fit(split = mysplit,\n             metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec))\n}\n\n\nCall the function to get performance metrics of different models\n\n\nShow/hide code\nset.seed(23784)\nbalclr_3c_SVM_radial_test_results &lt;- getmymetrics(balclr_3c_grid_results,\n                                                \"balclr_3c_SVM_radial\",\n                                                \"roc_auc\",\n                                                balclr_3c_split)\n\nbalclr_3c_SVM_poly_test_results &lt;- getmymetrics(balclr_3c_grid_results,\n                                                \"balclr_3c_SVM_poly\",\n                                                \"roc_auc\",\n                                                balclr_3c_split)\n\nbalclr_3c_CART_test_results &lt;- getmymetrics(balclr_3c_grid_results,\n                                                \"balclr_3c_CART\",\n                                                \"roc_auc\",\n                                                balclr_3c_split)\n\nbalclr_3c_CART_bagged_test_results &lt;- getmymetrics(balclr_3c_grid_results,\n                                                \"balclr_3c_CART_bagged\",\n                                                \"roc_auc\",\n                                                balclr_3c_split)\n\nbalclr_3c_NNET_test_results &lt;- getmymetrics(balclr_3c_grid_results,\n                                                \"balclr_3c_NNET\",\n                                                \"roc_auc\",\n                                                balclr_3c_split)\n\nbalclr_3c_boosting_test_results &lt;- getmymetrics(balclr_3c_grid_results,\n                                                \"balclr_3c_boosting\",\n                                                \"roc_auc\",\n                                                balclr_3c_split)\n\nbalclr_3c_fda_test_results &lt;- getmymetrics(balclr_3c_grid_results,\n                                          \"balclr_3c_fda\",\n                                          \"roc_auc\",\n                                          balclr_3c_split)\n\nbalclr_3c_rf_test_results &lt;- getmymetrics(balclr_3c_grid_results,\n                                          \"balclr_3c_RF\",\n                                          \"roc_auc\",\n                                          balclr_3c_split)\n\n\nDefines a function to collect and format metrics of different models and calls the function on all the different trained models\n\n\nShow/hide code\ncollect_format &lt;- function(res, name){\n  tune::collect_metrics(res) %&gt;%\n    dplyr::select(metric = .metric,\n                {{ name }} := .estimate,\n                estimate_type = .estimator)\n}\n\ncollect_format(balclr_3c_SVM_radial_test_results, \"SVM_rad\") %&gt;% \n  dplyr::left_join(collect_format(balclr_3c_SVM_poly_test_results, \"SVM_poly\"), by = join_by(metric, estimate_type)) %&gt;%\n  dplyr::left_join(collect_format(balclr_3c_CART_test_results, \"CART\"), by = join_by(metric, estimate_type)) %&gt;%\n  dplyr::left_join(collect_format(balclr_3c_CART_bagged_test_results, \"CART_bag\"), by = join_by(metric, estimate_type)) %&gt;%\n  dplyr::left_join(collect_format(balclr_3c_NNET_test_results, \"NNET\"), by = join_by(metric, estimate_type)) %&gt;%\n  dplyr::left_join(collect_format(balclr_3c_boosting_test_results, \"boosting\"), by = join_by(metric, estimate_type)) %&gt;%\n  dplyr::left_join(collect_format(balclr_3c_fda_test_results, \"FDA\"), by = join_by(metric, estimate_type)) %&gt;% \n  dplyr::left_join(collect_format(balclr_3c_rf_test_results, \"random_forest\"), by = join_by(metric, estimate_type)) %&gt;% \n  dplyr::relocate(estimate_type, metric)\n\n\n\n  \n\n\n\nOverall it looks like Gradient boosting is performing the best so we will go with that model\n\n\n5.1.6.2 ROC-curve for chosen model\nThis is a useful resource for understanding ROC curves and PR curves.\nROC curves here indicate that there is quite good performance for the gradient boosting model in distinguishing the evolutionary history of any particular microcosm from the experiment!\n\nShow/hide code\nbalclr_3c_boosting_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::roc_curve(home_env_3c, .pred_anc:.pred_bact_strep) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: ROC curve for True positive rate (TPR, vertical axis) versus the false positive rate (FPR, horizontal axis) for the three different evolutionary histories in the experiment from the hold-out testing data. The dashed 1:1 line is the expected performance of a random classifier. Curves above the 1:1 are better performance than random. Curves below 1:1 are worse performance than random.\n\n\n\n\nShow/hide code\nbalclr_3c_boosting_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::pr_curve(home_env_3c, .pred_anc:.pred_bact_strep) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Precision recall curves for the three different evolutionary histories in the experiment from the hold-out testing data. There is a good tuorial for interpretation of these plots on scikit-learn. All of them suggest good performance.\n\n\n\n\n\n5.1.6.3 Confusion matrix\nThe confusion matrix shows that the model is doing a very nice job predicting whether the community had an ancestral origin while there are only two mixups for the other two classes combined. Again this is quite good performance…\n\nShow/hide code\nbalclr_3c_boosting_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::conf_mat(home_env_3c, .pred_class) %&gt;%\n  tune::autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Confusion matrix showing the classifier performance on each of the three evolutionary history classes using the hold-out testing data.\n\n\n\n\n\n5.1.6.4 Probability distributions for the 3 classes\nGradient boosting trees give each prediction a probability for every class. The higher the probability the higher the confidence in the prediction. We can visualize the distribution of these prediction probabilities to get some insight as to which classes the model has trouble distinguishing and which are very clearly separated.\n\nShow/hide code\nbalclr_3c_boosting_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  tidyr::pivot_longer(c(\n    .pred_anc,\n    .pred_bact,\n    .pred_bact_strep\n  )) %&gt;%\n  ggplot2::ggplot() +\n  ggplot2::geom_density(aes(x = value, fill = home_env_3c), alpha = 0.5) +\n  ggplot2::labs(x = \"Prediction Probability\", y = \"Density\") +\n  ggplot2::facet_wrap( ~ name)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Prediction probability densities (colors) for each observation of the three evolutionary history classes (grid columns) tested with the model.",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/strep_only/communities/amplicon_sp_counts/01_format_rbec_tab.html",
    "href": "R/strep_only/communities/amplicon_sp_counts/01_format_rbec_tab.html",
    "title": "Data formatting of Rbec output from 20240318_BTK_illumina_v3",
    "section": "",
    "text": "Loads required libraries\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(archive)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\nSets some important variables for the analysis. In particular it defines a temporary location on disk to decompress the Rbec tarball\n\n\nShow/hide code\ndata_raw &lt;- here::here(\"_data_raw\", \"communities\", \"20240318_BTK_illumina_v3\")\namplicontar &lt;- here::here(data_raw, \"rbec_output.tar.gz\")\n\n# create temporary location to decompress\ntmpdir &lt;- fs::file_temp()\n\n\n\n\nThis tibble contains information mapping rRNA 16S locus tags to species and also total copy number of 16S rRNAs in each genome\n\n\nShow/hide code\ntax_locus_copynum &lt;- tibble::tribble(\n     ~strainID, ~rRNA16S_cn, ~rRNA16S_locus,             ~genus,        ~species,\n  \"HAMBI_0006\",          7L,  \"H0006_04757\",      \"Pseudomonas\",        \"putida\",\n  \"HAMBI_0097\",          7L,  \"H0097_00044\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_02759\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_01762\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0105\",          4L,  \"H0105_02306\",    \"Agrobacterium\",   \"tumefaciens\",\n  \"HAMBI_0262\",          3L,  \"H0262_00030\",    \"Brevundimonas\",       \"bullata\",\n  \"HAMBI_0403\",          9L,  \"H0403_00517\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_0403\",          9L,  \"H0403_00522\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_1279\",          7L,  \"H1279_03627\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_00125\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_03957\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1287\",          7L,  \"H1287_03997\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1287\",          7L,  \"H1287_03402\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1292\",          7L,  \"H1292_03239\",       \"Morganella\",      \"morganii\",\n  \"HAMBI_1299\",          8L,  \"H1299_04293\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1299_01283\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1279_03957\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1842\",          4L,  \"H1842_01650\",      \"Sphingobium\",    \"yanoikuyae\",\n  \"HAMBI_1896\",          4L,  \"H1896_00963\", \"Sphingobacterium\",  \"spiritivorum\",\n  \"HAMBI_1972\",         10L,  \"H1972_00343\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1972\",         10L,  \"H1972_03531\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1977\",          5L,  \"H1977_00118\",      \"Pseudomonas\",  \"chlororaphis\",\n  \"HAMBI_1988\",          5L,  \"H1988_05160\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05152\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05165\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_2159\",          4L,  \"H2159_01406\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2159\",          4L,  \"H2159_05851\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2160\",          3L,  \"H2160_00530\",       \"Bordetella\",         \"avium\",\n  \"HAMBI_2164\",          5L,  \"H2164_03337\",      \"Cupriavidus\",    \"oxalaticus\",\n  \"HAMBI_2443\",          3L,  \"H2443_00128\",       \"Paracoccus\", \"denitrificans\",\n  \"HAMBI_2494\",          4L,  \"H2494_03389\", \"Paraburkholderia\",   \"kururiensis\",\n  \"HAMBI_2659\",          4L,  \"H2659_00367\", \"Stenotrophomonas\",   \"maltophilia\",\n  \"HAMBI_2792\",          4L,  \"H2792_00549\",        \"Moraxella\",         \"canis\",\n  \"HAMBI_3031\",          2L,  \"H3031_00830\",         \"Niabella\",  \"yanshanensis\",\n  \"HAMBI_3237\",          6L,  \"H3237_00875\",       \"Microvirga\",   \"lotononidis\",\n  \"HAMBI_1923\",          6L,  \"H1923_00876\",   \"Flavobacterium\",      \"odoratum\"\n  )\n\n\n\n\n\nThese are functions to aid in reading and processing output from Rbec\n\n\nShow/hide code\n# this function \nnormalize_by_copy &lt;- function(.data, tlc = tax_locus_copynum){\n  .data %&gt;% \n    # join with the copy number data frame. We join by the locus tag so this will add H1279_03957 to HAMBI_1299\n    dplyr::left_join(tlc, by = join_by(rRNA16S_locus), relationship = \"many-to-many\") %&gt;%\n    # get total number of mapping reads per species. This aggregates all the difference ASVs per species\n    dplyr::summarize(count = sum(count), .by = c(sample, strainID, rRNA16S_cn)) %&gt;% \n    # group by sample\n    dplyr::group_by(sample) %&gt;% \n    # calculate a corrected count which is simply the count divided by copy num for each species\n    # dividide by the sum of count divided by copy num for whole sample multiplied by the total\n    # number of mapped reads per sample\n    dplyr::mutate(count_correct = round(sum(count)*(count/rRNA16S_cn)/sum(count/rRNA16S_cn))) %&gt;%  \n    dplyr::ungroup() %&gt;% \n    dplyr::select(sample, strainID, count, count_correct)\n  }\n\n# this function replaces missing species counts with zero\ncompletecombos &lt;- function(.data, tlc = tax_locus_copynum, countname = count, remove1923 = TRUE){\n \n  # get unique strainIDs\n  strainID &lt;- unique(tlc$strainID)\n  # table for assigning genus and species names. Doesn't matter if 1923 is there or not\n  # because it is filter joined later\n  tax &lt;- dplyr::distinct(dplyr::select(tlc, strainID, genus, species))\n  if (remove1923) {\n    # get unique strainIDs but exclude 1923 if remove1923 is true\n    strainID &lt;- strainID[strainID != \"HAMBI_1923\"]\n  }\n  \n  dplyr::bind_rows(tibble::tibble(strainID = strainID, sample = \"dummy\"), .data) %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(sample == \"dummy\", 1, {{ countname }})) %&gt;% \n    tidyr::complete(sample, strainID) %&gt;% \n    dplyr::filter(sample != \"dummy\") %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(is.na({{ countname }}), 0, {{ countname }})) %&gt;% \n    tidyr::replace_na(list(count_correct = 0)) %&gt;% \n    dplyr::left_join(dplyr::distinct(dplyr::select(tlc, strainID, genus, species)), by = join_by(strainID)) %&gt;% \n    dplyr::relocate(genus, species, .after = strainID)\n}",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "i) Amplicon data wrangling"
    ]
  },
  {
    "objectID": "R/strep_only/communities/amplicon_sp_counts/01_format_rbec_tab.html#s-copy-number-information",
    "href": "R/strep_only/communities/amplicon_sp_counts/01_format_rbec_tab.html#s-copy-number-information",
    "title": "Data formatting of Rbec output from 20240318_BTK_illumina_v3",
    "section": "",
    "text": "This tibble contains information mapping rRNA 16S locus tags to species and also total copy number of 16S rRNAs in each genome\n\n\nShow/hide code\ntax_locus_copynum &lt;- tibble::tribble(\n     ~strainID, ~rRNA16S_cn, ~rRNA16S_locus,             ~genus,        ~species,\n  \"HAMBI_0006\",          7L,  \"H0006_04757\",      \"Pseudomonas\",        \"putida\",\n  \"HAMBI_0097\",          7L,  \"H0097_00044\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_02759\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_01762\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0105\",          4L,  \"H0105_02306\",    \"Agrobacterium\",   \"tumefaciens\",\n  \"HAMBI_0262\",          3L,  \"H0262_00030\",    \"Brevundimonas\",       \"bullata\",\n  \"HAMBI_0403\",          9L,  \"H0403_00517\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_0403\",          9L,  \"H0403_00522\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_1279\",          7L,  \"H1279_03627\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_00125\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_03957\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1287\",          7L,  \"H1287_03997\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1287\",          7L,  \"H1287_03402\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1292\",          7L,  \"H1292_03239\",       \"Morganella\",      \"morganii\",\n  \"HAMBI_1299\",          8L,  \"H1299_04293\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1299_01283\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1279_03957\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1842\",          4L,  \"H1842_01650\",      \"Sphingobium\",    \"yanoikuyae\",\n  \"HAMBI_1896\",          4L,  \"H1896_00963\", \"Sphingobacterium\",  \"spiritivorum\",\n  \"HAMBI_1972\",         10L,  \"H1972_00343\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1972\",         10L,  \"H1972_03531\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1977\",          5L,  \"H1977_00118\",      \"Pseudomonas\",  \"chlororaphis\",\n  \"HAMBI_1988\",          5L,  \"H1988_05160\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05152\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05165\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_2159\",          4L,  \"H2159_01406\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2159\",          4L,  \"H2159_05851\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2160\",          3L,  \"H2160_00530\",       \"Bordetella\",         \"avium\",\n  \"HAMBI_2164\",          5L,  \"H2164_03337\",      \"Cupriavidus\",    \"oxalaticus\",\n  \"HAMBI_2443\",          3L,  \"H2443_00128\",       \"Paracoccus\", \"denitrificans\",\n  \"HAMBI_2494\",          4L,  \"H2494_03389\", \"Paraburkholderia\",   \"kururiensis\",\n  \"HAMBI_2659\",          4L,  \"H2659_00367\", \"Stenotrophomonas\",   \"maltophilia\",\n  \"HAMBI_2792\",          4L,  \"H2792_00549\",        \"Moraxella\",         \"canis\",\n  \"HAMBI_3031\",          2L,  \"H3031_00830\",         \"Niabella\",  \"yanshanensis\",\n  \"HAMBI_3237\",          6L,  \"H3237_00875\",       \"Microvirga\",   \"lotononidis\",\n  \"HAMBI_1923\",          6L,  \"H1923_00876\",   \"Flavobacterium\",      \"odoratum\"\n  )",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "i) Amplicon data wrangling"
    ]
  },
  {
    "objectID": "R/strep_only/communities/amplicon_sp_counts/01_format_rbec_tab.html#functions",
    "href": "R/strep_only/communities/amplicon_sp_counts/01_format_rbec_tab.html#functions",
    "title": "Data formatting of Rbec output from 20240318_BTK_illumina_v3",
    "section": "",
    "text": "These are functions to aid in reading and processing output from Rbec\n\n\nShow/hide code\n# this function \nnormalize_by_copy &lt;- function(.data, tlc = tax_locus_copynum){\n  .data %&gt;% \n    # join with the copy number data frame. We join by the locus tag so this will add H1279_03957 to HAMBI_1299\n    dplyr::left_join(tlc, by = join_by(rRNA16S_locus), relationship = \"many-to-many\") %&gt;%\n    # get total number of mapping reads per species. This aggregates all the difference ASVs per species\n    dplyr::summarize(count = sum(count), .by = c(sample, strainID, rRNA16S_cn)) %&gt;% \n    # group by sample\n    dplyr::group_by(sample) %&gt;% \n    # calculate a corrected count which is simply the count divided by copy num for each species\n    # dividide by the sum of count divided by copy num for whole sample multiplied by the total\n    # number of mapped reads per sample\n    dplyr::mutate(count_correct = round(sum(count)*(count/rRNA16S_cn)/sum(count/rRNA16S_cn))) %&gt;%  \n    dplyr::ungroup() %&gt;% \n    dplyr::select(sample, strainID, count, count_correct)\n  }\n\n# this function replaces missing species counts with zero\ncompletecombos &lt;- function(.data, tlc = tax_locus_copynum, countname = count, remove1923 = TRUE){\n \n  # get unique strainIDs\n  strainID &lt;- unique(tlc$strainID)\n  # table for assigning genus and species names. Doesn't matter if 1923 is there or not\n  # because it is filter joined later\n  tax &lt;- dplyr::distinct(dplyr::select(tlc, strainID, genus, species))\n  if (remove1923) {\n    # get unique strainIDs but exclude 1923 if remove1923 is true\n    strainID &lt;- strainID[strainID != \"HAMBI_1923\"]\n  }\n  \n  dplyr::bind_rows(tibble::tibble(strainID = strainID, sample = \"dummy\"), .data) %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(sample == \"dummy\", 1, {{ countname }})) %&gt;% \n    tidyr::complete(sample, strainID) %&gt;% \n    dplyr::filter(sample != \"dummy\") %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(is.na({{ countname }}), 0, {{ countname }})) %&gt;% \n    tidyr::replace_na(list(count_correct = 0)) %&gt;% \n    dplyr::left_join(dplyr::distinct(dplyr::select(tlc, strainID, genus, species)), by = join_by(strainID)) %&gt;% \n    dplyr::relocate(genus, species, .after = strainID)\n}",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "i) Amplicon data wrangling"
    ]
  },
  {
    "objectID": "R/strep_only/communities/amplicon_sp_counts/01_format_rbec_tab.html#metadata",
    "href": "R/strep_only/communities/amplicon_sp_counts/01_format_rbec_tab.html#metadata",
    "title": "Data formatting of Rbec output from 20240318_BTK_illumina_v3",
    "section": "2.1 Metadata",
    "text": "2.1 Metadata\nReads metadata for the samples\n\n\nShow/hide code\nmddf &lt;- readr::read_tsv(here::here(data_raw, \"20240318_BTK_illumina_v3_metadata.tsv\"))",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "i) Amplicon data wrangling"
    ]
  },
  {
    "objectID": "R/strep_only/communities/amplicon_sp_counts/01_format_rbec_tab.html#rbec",
    "href": "R/strep_only/communities/amplicon_sp_counts/01_format_rbec_tab.html#rbec",
    "title": "Data formatting of Rbec output from 20240318_BTK_illumina_v3",
    "section": "2.2 Rbec",
    "text": "2.2 Rbec\nUntar Rbec output tarball which contains raw counts tables\n\n\nShow/hide code\narchive::archive_extract(\n  amplicontar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)\n\n\nSets up directory structure for decompressing\n\n\nShow/hide code\ntabdir &lt;- here::here(tmpdir, \"rbec_output\")\nsamppaths &lt;- fs::dir_ls(tabdir)\nsampnames &lt;- fs::path_split(samppaths) %&gt;% \n  purrr::map_chr(dplyr::last)\n\n\nReads all the strain_table.txt files in a loop\n\n\nShow/hide code\nstraintabs &lt;- paste0(samppaths, \"/strain_table.txt\") %&gt;% \n  purrr::set_names(sampnames) %&gt;% \n  purrr::map(\n  readr::read_tsv,\n  skip = 1,\n  col_names = c(\"rRNA16S_locus\",\"count\"),\n  show_col_types = FALSE) %&gt;% \n  purrr::list_rbind(names_to = \"sample\")",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "i) Amplicon data wrangling"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/02_growthrate_auc.html",
    "href": "R/strep_only/monocultures/clone_phenotyping/02_growthrate_auc.html",
    "title": "Estimate Area Under the Curve (AUC) and growth rates",
    "section": "",
    "text": "Load required packages\n\n\nShow/hide code\nlibrary(here)\nlibrary(tidyverse)\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nlibrary(growthrates)\nlibrary(DescTools)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\nFunctions to simplify plotting later\n\n\nShow/hide code\nplotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, well, plate), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      ggplot2::geom_line(aes(y=OD600_smooth_avg), color = \"blue\"), \n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 2)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ well, nrow = rows, ncol = cols, page = page), #scales = \"free_y\"\n      ggplot2::theme(axis.text = element_text(size = 9))\n    )\n}",
    "crumbs": [
      "3. Clones workflow (STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/02_growthrate_auc.html#bact-conditions",
    "href": "R/strep_only/monocultures/clone_phenotyping/02_growthrate_auc.html#bact-conditions",
    "title": "Estimate Area Under the Curve (AUC) and growth rates",
    "section": "6.1 Bact conditions",
    "text": "6.1 Bact conditions\n\n6.1.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Growth curves for the bacteria only conditions on Plate 1. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Growth curves for the bacteria only conditions on Plate 2. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Growth curves for the bacteria only conditions on Plate 3. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Growth curves for the bacteria only conditions on Plate 4. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Growth curves for bacteria only conditions on Plate 5. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Growth curves for bacteria only conditions on Plate 6. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Growth curves for bacteria only conditions on Plate 7. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Growth curves for bacteria only conditions on Plate 8. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "3. Clones workflow (STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/02_growthrate_auc.html#streptomycin-conditions",
    "href": "R/strep_only/monocultures/clone_phenotyping/02_growthrate_auc.html#streptomycin-conditions",
    "title": "Estimate Area Under the Curve (AUC) and growth rates",
    "section": "6.2 Streptomycin conditions",
    "text": "6.2 Streptomycin conditions\n\n6.2.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Growth curves for the Streptomycin conditions on Plate 1. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Growth curves for the Streptomycin conditions on Plate 2. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Growth curves for the Streptomycin conditions on Plate 3. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Growth curves for the Streptomycin conditions on Plate 4. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Growth curves for Streptomycin conditions on Plate 5. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Growth curves for Streptomycin conditions on Plate 6. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Growth curves for Streptomycin conditions on Plate 7. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Growth curves for Streptomycin conditions on Plate 8. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "3. Clones workflow (STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html",
    "href": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html",
    "title": "Analysis of growth summary data",
    "section": "",
    "text": "Load required packages\n\n\nShow/hide code\nlibrary(here)\nlibrary(tidyverse)\nlibrary(stringr)\nlibrary(fs)\nlibrary(ggforce)\nlibrary(patchwork)\nlibrary(easystats)\nlibrary(brms)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\ndata_raw &lt;- here::here(\"_data_raw\", \"monocultures\", \"20230112_clone_phenotyping\")",
    "crumbs": [
      "3. Clones workflow (STR)",
      "iii) Analysis and plot"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html#plot-raw-data",
    "href": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html#plot-raw-data",
    "title": "Analysis of growth summary data",
    "section": "4.1 Plot raw data",
    "text": "4.1 Plot raw data\n\nShow/hide code\np01 &lt;- ggplot2::ggplot(auc_gr_md, aes(x = interaction(measure_env, evolution_env), y = auc)) +\n  ggplot2::geom_point(position=position_jitter(width=0.35), size=3, alpha = 0.35, stroke = 0) +\n  ggplot2::labs(x = \"Measure env:Evol hist\", y = \"Area under growth curve (AUC, unitless)\") +\n  ggplot2::theme_bw()\n\np01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Area under the growth curve for 32 randomly isolated clones from six replicates of each evolutionary history (background/bact, streptomcyin/bact_strep) grown either with or without streptomycin (bact or bact_strep, respectively). The horizontal axis shows the interaction of evolutionary history and measurement environment (e.g., the first column shows background evolved bacteria grown without streptomycin).\n\n\n\nA couple features to note… The difference in AUC with or without streptomycin appears small for streptomycin evolved clones (bact_strep:bact vs bact_strep:bact_strep). Clones from the streptomycin evolved community do not obviously appear to have suffered some kind of cost of resistance when growing without streptomycin. However, the differences in AUC with/without streptomycin are quite large for clones isolated from the background-evolved communities (bact:bact vs bact:bact_strep). Thus, many streptomycin sensitive clones appear to have been isolated from background community.",
    "crumbs": [
      "3. Clones workflow (STR)",
      "iii) Analysis and plot"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html#lmm-fit",
    "href": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html#lmm-fit",
    "title": "Analysis of growth summary data",
    "section": "4.2 LMM fit",
    "text": "4.2 LMM fit\nThis models auc as a function of evolution history the measurement condition and the interaction between the two. We used replicate with clone_id nested within replicate as random effects (clones were measured more than once). We are using brms here so the traditional frequentist p-value doesn’t apply. Instead we think about the proportion of the posterior that has a consistent direction (e.g., over/under 0).\n\n\nShow/hide code\nset.seed(37814)\nbrmmod &lt;- brms::brm(auc ~ evolution_env*measure_env + (1|replicate/clone_id), data = auc_gr_md)\n\n\n\n4.2.1 Posterior predictive check\ndoesn’t suggest anything amiss\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Density overlay posterior predictive check from 50 posterior draws. Vertical = density distribution of posterior (yrep) compared to observed data (y), horizontal = AUC values\n\n\n\n\n\n4.2.2 Convergence check\nAll chains appear to have converged\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Left: histogram of estimated model parameters. Right: traces of MCMC chains\n\n\n\n\n\n4.2.3 Model parameters\n\n\nShow/hide code\nparameters::model_parameters(brmmod)\n\n\n\n  \n\n\n\n\n\n4.2.4 Model Contrasts\n\n\nShow/hide code\nmodelbased::estimate_contrasts(brmmod, contrast = c(\"evolution_env\", \"measure_env\"))\n\n\n\n  \n\n\n\nWhat the contrast analysis shows is what was apparent from looking at Figure 1. Basically, clones from the streptomycin evolved communities don’t have significant growth differences with or without streptomycin, while clones from the background evolved communities do. This is pretty unsurprising I think.",
    "crumbs": [
      "3. Clones workflow (STR)",
      "iii) Analysis and plot"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html#plot-strep-sensitivity",
    "href": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html#plot-strep-sensitivity",
    "title": "Analysis of growth summary data",
    "section": "5.1 Plot strep sensitivity",
    "text": "5.1 Plot strep sensitivity\n\n\nShow/hide code\npexg &lt;- tidyr::drop_na(auc_gr_md_subset) %&gt;% \n  ggplot2::ggplot(aes(x = evolution_env, y = fitness)) +\n  ggplot2::geom_boxplot(data = filter(auc_gr_md_subset, fitness &lt; 5), outliers = FALSE) +\n  ggplot2::geom_point(position=position_jitter(width=0.35), size=3, alpha = 0.35, stroke = 0) +\n  ggplot2::labs(x = \"Home environment\", y = \"STR sensitivity\") +\n  ggforce::facet_zoom(y = flag == TRUE) +\n  ggplot2::theme_bw()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Community streptomycin sensitivity from different evolutionary histories of the pre-experiment.",
    "crumbs": [
      "3. Clones workflow (STR)",
      "iii) Analysis and plot"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html#sensitivity-of-intrinisically-resistant-clones",
    "href": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html#sensitivity-of-intrinisically-resistant-clones",
    "title": "Analysis of growth summary data",
    "section": "5.2 Sensitivity of intrinisically resistant clones",
    "text": "5.2 Sensitivity of intrinisically resistant clones\nNote that above we observed clones from both evolution treatments that were intrinsically resistant to streptomycin. One question is whether the resistant clones from the background evolved community have a higher streptomycin sensitivity compared to resistant clones from the streptomycin evolved community. I would predict that clones from the background community that were already quite streptomycin resistant have a higher (\\(S\\)) sensitivity than those from the streptomycin evolved community because clones from the strep community would have had time to adapt/evolve to streptomycin.\nWe can test this prediction using a linear model for (\\(S\\)) sensitivity as a function of the evolution environment. First we filter to only include intrinsically resistant clones (operationally defined as those with sensitivity less than 5). Then we fit the model but with zero intercept so that we compare each group to 0 instead of using one group as the intercept.\n\n\nShow/hide code\nauc_gr_md_subset_filt &lt;- auc_gr_md_subset %&gt;% \n  filter(flag == T) %&gt;% \n  mutate(evolution_env = factor(evolution_env, levels = c(\"bact\", \"bact_strep\")))\n\n\n\n5.2.1 LMM Fit\n\n\nShow/hide code\nset.seed(8435)\nbrmmod0 &lt;- brms::brm(fitness ~ 0 + evolution_env + (1|replicate), data = auc_gr_md_subset_filt)\n\n\n\n\n5.2.2 Posterior predictive check\ndoesn’t suggest anything amiss\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Density overlay posterior predictive check from 50 posterior draws. Vertical = density distribution of posterior (yrep) compared to observed data (y), horizontal = AUC values\n\n\n\n\n\n5.2.3 Convergence check\nAll chains appear to have converged\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Left: histogram of estimated model parameters. Right: traces of MCMC chains\n\n\n\n\n\n5.2.4 Model parameters\n\n\nShow/hide code\nparameters::model_parameters(brmmod0)\n\n\n\n  \n\n\n\nSo the results from the zero intercept model show that resistant clones from the background evolutionary history have a median Streptomycin sensitivity of 0.43 with a probability of direction (pd) of 95.5% while clones from the streptomycin evolutionary history communities have a mean sensitivity of -0.06 with a pd of about 62%. Sensitivity from the streptomycin history is statistically indistinguishable from zero, which makes sense and is consistent with what we saw in Figure 4.\nHowever, it seems that resistant clones from the background community have a small but significantly higher sensitivity to streptomycin. Overall I don’t think this is too surprising that naturally resistant clones isolated from the evolution conditions with streptomycin are less sensitive to stretomycin than those that were evolving without it.",
    "crumbs": [
      "3. Clones workflow (STR)",
      "iii) Analysis and plot"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html#export",
    "href": "R/strep_only/monocultures/clone_phenotyping/03_growth_summary_analysis.html#export",
    "title": "Analysis of growth summary data",
    "section": "6.1 Export",
    "text": "6.1 Export\n\n\nShow/hide code\nggplot2::ggsave(\n  here::here(figs, \"monoculture_clone_phenotyping_auc.svg\"),\n  pf,\n  width = 7,\n  height = 7,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(figs, \"monoculture_clone_phenotyping_auc.png\"),\n  pf,\n  width = 7,\n  height = 7,\n  units = \"in\",\n  device = \"png\"\n)",
    "crumbs": [
      "3. Clones workflow (STR)",
      "iii) Analysis and plot"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/amplicon_sp_counts/02_composition_analysis.html",
    "href": "R/strep_predator/communities/amplicon_sp_counts/02_composition_analysis.html",
    "title": "Predator and STR Community species composition workflow ii) analysis of community composition",
    "section": "",
    "text": "1 Setup\nLoads required libraries and sets global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(Rtsne)\nlibrary(patchwork)\nlibrary(philentropy)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n2 Read data\nRead species abundance data (16S v3 amplicon counts) and do some light formatting of metadata\n\n\nShow/hide code\nsptable &lt;- readr::read_tsv(here::here(data_stp_sp, \"species_counts_md.tsv\")) %&gt;% \n  dplyr::mutate(transfer = day/7)\n\ncounts_f &lt;- sptable %&gt;% \n  dplyr::group_by(sample) %&gt;% \n  dplyr::mutate(f=count_correct/sum(count_correct)) %&gt;% \n  dplyr::ungroup() %&gt;% \n  dplyr::mutate(measure_env_short = dplyr::case_when(measure_env == \"bact\" ~ \"Meas: B\",\n                                       measure_env == \"bact_pred\" ~ \"Meas: BP\",\n                                       measure_env == \"bact_strep\" ~ \"Meas: BS\",\n                                       measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\")) %&gt;% \n  dplyr::mutate(home_env_short = dplyr::case_when(evolution_env == \"anc\" ~ \"Home: Anc\",\n                                    evolution_env == \"bact\" ~ \"Home: B\",\n                                    evolution_env == \"bact_pred\" ~ \"Home: BP\",\n                                    evolution_env == \"bact_strep\" ~ \"Home: BS\",\n                                    evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\")) %&gt;% \n  dplyr::mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\n\n\n\n3 Formatting\nSome light formatting to subset data into distint tibbles for later plotting\n\n\nShow/hide code\n# these are communities of a (supposedly) known composition. Can be used with metacal\npos_ctrl_samples &lt;- counts_f %&gt;% \n  dplyr::filter(str_detect(sample, \"pos_ctrl\"))\n\n# these are samples taken directly from YSK and represent the composition of the communities used to start the experiment\nt0_samples &lt;- counts_f %&gt;% \n  dplyr::filter(!str_detect(sample, \"pos_ctrl\")) %&gt;% \n  dplyr::filter(day == 0)\n\n# only samples from the experiment\ncounts_f_experiment &lt;- dplyr::anti_join(counts_f, pos_ctrl_samples) %&gt;% \n  dplyr::anti_join(., t0_samples) %&gt;% \n  dplyr::mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\n\n\n\n4 Visualize Community composition\nUsing ggplot2 to plot bar plots of species composition from the experiment and the intial material used to seed the experiment\n\n\nShow/hide code\n# custom barplot theme\nmybartheme &lt;- function(...){\n  ggplot2::theme(\n    panel.spacing = unit(0.5,\"line\"),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n    panel.grid = element_blank(),\n    panel.border = element_blank(),\n    panel.background = element_blank(),\n    #axis.text.x = element_blank(),\n    axis.line.x = element_line(color = \"black\"),\n    axis.line.y = element_line(color = \"black\"),\n    legend.title = element_blank(),\n    legend.background = element_blank(),\n    legend.key = element_blank(),\n    legend.position = \"bottom\",\n    ...)\n}\n\n# Base function for making the subplots\nbasebar &lt;- function(.data, x = x, xlab = xlab, xgrid = NULL){\n  ggplot2::ggplot(.data) +\n  ggplot2::geom_bar(aes(y = f, x = {{ x }}, fill = strainID), color=\"black\", linewidth=0.25, stat=\"identity\") +\n  ggplot2::labs(x = xlab, y=\"% abundance\", fill=\"\") + \n  ggplot2::scale_fill_manual(values = hambi_colors) + \n  ggplot2::scale_y_continuous(limits = c(0,1.01), expand = c(0, 0), labels = percent) +\n  ggplot2::scale_x_discrete(guide = ggh4x::guide_axis_nested()) +\n  ggplot2::theme_bw() +\n  mybartheme()\n}\n\nA &lt;- t0_samples %&gt;% \n  dplyr::filter(evolution_env == \"anc\") %&gt;% \n  basebar(x = replicate, xlab = \"Replicate\") +\n  ggplot2::facet_grid( ~ home_env_short)\n\nB &lt;- t0_samples %&gt;% \n  dplyr::filter(evolution_env != \"anc\") %&gt;% \n  basebar(x = replicate, xlab = \"Replicate\") +\n  ggplot2::facet_grid( ~ home_env_short)\n\nC &lt;- counts_f_experiment %&gt;% \n  dplyr::filter(evolution_env == \"anc\") %&gt;% \n  basebar(x = interaction(replicate, transfer), xlab = \"Replicate | Growth Cycle\") +\n  ggplot2::facet_grid(measure_env_short ~ home_env_short)\n\nD &lt;- counts_f_experiment %&gt;% \n  dplyr::filter(evolution_env != \"anc\") %&gt;% \n  basebar(x = interaction(replicate, transfer), xlab = \"Replicate | Growth Cycle\") +\n  ggplot2::facet_grid(measure_env_short ~ home_env_short)\n\n\nMakes a final patchwork object and saves the results as raster and vector\n\n\nShow/hide code\nlayout &lt;- \"\nABBBB\nCDDDD\n\"\n\npbar &lt;- A + B + C + D  +\n  patchwork::plot_layout(guides = 'collect', heights = c(0.2, 0.9), \n              design = layout) +\n  patchwork::plot_annotation(tag_levels = 'A') &\n  ggplot2::theme(legend.position='bottom')\n\nggplot2::ggsave(\n  here::here(figs_stp, \"community_composition_bar_plot.svg\"),\n  pbar,\n  width = 8,\n  height = 10,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(figs_stp, \"community_composition_bar_plot.png\"),\n  pbar,\n  width = 8,\n  height = 10,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Relative abundance (Y axis, percent) of species from replicate microcosms (X axis, A-F). A) Community composition of the ancestral/clonal replicates inocula used to start experiments in C. B) Composition of the long-term community evolution experiment (YSK, week X) communities from each selection condition. These communities were used to inoculate the transplantation experiment in part D. C) Composition of the ancestral/clonal replicate communities after 4, 8, and 12 transfers in each measurement environment (grid rows). D) Composition of the YSK communities (grid columns, “home” environment) subjected to all possible measurement conditions (grid rows). B = bacteria grown without amendment, BS = streptomycin treatment, BP = Tetrahymena thermophila treatment, BPS = combined Tetrahymena thermophila and streptomycin treatment.\n\n\n\n\n\n5 tSNE dimension reduction of community composition\nSome preliminary inspections of the number of samples with zeros. This is needed for zcompositions\n\n\nShow/hide code\ncounts_f_experiment %&gt;% \n  dplyr::group_by(strainID) %&gt;% \n  dplyr::summarize(n_samples = n(),\n            n_gt0 = sum(count &gt; 0),\n            p_gt0 = n_gt0 / n_samples) %&gt;% \n  dplyr::ungroup() %&gt;% \n  dplyr::arrange(n_gt0)\n\n\n\n  \n\n\n\nHere we will use the centered log-ratio transformation for the species abundances. The centered log-ratio can be interpreted as the log-fold change of species i relative to the average microbe in a sample. The formula for the transformation is:\n\\[\n\\text{clr}(\\mathbf x)= \\left(log\n\\frac{x_i}{g(\\mathbf x)} \\right)_{i=1,...,D} \\qquad \\text{with} \\quad\ng(\\mathbf x) = \\left(\\prod_{i=1}^Dx_i\\right)^{1/D} =\n\\exp\\left(\\frac{1}{D}\\sum_{i=1}^D \\log x_i\\right)\\text{,}\n\\tag{1}\\]\nWe will use the implementation of centered log-ratio transform in the compositions package\n\n\nShow/hide code\nset.seed(234781)\n\n# exclude these species because they have too many zeros\nlowstrainsv &lt;- c(\n  \"HAMBI_0097\",\n  \"HAMBI_2792\"\n)\n\n# make a species count matrix\nmymat &lt;- counts_f_experiment %&gt;% \n  dplyr::filter(!(strainID %in% lowstrainsv)) %&gt;% \n  dplyr::select(sample, strainID, count) %&gt;% \n  dplyr::mutate(count = count + 1) %&gt;% \n  # important to arrange by sample as this makes some later joins easier\n  dplyr::arrange(sample) %&gt;% \n  tidyr::pivot_wider(names_from = \"strainID\", values_from = \"count\") %&gt;% \n  tibble::column_to_rownames(var = \"sample\") %&gt;% \n  data.frame()\n\n# calculate clr\nbalclr &lt;- compositions::clr(mymat)\n\n# tsne\nmymat_tsne &lt;- Rtsne::Rtsne(as.matrix(balclr), perplexity = 30, dims = 2)\n\n\nDefine a plotting function to plot the tSNE output\n\n\nShow/hide code\nptsne &lt;- function(tsne_obj, variable, colors){\n  data.frame(tsne_obj$Y) %&gt;% \n  cbind(dplyr::distinct(dplyr::select(counts_f_experiment, sample, replicate, transfer, measure_env_short, home_env_short))) %&gt;% \n  ggplot2::ggplot() +\n  ggplot2::geom_point(aes(x= X2, y = X1, color = {{ variable }}), alpha = 0.8) +\n  ggplot2::scale_y_continuous(breaks = c(10, 0, -10)) +\n  ggplot2::coord_fixed() + \n  ggplot2::labs(x = \"tSNE dimension 1\", \n       y = \"tSNE dimension 2\", \n       shape = \"Transfer\") +\n  ggplot2::scale_color_manual(values = colors) +\n  ggplot2::facet_grid(~transfer, labeller = label_both) +\n  ggplot2::theme_bw() +\n  ggplot2::theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  ) \n}\n\n\nCall the plotting function, make the patchwork layout, and save in raster and vector format\n\n\nShow/hide code\npm &lt;- ptsne(mymat_tsne, measure_env_short, c(\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\")) +\n  ggplot2::labs(color = \"Measure\\nenvironment\")\nph &lt;- ptsne(mymat_tsne, home_env_short, c(\"#fdbf6f\", \"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\")) +\n  ggplot2::labs(color = \"Home\\nenvironment\")\n\npt &lt;- pm + ph +\n  patchwork::plot_layout(guides = 'collect', nrow = 2) +\n  patchwork::plot_annotation(tag_levels = 'A')\n\nggplot2::ggsave(\n  here::here(figs_stp, \"community_composition_bar_tsne.svg\"),\n  pt,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(figs_stp, \"community_composition_tsne.png\"),\n  pt,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Dimensional reduction of bacterial community composition using t-SNE. Each point represents a replicate microcosm sampled at serial transfers 4, 8, and 12 (grid columns). In A) point colors depict the experimental measurement condition from the transplantation experiment. In B) point colors depict the evolutionary history of the inoculating communities (“home environment”).\n\n\n\n\n\n6 Distances between communities\nThe Jensen–Shannon divergence (JSD) is a symmetrized and smoothed version of the Kullback–Leibler divergence. It is defined as:\n\\[\nD_{\\text{JS}}(P \\parallel Q) = \\frac{1}{2} D_{\\text{KL}}(P \\parallel M) + \\frac{1}{2} D_{\\text{KL}}(Q \\parallel M)\n\\tag{2}\\]\n\\[\nM = \\frac{1}{2}(P + Q)\n\\tag{3}\\]\nHere, (\\(D_{\\text{KL}}\\)) denotes the Kullback-Leibler divergence which is defined as:\n\\[\nD_{KL}(P \\parallel Q) = \\sum_{x \\in \\mathcal{X}} P(x) \\log \\frac{P(x)}{Q(x)}\n\\tag{4}\\]\n\n\nShow/hide code\n# create a matrix of species frequencies\nprob_mat &lt;- counts_f_experiment %&gt;% \n  dplyr::select(sample, strainID, f) %&gt;% \n  tidyr::pivot_wider(names_from = strainID, values_from = f) %&gt;% \n  tibble::column_to_rownames(var = \"sample\") %&gt;% \n  as.matrix()\n\n# calculate JSD between all pairs using philentropy::JSD\njsd_mat &lt;- philentropy::JSD(prob_mat)\n\n\nMetric: 'jensen-shannon' using unit: 'log2'; comparing: 355 vectors.\n\n\nShow/hide code\n# get nonredundant pairings\nind &lt;- which(upper.tri(jsd_mat, diag = TRUE), arr.ind = TRUE)\nnn &lt;- list(rownames(prob_mat), rownames(prob_mat))\njsddf &lt;- data.frame(sample.x = nn[[1]][ind[, 1]],\n           sample.y = nn[[2]][ind[, 2]],\n           jsd = jsd_mat[ind])\n\n# metadata for joining\nmd &lt;- dplyr::distinct(counts_f_experiment, sample, replicate, transfer, measure_env_short, home_env_short)\n\n# convert to long format\njsddf_long_md &lt;- jsddf %&gt;% \n  dplyr::left_join(md, by = join_by(sample.x==sample)) %&gt;% \n  dplyr::left_join(md, by = join_by(sample.y==sample))\n\n\nFilter JSD pairs to only those that are relative to ancestral community in each measurement environment. Also calculate mean and boostrapped 95CI using HMisc\n\n\nShow/hide code\njsddf_long_md_filt &lt;- jsddf_long_md %&gt;% \n  dplyr::filter(measure_env_short.x == measure_env_short.y) %&gt;% \n  dplyr::filter(home_env_short.x != home_env_short.y & transfer.x == transfer.y & home_env_short.x == \"Home: Anc\") %&gt;% \n  dplyr::summarize(ggplot2::mean_cl_boot(jsd), .by=c(transfer.y, home_env_short.y, measure_env_short.y)) %&gt;% \n  dplyr::mutate(home_env_short.y = factor(home_env_short.y))\n\n\nHmmm…. not sure what exactly this is telling, but I am calculating the within home/measurement divergence as some kind of variability baseline.\n\n\nShow/hide code\nintrarepvar &lt;- jsddf_long_md %&gt;% \n  dplyr::filter(measure_env_short.x == measure_env_short.y & home_env_short.x == home_env_short.y & transfer.x == transfer.y) %&gt;% \n  dplyr::summarize(ggplot2::mean_cl_boot(jsd), .by=c(transfer.y, home_env_short.y, measure_env_short.y)) %&gt;% \n  dplyr::filter(home_env_short.y != \"Home: Anc\") %&gt;% \n  dplyr::mutate(home_env_short.y = factor(home_env_short.y))\n\n\nMake plot of JSD to ancestral communities in each condition and save in raster/vector format\n\n\nShow/hide code\nmycols &lt;- c(\"Home: B\" = \"#a6cee3\", \"Home: BP\" = \"#1f78b4\", \"Home: BS\" = \"#b2df8a\", \"Home: BPS\" = \"#33a02c\")\n\npjsd &lt;- ggplot2::ggplot() +\n  ggplot2::geom_ribbon(data = intrarepvar, \n              aes(x = transfer.y, ymin = ymin, ymax=ymax, fill = home_env_short.y), alpha=0.25) + \n  ggplot2::geom_line(data = intrarepvar, \n            aes(x = transfer.y, y=y, color = home_env_short.y), alpha=0.5, lty=2) + \n  ggplot2::geom_point(data = jsddf_long_md_filt, aes(x = transfer.y, y = y, group = home_env_short.y, color = home_env_short.y)) +\n  ggplot2::geom_linerange(data = jsddf_long_md_filt, \n                 aes(x = transfer.y, ymin = ymin, ymax = ymax, color = home_env_short.y)) + \n  ggplot2::geom_line(data= jsddf_long_md_filt, \n            aes(x = transfer.y, y = y, group = home_env_short.y, color = home_env_short.y)) + \n  ggplot2::facet_grid(measure_env_short.y ~ home_env_short.y) + #, scales = \"free_y\"\n  ggplot2::labs(x = \"Growth Cycles\", y = \"Jensen-Shannon Divergence relative to ancestor\", color = \"Home\\nEnvironment\", fill = \"Home\\nEnvironment\") +\n  #ggplot2::scale_y_sqrt() +\n  ggplot2::scale_x_continuous(breaks = c(4, 8, 12), limits = c(3.5, 12.5)) +\n  ggplot2::scale_color_manual(values=mycols) +\n  ggplot2::scale_fill_manual(values=mycols) +\n  ggplot2::theme_bw() +\n  ggplot2::theme(\n    #panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n\nggplot2::ggsave(\n  here::here(figs_stp, \"community_jsd_to_anc.svg\"),\n  pjsd,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(figs_stp, \"community_jsd_to_anc.png\"),\n  pjsd,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Mean \\(\\pm\\) 95% CI of the pairwise Jensen-Shannon Divergence between the ancestral/clonal community composition (Figure 1 C) and the community composition in YSK Home environments (Home, grid columns) for each measurement environment (Meas, grid rows) in the transplantation experiment (see also Figure 1 D). Mean divergences are nested within Growth Cycles (horizontal axis) where one growth cycle is 7 days. Dashed lines indicate mean and ribbons indicate 95% CI for the mean within-condition Jensen-Shannon Divergence and is meant as an indicator of replicate variability within each Home/Measurement treatment combination.",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "ii) Community composition"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/cell_density/01_analysis.html",
    "href": "R/strep_predator/communities/cell_density/01_analysis.html",
    "title": "Predator and STR Community growth workflow i) Process and plot bacteria and ciliate densities",
    "section": "",
    "text": "This code loads required libraries and sets global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(withr)\nlibrary(Rtsne)\nlibrary(patchwork)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\nThis code reads optical density data - OD600 and creates variables used later\n\n\nShow/hide code\nod &lt;- readr::read_tsv(here::here(data_stp_ds, \"OD600.tsv\")) %&gt;%\n  dplyr::group_by(measure_env, evolution_env) %&gt;%\n  dplyr::mutate(mean_od = median(od600)) %&gt;%\n  dplyr::ungroup() %&gt;%\n  dplyr::mutate(\n    measure_env_short = dplyr::case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    home_env_short = dplyr::case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )\n\n\n\n\n\nThis code reads Ciliate density (in cell counts per ml) and creates variables used later\n\n\nShow/hide code\ntetra &lt;- readr::read_tsv(here::here(data_stp_ds, \"tetrahymena.tsv\")) %&gt;%\n  dplyr::group_by(measure_env, evolution_env) %&gt;%\n  dplyr::mutate(mean_cil = median(ciliate_per_ml)) %&gt;%\n  dplyr::ungroup() %&gt;%\n  dplyr::mutate(\n    measure_env_short = dplyr::case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    home_env_short = dplyr::case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "1A. Community densities workflow (Predator and STR)",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/cell_density/01_analysis.html#read-and-format-optical-density-data",
    "href": "R/strep_predator/communities/cell_density/01_analysis.html#read-and-format-optical-density-data",
    "title": "Predator and STR Community growth workflow i) Process and plot bacteria and ciliate densities",
    "section": "",
    "text": "This code reads optical density data - OD600 and creates variables used later\n\n\nShow/hide code\nod &lt;- readr::read_tsv(here::here(data_stp_ds, \"OD600.tsv\")) %&gt;%\n  dplyr::group_by(measure_env, evolution_env) %&gt;%\n  dplyr::mutate(mean_od = median(od600)) %&gt;%\n  dplyr::ungroup() %&gt;%\n  dplyr::mutate(\n    measure_env_short = dplyr::case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    home_env_short = dplyr::case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "1A. Community densities workflow (Predator and STR)",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/cell_density/01_analysis.html#read-and-format-ciliate-density-data",
    "href": "R/strep_predator/communities/cell_density/01_analysis.html#read-and-format-ciliate-density-data",
    "title": "Predator and STR Community growth workflow i) Process and plot bacteria and ciliate densities",
    "section": "",
    "text": "This code reads Ciliate density (in cell counts per ml) and creates variables used later\n\n\nShow/hide code\ntetra &lt;- readr::read_tsv(here::here(data_stp_ds, \"tetrahymena.tsv\")) %&gt;%\n  dplyr::group_by(measure_env, evolution_env) %&gt;%\n  dplyr::mutate(mean_cil = median(ciliate_per_ml)) %&gt;%\n  dplyr::ungroup() %&gt;%\n  dplyr::mutate(\n    measure_env_short = dplyr::case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    home_env_short = dplyr::case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "1A. Community densities workflow (Predator and STR)",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/cell_density/01_analysis.html#od600",
    "href": "R/strep_predator/communities/cell_density/01_analysis.html#od600",
    "title": "Predator and STR Community growth workflow i) Process and plot bacteria and ciliate densities",
    "section": "2.1 OD600",
    "text": "2.1 OD600\n\n\nShow/hide code\npod &lt;- ggplot2::ggplot(od, aes(x = transfer, y = od600)) +\n  ggplot2::geom_line(aes(color = replicate)) +\n  ggplot2::geom_hline(aes(yintercept = mean_od), linetype = \"dashed\") + \n  ggplot2::scale_x_continuous(breaks = c(2, 4, 6, 8, 10, 12)) +\n  ggplot2::labs(y = \"Optical Density (600 nm)\", x = \"Experiment transfer (weeks)\", color = \"Replicate\") +\n  ggplot2::facet_grid(measure_env_short ~ home_env_short) +\n  ggplot2::theme_bw() +\n  ggplot2::theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n\nggplot2::ggsave(\n  here::here(figs_stp, \"community_optical_density.svg\"),\n  pod,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(figs_stp, \"community_optical_density.png\"),\n  pod,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Bacterial optical density (vertical axis) with respect to experimental transfer (horizontal axis). The different replicate microcosms are denoted by color. Optical density for the microscosms is displayed with respect to measurement environment (grid rows) and evolutionary history (grid columns, “home” environment).",
    "crumbs": [
      "1A. Community densities workflow (Predator and STR)",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/cell_density/01_analysis.html#ciliate",
    "href": "R/strep_predator/communities/cell_density/01_analysis.html#ciliate",
    "title": "Predator and STR Community growth workflow i) Process and plot bacteria and ciliate densities",
    "section": "2.2 Ciliate",
    "text": "2.2 Ciliate\n\n\nShow/hide code\nptet &lt;- ggplot(tetra, aes(x = transfer, y = ciliate_per_ml)) +\n  geom_line(aes(color = replicate)) +\n  geom_hline(aes(yintercept = mean_cil), linetype = \"dashed\") + \n  scale_x_continuous(breaks = c(2, 4, 6, 8, 10, 12)) +\n  facet_grid(measure_env_short ~ home_env_short) +\n  labs(y = \"Ciliate Density (cells per ml)\", x = \"Experiment transfer (weeks)\", color = \"Replicate\") +\n  theme_bw() +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n\nggplot2::ggsave(\n  here::here(figs_stp, \"community_ciliate_density.svg\"),\n  ptet,\n  width = 8,\n  height = 4,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(figs_stp, \"community_ciliate_density.png\"),\n  ptet,\n  width = 8,\n  height = 4,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Ciliate density (vertical axis, cells per ml) with respect to experimental transfer (horizontal axis). The different replicate microcosms are denoted by color. Predator density is displayed with respect to measurement environment (grid rows) and evolutionary history (grid columns, “home” environment).",
    "crumbs": [
      "1A. Community densities workflow (Predator and STR)",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html",
    "href": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html",
    "title": "Predator and STR Clones monoculture growth workflow i) inspection of growth curves",
    "section": "",
    "text": "After 12 transfers of the experiment 32 clones were randomly picked from each replicate/home environemnt/measurement environmentn on selective plates. These clones were grown in all the different YSK conditions (including in the presence of the Ciliate) for 48 hours on the log-phase 600 plate reader. From this data we can estimate the growth rate and the carrying capacity of each species in the different conditions.\nIn this notebook we will read the output from the log phase plate reader and format it for later plotting and analysis.",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#functions",
    "href": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#functions",
    "title": "Predator and STR Clones monoculture growth workflow i) inspection of growth curves",
    "section": "2.1 Functions",
    "text": "2.1 Functions\nDefine functions to make later plotting easier\n\n\nShow/hide code\nplotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, well, plate), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 1)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::geom_line(aes(y=OD600_smooth_avg), color = \"blue\", lty=2), \n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ well, nrow = rows, ncol = cols, page = page), #scales = \"free_y\"\n      ggplot2::theme(axis.text = element_text(size = 9))\n    )\n}",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#thinning",
    "href": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#thinning",
    "title": "Predator and STR Clones monoculture growth workflow i) inspection of growth curves",
    "section": "4.1 Thinning",
    "text": "4.1 Thinning\nOne thing I’ve realized is that many methods for inferring growth rates struggle when the density of observations is too high (e.g., one measurement every 5 minutes). In reality I’ve found that taking one measurement every 15 minutes is sufficient. Here we thin it out so that measurements are in 20 minute intervals. This seems to improve the fitting procedure a lot without much of a cost.\nThe rounding step is necessary because the plate readers actually don’t always output consistent intervals. Sometimes it is 00:30:06 and other times it is 00:30:05. This becomes a problem later on when trying to combine multiple runs at once\n\n\nShow/hide code\nround_any &lt;- function(x, accuracy, f=round){\n  f(x/ accuracy) * accuracy\n}\n\ngcurves_thin &lt;- gcurves_slurped_fmt %&gt;% \n  dplyr::mutate(seconds = round_any(seconds, 100)) %&gt;% \n  # 1200 is 20 minutes so by ensuring modulo = 0 we include only time points\n  # 0, 20, 40, 60 minutes and so on...\n  dplyr::filter(seconds %% 1200 == 0)",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#smoothing",
    "href": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#smoothing",
    "title": "Predator and STR Clones monoculture growth workflow i) inspection of growth curves",
    "section": "4.2 Smoothing",
    "text": "4.2 Smoothing\nFor the growth curves we will do some smoothing to reduce the “jaggedness” of the curves a bit because these were run before the optimized logphase600 protocol was in place (better breatheasy seals plus new sealing tool). We use the slider package with a 5 point rolling mean for each focal observation we take the mean including the focal point and two points before and after.\n\nSee here for a useful thread:\nThis answer seems promising\nPotentially also promising\n\nHere we will smooth out some of the higher frequency noise in the curves. First we wil smooth using a moving median approach then smooth that using a moving average approach. We will also try a min then mean smoothing approach. Some of the curves are really wacky with lots of erratic peaks…\n\n\nShow/hide code\ngcurves_thin_sm &lt;- gcurves_thin %&gt;% \n  dplyr::group_by(plate, well) %&gt;% \n  dplyr::mutate(OD600_smooth_md = slider::slide_dbl(OD600, median, .before = 2, .after = 2)) %&gt;% \n  dplyr::mutate(OD600_smooth_avg = slider::slide_dbl(OD600, mean, .before = 2, .after = 2)) %&gt;% \n  dplyr::mutate(OD600_smooth_md_avg = slider::slide_dbl(OD600_smooth_md, mean, .before = 2, .after = 2)) %&gt;% \n  ungroup()\n\nreadr::write_tsv(gcurves_thin_sm, here::here(data_stp_cl, \"gcurves_smoothed_thinned.tsv\"))",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#bact-conditions",
    "href": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#bact-conditions",
    "title": "Predator and STR Clones monoculture growth workflow i) inspection of growth curves",
    "section": "5.1 Bact conditions",
    "text": "5.1 Bact conditions\n\n5.1.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Growth curves for the bacteria only conditions on Plate 1. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Growth curves for the bacteria only conditions on Plate 2. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Growth curves for the bacteria only conditions on Plate 3. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Growth curves for the bacteria only conditions on Plate 4. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Growth curves for bacteria only conditions on Plate 5. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Growth curves for bacteria only conditions on Plate 6. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Growth curves for bacteria only conditions on Plate 7. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Growth curves for bacteria only conditions on Plate 8. Orange solid line is raw data, blue line is 5-point rolling mean smooth.",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#predator-conditions",
    "href": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#predator-conditions",
    "title": "Predator and STR Clones monoculture growth workflow i) inspection of growth curves",
    "section": "5.2 Predator conditions",
    "text": "5.2 Predator conditions\n\n5.2.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Growth curves for the ciliate conditions on Plate 1. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Growth curves for the ciliate conditions on Plate 2. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Growth curves for the ciliate conditions on Plate 3. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Growth curves for the ciliate conditions on Plate 4. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Growth curves for ciliate conditions on Plate 5. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Growth curves for ciliate conditions on Plate 6. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Growth curves for ciliate conditions on Plate 7. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Growth curves for ciliate conditions on Plate 8. Orange solid line is raw data, blue line is 5-point rolling mean smooth.",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#streptomycin-conditions",
    "href": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#streptomycin-conditions",
    "title": "Predator and STR Clones monoculture growth workflow i) inspection of growth curves",
    "section": "5.3 Streptomycin conditions",
    "text": "5.3 Streptomycin conditions\n\n5.3.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17: Growth curves for the Streptomycin conditions on Plate 1. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: Growth curves for the Streptomycin conditions on Plate 2. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Growth curves for the Streptomycin conditions on Plate 3. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 20: Growth curves for the Streptomycin conditions on Plate 4. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 21: Growth curves for Streptomycin conditions on Plate 5. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 22: Growth curves for Streptomycin conditions on Plate 6. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 23: Growth curves for Streptomycin conditions on Plate 7. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 24: Growth curves for Streptomycin conditions on Plate 8. Orange solid line is raw data, blue line is 5-point rolling mean smooth.",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#predator-streptomycin-conditions",
    "href": "R/strep_predator/monocultures/clone_phenotyping/01_growth_curve_qc.html#predator-streptomycin-conditions",
    "title": "Predator and STR Clones monoculture growth workflow i) inspection of growth curves",
    "section": "5.4 Predator + Streptomycin conditions",
    "text": "5.4 Predator + Streptomycin conditions\n\n5.4.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 25: Growth curves for the Ciliate + Streptomycin conditions on Plate 1. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 26: Growth curves for the Ciliate + Streptomycin conditions on Plate 2. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 27: Growth curves for the Ciliate + Streptomycin conditions on Plate 3. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 28: Growth curves for the Ciliate + Streptomycin conditions on Plate 4. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 29: Growth curves for Ciliate + Streptomycin conditions on Plate 5. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30: Growth curves for Ciliate + Streptomycin conditions on Plate 6. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 31: Growth curves for Ciliate + Streptomycin conditions on Plate 7. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 32: Growth curves for Ciliate + Streptomycin conditions on Plate 8. Orange solid line is raw data, blue line is 5-point rolling mean smooth.",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data analysis for the project hambiEvoVEnv",
    "section": "",
    "text": "◇ Corresponding author\n\n\nA shared history shapes community response to the environment.\nSmolander N, Silvennoinen A, Tamminen M, Hiltunen T, Hogle SL◇. XYZ (2024/5) doi:\n\n\n\nA shared history shapes community response to the environment.\nSmolander N, Silvennoinen A, Tamminen M, Hiltunen T, Hogle SL◇. BioRxiv (2024/5) doi:"
  },
  {
    "objectID": "index.html#manuscript",
    "href": "index.html#manuscript",
    "title": "Data analysis for the project hambiEvoVEnv",
    "section": "",
    "text": "◇ Corresponding author\n\n\nA shared history shapes community response to the environment.\nSmolander N, Silvennoinen A, Tamminen M, Hiltunen T, Hogle SL◇. XYZ (2024/5) doi:\n\n\n\nA shared history shapes community response to the environment.\nSmolander N, Silvennoinen A, Tamminen M, Hiltunen T, Hogle SL◇. BioRxiv (2024/5) doi:"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Data analysis for the project hambiEvoVEnv",
    "section": "2 Introduction",
    "text": "2 Introduction\nWe consider the material and information legacies embedded within a synthetic microbial community that has been serially propagated for over 400 days. We ask whether ecological and evolutionary patterns exhibited by a microbial community in its long-term home environment are retained in a novel environment. Recent work has shown that when entire microbial communities are mixed or transplanted, they retain some degree of cohesion in function and composition (Rillig et al. 2015). What causes communities to behave cohesively rather than collapsing into their constituents when subjected to abiotic or biotic pressures? When might we expect a cohesive community response instead of the aggregate responses of individual species?"
  },
  {
    "objectID": "index.html#experiment-overview",
    "href": "index.html#experiment-overview",
    "title": "Data analysis for the project hambiEvoVEnv",
    "section": "3 Experiment overview",
    "text": "3 Experiment overview\n\n\n\nStructure of the community evolution and transplantation experiments. Exp = experiment, MetaG = metagenomic.\n\n\nWe first serially propagated a bacterial community, starting from clones of 23 soil and aquatic species (Hogle, Tamminen, and Hiltunen 2024), for 406 days in two different conditions: a low-carbon, complex growth medium with and without the antibiotic streptomycin. We refer to these as “evolved” communities. We isolated 32 clones from each evovlved microcosm and phenotyped them both home environments to determine mean community fitness in each environment. We then reciprocally transplanted each of these evolved communities into the other’s home environment, with a clonal ancestor community serving as a reference. We allowed the experimental communities to grow for a further 84 days, measuring community composition at three different points and sequencing community genomes from the end of the experiment, which allowed us to track the fate of mutations from the evolved communities in their new environments.\n\n3.1 Measurements and data types\n\n32 clones were isolated from each replicate microcosm of the community evolution pre-experiment. High-resolution growth curves were obtained for the clones (obtained using the log-phase 600)\nBacterial optical density (\\(\\mathrm{OD_{600}}\\)) were measured at every weekly transfer\nCommunity DNA was sampled at all transfers.\n16S rRNA amplicon sequencing was performed at transfers 0, 4 (28 days), 8 (56 days), and 12 (84 days)\nCommunity genome (metagenome) sequencing was performed at transfer 12 of the transplantation experiment and of the evolution treatments starting materials"
  },
  {
    "objectID": "index.html#analysis-overview",
    "href": "index.html#analysis-overview",
    "title": "Data analysis for the project hambiEvoVEnv",
    "section": "4 Analysis overview",
    "text": "4 Analysis overview\nThese notebooks allow the full reproduction of the data analysis from the sequencing data and clone phenotyping data. They include analyses of mean community fitness (from clone phenotypcing, for ploting species composition, for performing ordination on community composition, and machine learning to predict community history from the present community composition."
  },
  {
    "objectID": "index.html#availability",
    "href": "index.html#availability",
    "title": "Data analysis for the project hambiEvoVEnv",
    "section": "5 Availability",
    "text": "5 Availability\nData and code in this GitHub repository (https://github.com/slhogle/hambiEvoVEnv) is provided under GNU AGPL3. The rendered project site is available at https://slhogle.github.io/hambiEvoVEnv/, which has been produced using Quarto notebooks. The content on the rendered site is released under the CC BY 4.0. This repository hosts all code and data for this project including the code necessary to fully recreate the rendered webpage.\nAn archived release of the code here is available from Zenodo:\nRaw sequencing data using in the project is available from NCBI Bioproject ."
  },
  {
    "objectID": "index.html#reproducibility",
    "href": "index.html#reproducibility",
    "title": "Data analysis for the project hambiEvoVEnv",
    "section": "6 Reproducibility",
    "text": "6 Reproducibility\nThe project uses renv to create reproducible environment to execute the code in this project. See here for a brief overview on collaboration and reproduction of the entire project. To get up and running you can do:\ninstall.packages(\"renv\")\nrenv::restore()"
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/03_growth_summary_analysis.html",
    "href": "R/strep_predator/monocultures/clone_phenotyping/03_growth_summary_analysis.html",
    "title": "Predator and STR Clones monoculture growth workflow iii) analysis of growth summary data",
    "section": "",
    "text": "This notebook plots and performs some analysis on the growthrate and AUC estimates from the prior notebook\n\n1 Setup\nLoad required packages\n\n\nShow/hide code\nlibrary(here)\n\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiEvoVEnv\n\n\nShow/hide code\nlibrary(tidyverse)\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nShow/hide code\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\ndata_raw &lt;- here::here(\"_data_raw\", \"monocultures\", \"20230112_clone_phenotyping\")\n\n\n\n\n2 Read data\nExperiment information (e.g., which wells correspond to which clones from which condition)\n\n\nShow/hide code\nmddf &lt;- read_tsv(\n  here::here(data_raw, \"metadata.tsv\"),\n  col_types = list(\n    plate = col_character(),\n    well = col_character(),\n    clone_id = col_double(),\n    experiment_treatment = col_character(),\n    LTCSE_treatment = col_character(),\n    replicate = col_character(),\n    lagtime = col_time(format = \"%T\"),\n    max_growth_death_rate = col_double(),\n    time_to_stationary = col_time(format = \"%T\")\n  )\n) %&gt;%\n  mutate(\n    measure_env_short = case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    home_env_short = case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate),\n    clone_id = factor(clone_id)\n  )\n\n\nBlacklist (i.e., samples that have been manually inspected and should be excluded due to strange features)\n\n\nShow/hide code\nblacklist &lt;- read_tsv(here::here(data_stp_cl, \"blacklist.tsv\"))\n\n\nGrowth summary data\n\n\nShow/hide code\nauc_grates &lt;- readr::read_tsv(here::here(data_stp_cl, \"auc_mumax_results.tsv\"))\n\n\n\n\n3 Formatting\nAnti join black list to growth curves to remove the bad growth curves and join to experiment metadata\n\n\nShow/hide code\nauc_gr_md &lt;- left_join(auc_grates, mddf, by = join_by(plate, well)) %&gt;%\n  anti_join(blacklist, by = join_by(plate, well))\n\n\nMean center the AUC and growth rates to the mean of all clones from all evolutionary histories nested by measurement environment\n\n\nShow/hide code\nauc_gr_md_subset &lt;- auc_gr_md %&gt;%\n  dplyr::select(\n    auc,\n    mumax,\n    measure_env,\n    evolution_env,\n    measure_env_short,\n    home_env_short,\n    replicate,\n    clone_id\n  )\n\nauc_gr_md_subset_summary &lt;- auc_gr_md_subset %&gt;%\n  filter(measure_env == evolution_env) %&gt;%\n  summarize(\n    auc_mn = mean(auc),\n    auc_sd = sd(auc),\n    mu_mn = mean(mumax),\n    mu_sd = sd(mumax),\n    .by = c(measure_env)\n  )\n\nauc_gr_md_subset_summary_z &lt;- left_join(auc_gr_md_subset, auc_gr_md_subset_summary, by = join_by(measure_env)) %&gt;%\n  mutate(z_mu = (mumax - mu_mn), #/ mu_sd\n         z_auc = (auc - auc_mn)) %&gt;% #/auc_sd\n  pivot_longer(cols = starts_with(\"z\"),\n               names_to = \"metric\",\n               values_to = \"z\")\n\n\n\n\n4 Plot\nFunction to plot metric of choice\n\n\nShow/hide code\ncloneplot &lt;- function(df, metric, ylab){\n  df %&gt;% \n    filter(metric == {{ metric }}) %&gt;% \n    ggplot2::ggplot() +\n    ggplot2::geom_hline(yintercept = 0) +\n    ggplot2::geom_boxplot(aes(y = z, x = home_env_short), color = \"red\", outliers = FALSE, position = position_dodge(width = 0.5)) +\n    ggplot2::geom_jitter(aes(y = z, x = home_env_short, color = replicate), width = 0.25, height = 0, alpha = 0.25) +\n    ggplot2::labs(x = \"Home environment\", y = ylab, fill=\"\") + \n    ggplot2::facet_grid(measure_env_short ~ ., scales = \"free_y\") +\n    ggplot2::theme_bw()\n}\n\npclone_auc &lt;- cloneplot(auc_gr_md_subset_summary_z, \"z_auc\", \"Meaurement env mean centered AUC\")\npclone_mu &lt;- cloneplot(auc_gr_md_subset_summary_z, \"z_mu\", \"Meaurement env mean centered μ\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Mean centered AUC (area under the growth curve) for 32 randomly picked clones from each replicate (A-F) of each home YSK environment and measurement condition pair. Points are individual measurements (colored by replicate) while boxplots represent the mean and 1-3 quartiles with whiskers representing 1.5 \\(\\times\\) the interquartile range. Heavy black line is the Measurement Environment mean.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Mean centered maximum specific growth rate (μ max) for 32 randomly picked clones from each replicate (A-F) of each home YSK environment and measurement condition pair. Points are individual measurements (colored by replicate) while boxplots represent the mean and 1-3 quartiles with whiskers representing 1.5 \\(\\times\\) the interquartile range. Heavy black line is the Measurement Environment mean.\n\n\n\n\n\nShow/hide code\nggplot2::ggsave(\n  here::here(figs_stp, \"monoculture_clone_phenotyping_auc.svg\"),\n  pclone_auc,\n  width = 7,\n  height = 8,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(figs_stp, \"monoculture_clone_phenotyping_auc.png\"),\n  pclone_auc,\n  width = 7,\n  height = 8,\n  units = \"in\",\n  device = \"png\"\n)",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "iii) Analysis and plot"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html",
    "href": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html",
    "title": "Predator and STR Clones monoculture growth workflow ii) AUC and growth rate estimate",
    "section": "",
    "text": "This notebook estimates growth rates by fitting non-parametric splines using the really nice growthrates package. AUC is esimated using the DescTools package.",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#fit",
    "href": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#fit",
    "title": "Predator and STR Clones monoculture growth workflow ii) AUC and growth rate estimate",
    "section": "3.1 Fit",
    "text": "3.1 Fit\n\n\nShow/hide code\nset.seed(45278)\nmany_spline &lt;- growthrates::all_splines(OD600_smooth_avg ~ hours | id, data = gcurves_thin_sm, spar = 0.5)\n\nreadr::write_rds(many_spline, here::here(data_stp_cl, \"spline_fits\"))",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#results",
    "href": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#results",
    "title": "Predator and STR Clones monoculture growth workflow ii) AUC and growth rate estimate",
    "section": "3.2 Results",
    "text": "3.2 Results\n\n\nShow/hide code\nmany_spline_res &lt;- growthrates::results(many_spline)",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#predictions",
    "href": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#predictions",
    "title": "Predator and STR Clones monoculture growth workflow ii) AUC and growth rate estimate",
    "section": "3.3 Predictions",
    "text": "3.3 Predictions\n\n\nShow/hide code\nmany_spline_xy &lt;- purrr::map(many_spline@fits, \\(x) data.frame(x = x@xy[1], y = x@xy[2])) %&gt;%\n  purrr::list_rbind(names_to = \"id\")\n\nmany_spline_fitted &lt;- purrr::map(many_spline@fits, \\(x) data.frame(x@FUN(x@obs$time, x@par))) %&gt;%\n  purrr::list_rbind(names_to = \"id\") %&gt;%\n  dplyr::rename(hours = time, predicted = y) %&gt;%\n  dplyr::left_join(gcurves_thin_sm, by = dplyr::join_by(id, hours)) %&gt;%\n  dplyr::group_by(id) %&gt;%\n  # this step makes sure we don't plot fits that go outside the range of the data\n  dplyr::mutate(predicted = dplyr::if_else(dplyr::between(\n    predicted, min(OD600_smooth_avg), max(OD600_smooth_avg * 1.5)\n  ), predicted, NA_real_)) %&gt;%\n  dplyr::ungroup()",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#bact-conditions",
    "href": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#bact-conditions",
    "title": "Predator and STR Clones monoculture growth workflow ii) AUC and growth rate estimate",
    "section": "6.1 Bact conditions",
    "text": "6.1 Bact conditions\n\n6.1.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Growth curves for the bacteria only conditions on Plate 1. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Growth curves for the bacteria only conditions on Plate 2. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Growth curves for the bacteria only conditions on Plate 3. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Growth curves for the bacteria only conditions on Plate 4. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Growth curves for bacteria only conditions on Plate 5. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Growth curves for bacteria only conditions on Plate 6. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Growth curves for bacteria only conditions on Plate 7. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.1.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Growth curves for bacteria only conditions on Plate 8. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#predator-conditions",
    "href": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#predator-conditions",
    "title": "Predator and STR Clones monoculture growth workflow ii) AUC and growth rate estimate",
    "section": "6.2 Predator conditions",
    "text": "6.2 Predator conditions\n\n6.2.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Growth curves for the ciliate conditions on Plate 1. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Growth curves for the ciliate conditions on Plate 2. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Growth curves for the ciliate conditions on Plate 3. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Growth curves for the ciliate conditions on Plate 4. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Growth curves for ciliate conditions on Plate 5. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Growth curves for ciliate conditions on Plate 6. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Growth curves for ciliate conditions on Plate 7. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.2.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Growth curves for ciliate conditions on Plate 8. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#streptomycin-conditions",
    "href": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#streptomycin-conditions",
    "title": "Predator and STR Clones monoculture growth workflow ii) AUC and growth rate estimate",
    "section": "6.3 Streptomycin conditions",
    "text": "6.3 Streptomycin conditions\n\n6.3.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17: Growth curves for the Streptomycin conditions on Plate 1. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.3.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: Growth curves for the Streptomycin conditions on Plate 2. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.3.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Growth curves for the Streptomycin conditions on Plate 3. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.3.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 20: Growth curves for the Streptomycin conditions on Plate 4. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.3.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 21: Growth curves for Streptomycin conditions on Plate 5. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.3.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 22: Growth curves for Streptomycin conditions on Plate 6. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.3.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 23: Growth curves for Streptomycin conditions on Plate 7. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.3.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 24: Growth curves for Streptomycin conditions on Plate 8. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#predator-streptomycin-conditions",
    "href": "R/strep_predator/monocultures/clone_phenotyping/02_growthrate_auc.html#predator-streptomycin-conditions",
    "title": "Predator and STR Clones monoculture growth workflow ii) AUC and growth rate estimate",
    "section": "6.4 Predator + Streptomycin conditions",
    "text": "6.4 Predator + Streptomycin conditions\n\n6.4.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 25: Growth curves for the Ciliate + Streptomycin conditions on Plate 1. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.4.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 26: Growth curves for the Ciliate + Streptomycin conditions on Plate 2. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.4.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 27: Growth curves for the Ciliate + Streptomycin conditions on Plate 3. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.4.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 28: Growth curves for the Ciliate + Streptomycin conditions on Plate 4. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.4.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 29: Growth curves for Ciliate + Streptomycin conditions on Plate 5. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.4.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30: Growth curves for Ciliate + Streptomycin conditions on Plate 6. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.4.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 31: Growth curves for Ciliate + Streptomycin conditions on Plate 7. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n6.4.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 32: Growth curves for Ciliate + Streptomycin conditions on Plate 8. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "3A. Clones workflow (Predator and STR)",
      "ii) Summarize curves"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/amplicon_sp_counts/01_format_rbec_tab.html",
    "href": "R/strep_predator/communities/amplicon_sp_counts/01_format_rbec_tab.html",
    "title": "Predator and STR Community species composition workflow i) Data formatting from 20240318_BTK_illumina_v3",
    "section": "",
    "text": "Contains both results from hambiYSKpleiotropy experiment and also a test of the boilprep extraction method from the tipping point experiment.",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "i) Amplicon data wrangling"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/amplicon_sp_counts/01_format_rbec_tab.html#s-copy-number-data",
    "href": "R/strep_predator/communities/amplicon_sp_counts/01_format_rbec_tab.html#s-copy-number-data",
    "title": "Predator and STR Community species composition workflow i) Data formatting from 20240318_BTK_illumina_v3",
    "section": "1.1 16S copy number data",
    "text": "1.1 16S copy number data\nThis tibble contains information mapping rRNA 16S locus tags to species and also total copy number of 16S rRNAs in each genome\n\n\nShow/hide code\ntax_locus_copynum &lt;- tibble::tribble(\n     ~strainID, ~rRNA16S_cn, ~rRNA16S_locus,             ~genus,        ~species,\n  \"HAMBI_0006\",          7L,  \"H0006_04757\",      \"Pseudomonas\",        \"putida\",\n  \"HAMBI_0097\",          7L,  \"H0097_00044\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_02759\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_01762\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0105\",          4L,  \"H0105_02306\",    \"Agrobacterium\",   \"tumefaciens\",\n  \"HAMBI_0262\",          3L,  \"H0262_00030\",    \"Brevundimonas\",       \"bullata\",\n  \"HAMBI_0403\",          9L,  \"H0403_00517\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_0403\",          9L,  \"H0403_00522\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_1279\",          7L,  \"H1279_03627\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_00125\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_03957\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1287\",          7L,  \"H1287_03997\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1287\",          7L,  \"H1287_03402\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1292\",          7L,  \"H1292_03239\",       \"Morganella\",      \"morganii\",\n  \"HAMBI_1299\",          8L,  \"H1299_04293\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1299_01283\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1279_03957\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1842\",          4L,  \"H1842_01650\",      \"Sphingobium\",    \"yanoikuyae\",\n  \"HAMBI_1896\",          4L,  \"H1896_00963\", \"Sphingobacterium\",  \"spiritivorum\",\n  \"HAMBI_1972\",         10L,  \"H1972_00343\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1972\",         10L,  \"H1972_03531\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1977\",          5L,  \"H1977_00118\",      \"Pseudomonas\",  \"chlororaphis\",\n  \"HAMBI_1988\",          5L,  \"H1988_05160\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05152\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05165\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_2159\",          4L,  \"H2159_01406\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2159\",          4L,  \"H2159_05851\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2160\",          3L,  \"H2160_00530\",       \"Bordetella\",         \"avium\",\n  \"HAMBI_2164\",          5L,  \"H2164_03337\",      \"Cupriavidus\",    \"oxalaticus\",\n  \"HAMBI_2443\",          3L,  \"H2443_00128\",       \"Paracoccus\", \"denitrificans\",\n  \"HAMBI_2494\",          4L,  \"H2494_03389\", \"Paraburkholderia\",   \"kururiensis\",\n  \"HAMBI_2659\",          4L,  \"H2659_00367\", \"Stenotrophomonas\",   \"maltophilia\",\n  \"HAMBI_2792\",          4L,  \"H2792_00549\",        \"Moraxella\",         \"canis\",\n  \"HAMBI_3031\",          2L,  \"H3031_00830\",         \"Niabella\",  \"yanshanensis\",\n  \"HAMBI_3237\",          6L,  \"H3237_00875\",       \"Microvirga\",   \"lotononidis\",\n  \"HAMBI_1923\",          6L,  \"H1923_00876\",   \"Flavobacterium\",      \"odoratum\"\n  )",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "i) Amplicon data wrangling"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/amplicon_sp_counts/01_format_rbec_tab.html#functions",
    "href": "R/strep_predator/communities/amplicon_sp_counts/01_format_rbec_tab.html#functions",
    "title": "Predator and STR Community species composition workflow i) Data formatting from 20240318_BTK_illumina_v3",
    "section": "1.2 Functions",
    "text": "1.2 Functions\nThese are functions to aid in reading and processing output from Rbec\n\n\nShow/hide code\n# this function \nnormalize_by_copy &lt;- function(.data, tlc = tax_locus_copynum){\n  .data %&gt;% \n    # join with the copy number data frame. We join by the locus tag so this will add H1279_03957 to HAMBI_1299\n    dplyr::left_join(tlc, by = join_by(rRNA16S_locus), relationship = \"many-to-many\") %&gt;%\n    # get total number of mapping reads per species. This aggregates all the difference ASVs per species\n    dplyr::summarize(count = sum(count), .by = c(sample, strainID, rRNA16S_cn)) %&gt;% \n    # group by sample\n    dplyr::group_by(sample) %&gt;% \n    # calculate a corrected count which is simply the count divided by copy num for each species\n    # dividide by the sum of count divided by copy num for whole sample multiplied by the total\n    # number of mapped reads per sample\n    dplyr::mutate(count_correct = round(sum(count)*(count/rRNA16S_cn)/sum(count/rRNA16S_cn))) %&gt;%  \n    dplyr::ungroup() %&gt;% \n    dplyr::select(sample, strainID, count, count_correct)\n  }\n\n# this function replaces missing species counts with zero\ncompletecombos &lt;- function(.data, tlc = tax_locus_copynum, countname = count, remove1923 = TRUE){\n \n  # get unique strainIDs\n  strainID &lt;- unique(tlc$strainID)\n  # table for assigning genus and species names. Doesn't matter if 1923 is there or not\n  # because it is filter joined later\n  tax &lt;- dplyr::distinct(dplyr::select(tlc, strainID, genus, species))\n  if (remove1923) {\n    # get unique strainIDs but exclude 1923 if remove1923 is true\n    strainID &lt;- strainID[strainID != \"HAMBI_1923\"]\n  }\n  \n  dplyr::bind_rows(tibble::tibble(strainID = strainID, sample = \"dummy\"), .data) %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(sample == \"dummy\", 1, {{ countname }})) %&gt;% \n    tidyr::complete(sample, strainID) %&gt;% \n    dplyr::filter(sample != \"dummy\") %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(is.na({{ countname }}), 0, {{ countname }})) %&gt;% \n    tidyr::replace_na(list(count_correct = 0)) %&gt;% \n    dplyr::left_join(dplyr::distinct(dplyr::select(tlc, strainID, genus, species)), by = join_by(strainID)) %&gt;% \n    dplyr::relocate(genus, species, .after = strainID)\n}",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "i) Amplicon data wrangling"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/amplicon_sp_counts/01_format_rbec_tab.html#metadata",
    "href": "R/strep_predator/communities/amplicon_sp_counts/01_format_rbec_tab.html#metadata",
    "title": "Predator and STR Community species composition workflow i) Data formatting from 20240318_BTK_illumina_v3",
    "section": "2.1 Metadata",
    "text": "2.1 Metadata\nReads metadata for the samples\n\n\nShow/hide code\nmddf &lt;- readr::read_tsv(here::here(data_raw, \"20240318_BTK_illumina_v3_metadata.tsv\"))\n\n\nRows: 414 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (10): pool, fusion_fwd, fusion_rev, sample, project, lib_prep, replicate...\ndbl  (2): amp_conc, day\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "i) Amplicon data wrangling"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/amplicon_sp_counts/01_format_rbec_tab.html#rbec",
    "href": "R/strep_predator/communities/amplicon_sp_counts/01_format_rbec_tab.html#rbec",
    "title": "Predator and STR Community species composition workflow i) Data formatting from 20240318_BTK_illumina_v3",
    "section": "2.2 Rbec",
    "text": "2.2 Rbec\nUntar Rbec output tarball which contains raw counts tables\n\n\nShow/hide code\narchive::archive_extract(\n  amplicontar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)\n\n\nSets up directory structure for decompressing\n\n\nShow/hide code\ntabdir &lt;- here::here(tmpdir, \"rbec_output\")\nsamppaths &lt;- fs::dir_ls(tabdir)\nsampnames &lt;- fs::path_split(samppaths) %&gt;% \n  purrr::map_chr(dplyr::last)\n\n\nReads all the strain_table.txt files in a loop\n\n\nShow/hide code\nstraintabs &lt;- paste0(samppaths, \"/strain_table.txt\") %&gt;% \n  purrr::set_names(sampnames) %&gt;% \n  purrr::map(\n  readr::read_tsv,\n  skip = 1,\n  col_names = c(\"rRNA16S_locus\",\"count\"),\n  show_col_types = FALSE) %&gt;% \n  purrr::list_rbind(names_to = \"sample\")",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "i) Amplicon data wrangling"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/machine_learning_pipelines/01_machine_learn_home_env.html",
    "href": "R/strep_predator/communities/machine_learning_pipelines/01_machine_learn_home_env.html",
    "title": "Predator and STR Community species composition workflow iii) prediction of evolution environment from measurement environment",
    "section": "",
    "text": "Loads required libraries and sets global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/machine_learning_pipelines/01_machine_learn_home_env.html#classes-ancesteral-b-bp-bs-and-bps",
    "href": "R/strep_predator/communities/machine_learning_pipelines/01_machine_learn_home_env.html#classes-ancesteral-b-bp-bs-and-bps",
    "title": "Predator and STR Community species composition workflow iii) prediction of evolution environment from measurement environment",
    "section": "5.1 5 classes (ancesteral, B, BP, BS, and BPS)",
    "text": "5.1 5 classes (ancesteral, B, BP, BS, and BPS)\nFirst were going to try and predict all 5 different home evolution environments\n\n5.1.1 Spliting\nSplit the data using the default 3:1 ratio of training-to-test. Here we also set the strata argument. This argument makes sure that both sides of the split have roughly the same distribution for each value of strata. If a numeric variable is passed to strata then it is binned and distributions are matched within bins. In this case there will be roughly the same distribution of the 5 classes within each side of the test/train split.\n\n\nShow/hide code\nbalclr_5c &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_ae, -home_env_sns, -home_env_pnp) %&gt;% \n  tidyr::drop_na()\n\ntable(balclr_5c$home_env_5c)\n\n\n\n            anc            bact       bact_pred bact_pred_strep      bact_strep \n             72              70              71              70              72 \n\n\nThe data is balanced\n\n\nShow/hide code\nset.seed(1501)\nbalclr_5c_split &lt;- rsample::initial_split(balclr_5c, strata = home_env_5c)\nbalclr_5c_train &lt;- rsample::training(balclr_5c_split)\nbalclr_5c_test  &lt;- rsample::testing(balclr_5c_split)\n\n\nResample the training set using five repeats of 10-fold cross-validation\n\n\nShow/hide code\nset.seed(1502)\nbalclr_5c_folds &lt;- rsample::vfold_cv(balclr_5c_train, strata = home_env_5c)\n\n\n\n\n5.1.2 Recipe\nFirst we need to preprocess the data so that it is in optimal format for Ml. Some useful steps include:\n\nstep_novel(): converts all nominal variables to factors and takes care of other issues related to categorical variables.\nstep_normalize(): normalizes (center and scales) the numeric variables to have a standard deviation of one and a mean of zero. (i.e., z-standardization).\nstep_dummy(): converts our factor column ocean_proximity into numeric binary (0 and 1) variables.\n\nNote that this step may cause problems if your categorical variable has too many levels - especially if some of the levels are very infrequent. In this case you should either drop the variable or pool infrequently occurring values into an “other” category with step_other. This steps has to be performed before step_dummy.\n\nstep_zv(): removes any numeric variables that have zero variance.\nstep_corr(): will remove predictor variables that have large correlations with other predictor variables.\n\nEdit: data is already in centered log-ratio transform and further normalization doesn’t really help.\n\n\nShow/hide code\nbalclr_5c_rec &lt;- recipes::recipe(home_env_5c ~ ., data = balclr_5c_train) %&gt;% \n  #step_novel(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_normalize(od600, ciliate_per_ml) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_zv(od600, ciliate_per_ml)# %&gt;% \n  #step_corr(all_predictors(), threshold = 0.7, method = \"spearman\")\n\n\nYou can take a peek at the what the preprocessing recipe does using prep and bake\n\n\nShow/hide code\nbalclr_5c_rec %&gt;% \n  # perform the recipe on training data\n  recipes::prep() %&gt;% \n  # extract only the preprocessed dataframe \n  recipes::bake(new_data = NULL)\n\n\n\n  \n\n\n\n\n\n5.1.3 Model specifications\nThe process of specifying models is:\n\nPick a model type\nSet the engine\nSet the mode: regression or classification\n\n\n\nShow/hide code\nlibrary(rules)\nlibrary(baguette)\n\nsvm_r_spec &lt;- \n   parsnip::svm_rbf(cost = tune(), rbf_sigma = tune()) %&gt;% \n   parsnip::set_engine(\"kernlab\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nsvm_p_spec &lt;- \n   parsnip::svm_poly(cost = tune(), degree = tune()) %&gt;% \n   parsnip::set_engine(\"kernlab\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\ncart_spec &lt;- \n   parsnip::decision_tree(cost_complexity = tune(), min_n = tune()) %&gt;% \n   parsnip::set_engine(\"rpart\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nbag_cart_spec &lt;- \n   parsnip::bag_tree() %&gt;% \n   parsnip::set_engine(\"rpart\", times = 50L) %&gt;% \n   parsnip::set_mode(\"classification\")\n\nrf_spec &lt;- \n   parsnip::rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %&gt;% \n   parsnip::set_engine(\"ranger\", importance = \"impurity\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nxgb_spec &lt;- \n   parsnip::boost_tree(tree_depth = tune(), learn_rate = tune(), loss_reduction = tune(), \n              min_n = tune(), sample_size = tune(), trees = tune()) %&gt;% \n   parsnip::set_engine(\"xgboost\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nnnet_spec &lt;- \n   parsnip::mlp(hidden_units = tune(), penalty = tune(), epochs = tune()) %&gt;% \n   parsnip::set_engine(\"nnet\", MaxNWts = 2600) %&gt;% \n   parsnip::set_mode(\"classification\")\n\nfda_spec &lt;- \n   parsnip::discrim_flexible(prod_degree = tune()) %&gt;%  #&lt;- use GCV to choose terms\n   parsnip::set_engine(\"earth\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nbart_spec &lt;- \n  parsnip::bart(trees = 1000, prior_terminal_node_coef = tune(), prior_terminal_node_expo = tune()) %&gt;% \n  parsnip::set_engine(\"dbarts\") %&gt;% \n  parsnip::set_mode(\"classification\")\n\n\n\n\n5.1.4 Create workflow set\nNow we need to specify the workflows that will be followed for the different model types\n\n\nShow/hide code\nbalclr_5c_wf &lt;- \n   workflowsets::workflow_set(\n      preproc = list(balclr_5c = balclr_5c_rec), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        #bart = bart_spec, \n        #fda = fda_spec,\n        RF = rf_spec)\n   )\n\nbalclr_5c_wf\n\n\n\n  \n\n\n\n\n\n5.1.5 Tune\nTrain and test performance for all the different models over the different train/test and 5-fold cv splits. This takes a long time to run…\n\n\nShow/hide code\nbalclr_5c_grid_results &lt;-\n   workflowsets::workflow_map(balclr_5c_wf, \n      seed = 1578,\n      resamples = balclr_5c_folds,\n      grid = 15,\n      control = tune::control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nreadr::write_rds(balclr_5c_grid_results, here::here(data_ml, \"model_tune_5_class.rds\"))\n\n\n\n\n5.1.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best according to area under the receiver operator curve\n\nShow/hide code\nmymetric &lt;- \"roc_auc\"\n\ntune::autoplot(\n  balclr_5c_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Mean and standard deviation across train-test splits of the areas under the receiver operator curves for the different models. boosting = Gradient Boosted Trees Classifier (XGBoost), RF = Random Forest Classifier (Ranger).\n\n\n\n\n5.1.6.1 Peformance metrics for best model\nDefines a function for easily extracting metrics of interest\n\n\nShow/hide code\ngetmymetrics &lt;- function(gridresults, myworkflow, mymetric, mysplit){\n  best_results &lt;- gridresults %&gt;% \n   workflowsets::extract_workflow_set_result(myworkflow) %&gt;% \n   tune::select_best(metric = mymetric)\n  \n   gridresults %&gt;% \n     hardhat::extract_workflow(myworkflow) %&gt;% \n     tune::finalize_workflow(best_results) %&gt;% \n     tune::last_fit(split = mysplit,\n             metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec))\n}\n\n\nCall the function to get performance metrics of different models\n\n\nShow/hide code\nset.seed(23784)\nbalclr_5c_rf_test_results &lt;- getmymetrics(balclr_5c_grid_results,\n                                          \"balclr_5c_RF\",\n                                          \"roc_auc\",\n                                          balclr_5c_split)\nbalclr_5c_boosting_test_results &lt;- getmymetrics(balclr_5c_grid_results,\n                                                \"balclr_5c_boosting\",\n                                                \"roc_auc\",\n                                                balclr_5c_split)\n\n\nDefines a function to collect and format metrics of different models and calls the function on all the different trained models\n\n\nShow/hide code\ncollect_format &lt;- function(res, name){\n  tune::collect_metrics(res) %&gt;%\n    dplyr::select(metric = .metric,\n                {{ name }} := .estimate,\n                estimate_type = .estimator)\n}\n\ncollect_format(balclr_5c_rf_test_results, \"random_forest\") %&gt;% \n  dplyr::left_join(collect_format(balclr_5c_boosting_test_results, \"boosting\"), by = join_by(metric, estimate_type)) %&gt;% \n  dplyr::relocate(estimate_type, metric)\n\n\n\n  \n\n\n\n\n\n5.1.6.2 ROC and PR curves\nThis is a useful resource for understanding ROC curves and PR curves.\nROC curves here indicate that there is decent performance for the evolution environments of the ancestral clones, bacteria only, and bacteria plus ciliates. Performance is worse for treatments with streptomycin (see the PR curves). This is consistent with the strong overlap in community composition that we saw between strep and strep plus ciliate treatments. If the community response of the treatments is similiar it will be difficult to identify discriminating patterns in the data.\n\nShow/hide code\nbalclr_5c_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::roc_curve(home_env_5c, .pred_anc:.pred_bact_strep) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: ROC curve for True positive rate (TPR, vertical axis) versus the false positive rate (FPR, horizontal axis) for the five different evolutionary histories in the experiment from the hold-out testing data. The dashed 1:1 line is the expected performance of a random classifier. Curves above the 1:1 are better performance than random. Curves below 1:1 are worse performance than random.\n\n\n\n\nShow/hide code\nbalclr_5c_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::pr_curve(home_env_5c, .pred_anc:.pred_bact_strep) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Precision recall curves for the five different evolutionary histories in the experiment from the hold-out testing data. There is a good tuorial for interpretation of these plots on scikit-learn.\n\n\n\n\n\n5.1.6.3 Confusion matrix\nThe confusion matrix shows that for ciliates evolution environment (bact_pred), the model is only getting the evolution environment correct about half the time (10 correct/8 incorrect) which is basically the same as guessing. The best performing home environments are the ancestral and the combined predators and streptomycin treatments.\n\nShow/hide code\nbalclr_5c_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::conf_mat(home_env_5c, .pred_class) %&gt;%\n  tune::autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Confusion matrix showing the classifier performance on each of the five evolutionary history classes using the hold-out testing data.\n\n\n\n\n\n5.1.6.4 Probability distributions for the 5 classes\nGradient boosting trees give each prediction a probability for every class. The higher the probability the higher the confidence in the prediction. We can visualize the distribution of these prediction probabilities to get some insight as to which classes the model has trouble distinguishing and which are very clearly separated.\n\nShow/hide code\nbalclr_5c_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  tidyr::pivot_longer(c(\n    .pred_anc,\n    .pred_bact,\n    .pred_bact_pred,\n    .pred_bact_pred_strep,\n    .pred_bact_strep\n  )) %&gt;%\n  ggplot2::ggplot() +\n  ggplot2::geom_density(aes(x = value, fill = home_env_5c), alpha = 0.5) +\n  ggplot2::labs(x = \"Prediction Probability\", y = \"Density\") +\n  ggplot2::facet_wrap( ~ name)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Prediction probability densities (colors) for each observation of the five evolutionary history classes (grid columns) tested with the model.",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/machine_learning_pipelines/01_machine_learn_home_env.html#classes-ancestral-clones-vs-coevolved-history",
    "href": "R/strep_predator/communities/machine_learning_pipelines/01_machine_learn_home_env.html#classes-ancestral-clones-vs-coevolved-history",
    "title": "Predator and STR Community species composition workflow iii) prediction of evolution environment from measurement environment",
    "section": "5.2 2 classes (ancestral clones vs coevolved history)",
    "text": "5.2 2 classes (ancestral clones vs coevolved history)\nBased on the above analysis and from inspecting the community composition data it appears that ancestral/clonal community has a distinct response to the measurement conditions compared with all the other evolutionary histories. Here instead of trying to predict 5 different home environment classes we just want to predict whether the bacteria had a coevolutionary history from the YSK experiment or not. However, this introduces an additional challenge because now the classes we will be trying to predict are imbalanced.\n\n5.2.1 Spliting\nDone the same as in Section 5.1.1 from the 5-class classification.\n\n\nShow/hide code\nbalclr_ae &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_5c, -home_env_sns, -home_env_pnp) %&gt;% \n  dplyr::mutate(replicate = factor(replicate),\n         transfer = factor(transfer),\n         measure_env = factor(measure_env),\n         home_env_ae = factor(home_env_ae))\n\ntable(balclr_ae$home_env_ae)\n\n\n\nanc evo \n 72 283 \n\n\nSo in this case the classes from the data are clearly not balanced… We will try and address that in the recipe step using the themis package. In particular we use Randomly Over Sampling Examples (ROSE). The ROSE algorithm works by selecting an observation belonging to class k and generates new examples in its neighborhood is determined by some matrix H_k. Smaller values of these arguments have the effect of shrinking the entries of the corresponding smoothing matrix H_k, Shrinking would be a cautious choice if there is a concern that excessively large neighborhoods could lead to blur the boundaries between the regions of the feature space associated with each class.\n\n\nShow/hide code\nset.seed(1467)\nbalclr_ae_split &lt;- rsample::initial_split(balclr_ae, strata = home_env_ae)\nbalclr_ae_train &lt;- rsample::training(balclr_ae_split)\nbalclr_ae_test  &lt;- rsample::testing(balclr_ae_split)\n\n\n\n\nShow/hide code\nset.seed(1468)\nbalclr_ae_folds &lt;- rsample::vfold_cv(balclr_ae_train, strata = home_env_ae)\n\n\n\n\n5.2.2 Recipe\nDone the same as in Section 5.1.2 from the 5-class classification.\n\n\nShow/hide code\nbalclr_ae_rec &lt;- recipes::recipe(home_env_ae ~ ., data = balclr_ae_train) %&gt;% \n  recipes::step_normalize(od600, ciliate_per_ml) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_zv(od600, ciliate_per_ml)\n\nbalclr_ae_rec_rose &lt;- recipes::recipe(home_env_ae ~ ., data = balclr_ae_train) %&gt;% \n  themis::step_rose(home_env_ae) %&gt;% \n  recipes::step_normalize(od600, ciliate_per_ml) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_zv(od600, ciliate_per_ml)\n\n\n\n\n5.2.3 Model specifications\nUsing the same model specifications as in Section 5.1.3 from the 5-class classification.\n\n\n5.2.4 Create workflow set\nSame process as in Section 5.1.4 from the 5-class classification.\n\n\nShow/hide code\nbalclr_ae_wf &lt;- \n   workflowsets::workflow_set(\n      preproc = list(balclr_ae = balclr_ae_rec, \n                     balclr_ae_rose = balclr_ae_rec_rose), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        #bart = bart_spec, \n        #fda = fda_spec,\n        RF = rf_spec\n      )\n   )\n\n\n\n\n5.2.5 Tune\nSame as in Section 5.1.5 from the 5-class classification. Warning this takes some time…\n\n\nShow/hide code\nbalclr_ae_grid_results &lt;-\n   workflowsets::workflow_map(balclr_ae_wf, \n      seed = 1469,\n      resamples = balclr_ae_folds,\n      grid = 15,\n      control = tune::control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nreadr::write_rds(balclr_ae_grid_results, here::here(data_stp_ml, \"model_tune_ae.rds\"))\n\n\n\n\nShow/hide code\nbalclr_ae_grid_results &lt;- readr::read_rds(here::here(data_stp_ml, \"model_tune_ae.rds\"))\n\n\n\n\n5.2.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. We’ll use the J index and the ROC auc as suggested in the tidymodels unbalanced class tutorial.\n\nThe area under the ROC curve is an overall assessment of performance across all cutoffs. Values near one indicate very good results while values near 0.5 would imply that the model is very poor (i.e. no better than guessing)\nThe J index (a.k.a. Youden’s J statistic) is sensitivity + specificity - 1. Values near one are once again best.\n\nIf a model is poorly calibrated, the ROC curve value might not show diminished performance. However, the J index would be lower for models with pathological distributions for the class probabilities. The yardstick package will be used to compute these metrics.\nJ index\n\nShow/hide code\n# which metric to visualize\nmymetric &lt;- \"j_index\"\n\ntune::autoplot(\n  balclr_ae_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Mean and standard deviation across train-test splits of the J-index for the different models. boosting = Gradient Boosted Trees Classifier (XGBoost), RF = Random Forest Classifier (Ranger). Rose indicates that synthetic data has been generated using the ROSE algorithm to better balance the classes.\n\n\n\n\nShow/hide code\n# which metric to visualize\nmymetric &lt;- \"roc_auc\"\n\ntune::autoplot(\n  balclr_ae_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Mean and standard deviation across train-test splits of the areas under the receiver operator curves for the different models. boosting = Gradient Boosted Trees Classifier (XGBoost), RF = Random Forest Classifier (Ranger). Rose indicates that synthetic data has been generated using the ROSE algorithm to better balance the classes.\n\n\n\nIt looks like ROSE preprocessing step helped (at least somewhat) with the J-index. Class imbalance sampling methods tend to greatly improve metrics based on the hard class predictions (i.e., the categorical predictions) because the default cutoff tends to be a better balance of sensitivity and specificity.\n\n5.2.6.1 Peformance metrics for best model\n\n\nShow/hide code\nset.seed(4671)\nbalclr_ae_boosting_test_results &lt;- getmymetrics(balclr_ae_grid_results,\n                                                \"balclr_ae_rose_boosting\",\n                                                \"j_index\",\n                                                balclr_ae_split)\nbalclr_ae_rf_test_results &lt;- getmymetrics(balclr_ae_grid_results,\n                                          \"balclr_ae_rose_RF\",\n                                          \"j_index\",\n                                          balclr_ae_split)\n\ncollect_format(balclr_ae_rf_test_results, \"random_forest\") %&gt;% \n  dplyr::left_join(collect_format(balclr_ae_boosting_test_results, \"boosting\"), by = join_by(metric, estimate_type)) %&gt;% \n  dplyr::relocate(estimate_type, metric)\n\n\n\n  \n\n\n\nGradient boosting and random forest seems to be doing performing about equally here\n\n\n5.2.6.2 ROC and PR curves\nWith unbalaced classes like we have here, it is best to look at both the ROC curve and the PR (precision-recall) curve. See here\n\nShow/hide code\nbalclr_ae_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::roc_curve(home_env_ae, .pred_anc) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: ROC curve for True positive rate (TPR, vertical axis) versus the false positive rate (FPR, horizontal axis) for classifying the evolutionary history as either ancestral/clonal or YSK-derived in the experiment from the hold-out testing data. The dashed 1:1 line is the expected performance of a random classifier. Curves above the 1:1 are better performance than random. Curves below 1:1 are worse performance than random.\n\n\n\n\nShow/hide code\nbalclr_ae_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::pr_curve(home_env_ae, .pred_anc) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Precision recall curves for classifying the evolutionary history as either ancestral/clonal or YSK-derived in the experiment from the hold-out testing data. There is a good tuorial for interpretation of these plots on scikit-learn.\n\n\n\n\n\n5.2.6.3 Confusion matrix\nThe model is doing pretty well finding the communiuties with a coevolutionary history, but it is doing less well at finding the ancestral communities. It is getting the ancestral correct 2/3 of the time.\n\nShow/hide code\nbalclr_ae_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::conf_mat(home_env_ae, .pred_class) %&gt;%\n  tune::autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Confusion matrix showing the classifier performance on each of the two evolutionary history classes using the hold-out testing data. (anc = ancelstra/clonal, evo = from YSK)\n\n\n\n\n\n5.2.6.4 Probability distributions for the 2 classes\n\nShow/hide code\nbalclr_ae_boosting_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  ggplot2::ggplot() +\n  ggplot2::geom_density(aes(x = .pred_evo, fill = home_env_ae), alpha = 0.5) +\n  ggplot2::labs(x = \"Prediction Probability\", y = \"Density\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Prediction probability densities (colors) for each observation of the two evolutionary history classes tested with the model.",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/machine_learning_pipelines/01_machine_learn_home_env.html#classes-streptomycin-history-vs-no-streptomycin-history",
    "href": "R/strep_predator/communities/machine_learning_pipelines/01_machine_learn_home_env.html#classes-streptomycin-history-vs-no-streptomycin-history",
    "title": "Predator and STR Community species composition workflow iii) prediction of evolution environment from measurement environment",
    "section": "5.3 2 classes (streptomycin history vs no streptomycin history)",
    "text": "5.3 2 classes (streptomycin history vs no streptomycin history)\nNow we will try and predict whether the evolutionary history of the communities included exposure to streptomycin\n\n5.3.1 Spliting\nDone the same as in Section 5.1.1 from the 5-class classification.\n\n\nShow/hide code\nbalclr_sns &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_5c, -home_env_ae, -home_env_pnp) %&gt;% \n  dplyr::mutate(replicate = factor(replicate),\n         transfer = factor(transfer),\n         measure_env = factor(measure_env),\n         home_env_sns = factor(home_env_sns)) %&gt;% \n  # we omit the ancestral samples to keep it more balanced\n  tidyr::drop_na()\n\ntable(balclr_sns$home_env_sns)\n\n\n\nnostrep   strep \n    141     142 \n\n\n\n\nShow/hide code\nset.seed(1567)\nbalclr_sns_split &lt;- rsample::initial_split(balclr_sns, strata = home_env_sns)\nbalclr_sns_train &lt;- rsample::training(balclr_sns_split)\nbalclr_sns_test  &lt;- rsample::testing(balclr_sns_split)\n\n\n\n\nShow/hide code\nset.seed(1568)\nbalclr_sns_folds &lt;- rsample::vfold_cv(balclr_sns_train, strata = home_env_sns)\n\n\n\n\n5.3.2 Recipe\nDone the same as in Section 5.1.2 from the 5-class classification.\n\n\nShow/hide code\nbalclr_sns_rec &lt;- recipes::recipe(home_env_sns ~ ., data = balclr_sns_train) %&gt;% \n  recipes::step_normalize(od600, ciliate_per_ml) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_zv(od600, ciliate_per_ml)\n\n\n\n\n5.3.3 Model specifications\nUsing the same model specifications as in Section 5.1.3 from the 5-class classification.\n\n\n5.3.4 Create workflow set\nSame process as in Section 5.1.4 from the 5-class classification.\n\n\nShow/hide code\nlibrary(discrim)\n\nbalclr_sns_wf &lt;- \n   workflowsets::workflow_set(\n      preproc = list(balclr_sns = balclr_sns_rec), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        #bart = bart_spec, \n        #fda = fda_spec,\n        RF = rf_spec\n      )\n   )\n\n\n\n\n5.3.5 Tune\nSame as in Section 5.1.5 from the 5-class classification. Warning this takes some time…\n\n\nShow/hide code\nbalclr_sns_grid_results &lt;-\n   workflowsets::workflow_map(balclr_sns_wf, \n      seed = 1569,\n      resamples = balclr_sns_folds,\n      grid = 15,\n      control = tune::control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nreadr::write_rds(balclr_sns_grid_results, here::here(data_stp_ml, \"model_tune_sns.rds\"))\n\n\n\n\nShow/hide code\nbalclr_sns_grid_results &lt;- readr::read_rds(here::here(data_stp_ml, \"model_tune_sns.rds\"))\n\n\n\n\n5.3.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. It appears that based on all metrics the random forest performs the best.\n\nShow/hide code\nmymetric &lt;- \"roc_auc\"\n\ntune::autoplot(\n  balclr_sns_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Mean and standard deviation across train-test splits of the areas under the receiver operator curves for the different models. boosting = Gradient Boosted Trees Classifier (XGBoost), RF = Random Forest Classifier (Ranger). Rose indicates that synthetic data has been generated using the ROSE algorithm to better balance the classes.\n\n\n\n\n5.3.6.1 Peformance metrics for best model\nAll performance metrics are almost identical (making same overall predictions) with RF just having higher ROC auc\n\n\nShow/hide code\nset.seed(4671)\nbalclr_sns_rf_test_results &lt;- getmymetrics(balclr_sns_grid_results,\n                                           \"balclr_sns_RF\",\n                                           \"roc_auc\",\n                                           balclr_sns_split)\nbalclr_sns_boosting_test_results &lt;- getmymetrics(balclr_sns_grid_results,\n                                                 \"balclr_sns_boosting\",\n                                                 \"roc_auc\",\n                                                 balclr_sns_split)\n\ncollect_format(balclr_sns_rf_test_results, \"random_forest\") %&gt;% \n  dplyr::left_join(collect_format(balclr_sns_boosting_test_results, \"boosting\"), by = join_by(metric, estimate_type)) %&gt;% \n  dplyr::relocate(estimate_type, metric)\n\n\n\n  \n\n\n\n\n\n5.3.6.2 ROC and PR curves\nROC curves indicate that there is good performance for the evolution environments that either contain streptomycin or do not.\n\nShow/hide code\nbalclr_sns_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::roc_curve(home_env_sns, .pred_nostrep) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: ROC curve for True positive rate (TPR, vertical axis) versus the false positive rate (FPR, horizontal axis) for classifying the evolutionary history as either exposed to streptomycin or not in the experiment from the hold-out testing data. The dashed 1:1 line is the expected performance of a random classifier. Curves above the 1:1 are better performance than random. Curves below 1:1 are worse performance than random.\n\n\n\n\nShow/hide code\nbalclr_sns_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::pr_curve(home_env_sns, .pred_nostrep) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Precision recall curves for classifying the evolutionary history as either exposed to streptomycin or not in the experiment from the hold-out testing data. There is a good tuorial for interpretation of these plots on scikit-learn.\n\n\n\n\n\n5.3.6.3 Confusion matrix\n\nShow/hide code\nbalclr_sns_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::conf_mat(home_env_sns, .pred_class) %&gt;%\n  tune::autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Confusion matrix showing the classifier performance on each of the two evolutionary history classes (strep exposure or no strep exposure) using the hold-out testing data. (nostrep = bact and bact_pred, strep = bact_strep, bact_pred_strep)\n\n\n\n\n\n5.3.6.4 Probability distributions for the 2 classes\n\nShow/hide code\nbalclr_sns_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  ggplot2::ggplot() +\n  ggplot2::geom_density(aes(x = .pred_strep, fill = home_env_sns), alpha = 0.5) +\n  ggplot2::labs(x = \"Prediction Probability\", y = \"Density\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Prediction probability densities (colors) for each observation of the two evolutionary history classes tested with the model. (nostrep = bact and bact_pred, strep = bact_strep, bact_pred_strep)",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/strep_predator/communities/machine_learning_pipelines/01_machine_learn_home_env.html#classes-predation-history-vs-no-predation-history",
    "href": "R/strep_predator/communities/machine_learning_pipelines/01_machine_learn_home_env.html#classes-predation-history-vs-no-predation-history",
    "title": "Predator and STR Community species composition workflow iii) prediction of evolution environment from measurement environment",
    "section": "5.4 2 classes (predation history vs no predation history)",
    "text": "5.4 2 classes (predation history vs no predation history)\n\n5.4.1 Spliting\nDone the same as in Section 5.1.1 from the 5-class classification.\n\n\nShow/hide code\nbalclr_pnp &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_5c, -home_env_ae, -home_env_sns) %&gt;% \n  dplyr::mutate(replicate = factor(replicate),\n         transfer = factor(transfer),\n         measure_env = factor(measure_env),\n         home_env_pnp = factor(home_env_pnp)) %&gt;% \n  # we omit the ancestral samples to keep it more balanced\n  tidyr::drop_na()\n\ntable(balclr_pnp$home_env_pnp)\n\n\n\nnopred   pred \n   142    141 \n\n\n\n\nShow/hide code\nset.seed(1567)\nbalclr_pnp_split &lt;- rsample::initial_split(balclr_pnp, strata = home_env_pnp)\nbalclr_pnp_train &lt;- rsample::training(balclr_pnp_split)\nbalclr_pnp_test  &lt;- rsample::testing(balclr_pnp_split)\n\n\n\n\nShow/hide code\nset.seed(1568)\nbalclr_pnp_folds &lt;- rsample::vfold_cv(balclr_pnp_train, strata = home_env_pnp)\n\n\n\n\n5.4.2 Recipe\nDone the same as in Section 5.1.2 from the 5-class classification.\n\n\nShow/hide code\nbalclr_pnp_rec &lt;- recipes::recipe(home_env_pnp ~ ., data = balclr_pnp_train) %&gt;% \n  recipes::step_normalize(od600, ciliate_per_ml) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_zv(od600, ciliate_per_ml)\n\n\n\n\n5.4.3 Model specifications\nUsing the same model specifications as in Section 5.1.3 from the 5-class classification.\n\n\n5.4.4 Create workflow set\nSame process as in Section 5.1.4 from the 5-class classification.\n\n\nShow/hide code\nbalclr_pnp_wf &lt;- \n   workflowsets::workflow_set(\n      preproc = list(balclr_pnp = balclr_pnp_rec), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        #bart = bart_spec, \n        #fda = fda_spec,\n        RF = rf_spec\n      )\n   )\n\n\n\n\n5.4.5 Tune\nSame as in Section 5.1.5 from the 5-class classification. Warning this takes some time…\n\n\nShow/hide code\nbalclr_pnp_grid_results &lt;-\n   workflowsets::workflow_map(balclr_pnp_wf, \n      seed = 1569,\n      resamples = balclr_pnp_folds,\n      grid = 25,\n      control = tune::control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nreadr::write_rds(balclr_pnp_grid_results, here::here(data_stp_ml, \"model_tune_pnp.rds\"))\n\n\n\n\nShow/hide code\nbalclr_pnp_grid_results &lt;- readr::read_rds(here::here(data_stp_ml, \"model_tune_pnp.rds\"))\n\n\n\n\n5.4.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. It appears that based on all metrics the random forest performs the best.\n\nShow/hide code\nmymetric &lt;- \"roc_auc\"\n\ntune::autoplot(\n  balclr_pnp_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17: Mean and standard deviation across train-test splits of the areas under the receiver operator curves for the different models. boosting = Gradient Boosted Trees Classifier (XGBoost), RF = Random Forest Classifier (Ranger).\n\n\n\n\n5.4.6.1 Peformance metrics for best model\nClearly here random forest is doing better\n\n\nShow/hide code\nset.seed(87605)\nbalclr_pnp_boosting_test_results &lt;- getmymetrics(balclr_pnp_grid_results,\n                                                 \"balclr_pnp_boosting\",\n                                                 \"j_index\",\n                                                 balclr_pnp_split)\n\nbalclr_pnp_rf_test_results &lt;- getmymetrics(balclr_pnp_grid_results,\n                                           \"balclr_pnp_RF\",\n                                           \"j_index\",\n                                           balclr_pnp_split)\n\ncollect_format(balclr_pnp_rf_test_results, \"random_forest\") %&gt;% \n  dplyr::left_join(collect_format(balclr_pnp_boosting_test_results, \"boosting\"), by = join_by(metric, estimate_type)) %&gt;% \n  dplyr::relocate(estimate_type, metric)\n\n\n\n  \n\n\n\n\n\n5.4.6.2 ROC and PR curves\nROC curves indicate that there is good performance for the evolution environments that either contain streptomycin or do not.\n\nShow/hide code\nbalclr_pnp_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  yardstick::roc_curve(home_env_pnp, .pred_nopred) %&gt;%\n  tune::autoplot() +\n  ggplot2::labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: ROC curve for True positive rate (TPR, vertical axis) versus the false positive rate (FPR, horizontal axis) for classifying the evolutionary history as either exposed to predator or not in the experiment from the hold-out testing data. The dashed 1:1 line is the expected performance of a random classifier. Curves above the 1:1 are better performance than random. Curves below 1:1 are worse performance than random.\n\n\n\n\nShow/hide code\nbalclr_pnp_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  yardstick::pr_curve(home_env_pnp, .pred_nopred) %&gt;%\n  tune::autoplot() +\n  ggplot2::labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Precision recall curves for classifying the YSK evolutionary history as either exposed to predator or not in the experiment from the hold-out testing data. There is a good tutorial for interpretation of these plots on scikit-learn.\n\n\n\n\n\n5.4.6.3 Confusion matrix\n\nShow/hide code\nbalclr_pnp_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  yardstick::conf_mat(home_env_pnp, .pred_class) %&gt;%\n  tune::autoplot(type = \"heatmap\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 20: Confusion matrix showing the classifier performance on each of the two evolutionary history classes (predator exposure or no predator exposure) using the hold-out testing data. (nospred = bact and bact_strep, pred = bact_pred, bact_pred_strep)\n\n\n\n\n\n5.4.6.4 Probability distributions for the 2 classes\n\nShow/hide code\nbalclr_pnp_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  ggplot2::ggplot() +\n  ggplot2::geom_density(aes(x = .pred_pred, fill = home_env_pnp), alpha = 0.5) +\n  ggplot2::labs(x = \"Prediction Probability\", y = \"Density\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 21: Prediction probability densities (colors) for each observation of the two evolutionary history classes tested with the model. (nopred = bact and bact_strep, pred = bact_pred, bact_pred_strep)",
    "crumbs": [
      "2A. Community composition workflow (Predator and STR)",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html",
    "href": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html",
    "title": "Inspection of growth curves",
    "section": "",
    "text": "Loads required libraries and sets global variables\n\n\nShow/hide code\nlibrary(here)\nlibrary(tidyverse)\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\ndata_raw &lt;- here::here(\"_data_raw\", \"monocultures\", \"20230112_clone_phenotyping\")\n\n\n\n\nDefine functions to make later plotting easier\n\n\nShow/hide code\nplotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, well, plate), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 1)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::geom_line(aes(y=OD600_smooth_avg), color = \"blue\", lty=2), \n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ well, nrow = rows, ncol = cols, page = page), #scales = \"free_y\"\n      ggplot2::theme(axis.text = element_text(size = 9))\n    )\n}",
    "crumbs": [
      "3. Clones workflow (STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html#functions",
    "href": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html#functions",
    "title": "Inspection of growth curves",
    "section": "",
    "text": "Define functions to make later plotting easier\n\n\nShow/hide code\nplotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, well, plate), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 1)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::geom_line(aes(y=OD600_smooth_avg), color = \"blue\", lty=2), \n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ well, nrow = rows, ncol = cols, page = page), #scales = \"free_y\"\n      ggplot2::theme(axis.text = element_text(size = 9))\n    )\n}",
    "crumbs": [
      "3. Clones workflow (STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html#thinning",
    "href": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html#thinning",
    "title": "Inspection of growth curves",
    "section": "3.1 Thinning",
    "text": "3.1 Thinning\nOne thing I’ve realized is that many methods for inferring growth rates struggle when the density of observations is too high (e.g., one measurement every 5 minutes). In reality I’ve found that taking one measurement every 15 minutes is sufficient. Here we thin it out so that measurements are in 20 minute intervals. This seems to improve the fitting procedure a lot without much of a cost.\nThe rounding step is necessary because the plate readers actually don’t always output consistent intervals. Sometimes it is 00:30:06 and other times it is 00:30:05. This becomes a problem later on when trying to combine multiple runs at once\n\n\nShow/hide code\nround_any &lt;- function(x, accuracy, f=round){\n  f(x/ accuracy) * accuracy\n}\n\ngcurves_thin &lt;- gcurves_slurped_fmt %&gt;% \n  dplyr::mutate(seconds = round_any(seconds, 100)) %&gt;% \n  # 1200 is 20 minutes so by ensuring modulo = 0 we include only time points\n  # 0, 20, 40, 60 minutes and so on...\n  dplyr::filter(seconds %% 1200 == 0)",
    "crumbs": [
      "3. Clones workflow (STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html#smoothing",
    "href": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html#smoothing",
    "title": "Inspection of growth curves",
    "section": "3.2 Smoothing",
    "text": "3.2 Smoothing\nFor the growth curves we will do some smoothing to reduce the “jaggedness” of the curves a bit because these were run before the optimized logphase600 protocol was in place (better breatheasy seals plus new sealing tool). We use the slider package with a 5 point rolling mean for each focal observation we take the mean including the focal point and two points before and after.\n\nSee here for a useful thread:\nThis answer seems promising\nPotentially also promising\n\nHere we will smooth out some of the higher frequency noise in the curves. First we wil smooth using a moving median approach then smooth that using a moving average approach. We will also try a min then mean smoothing approach. Some of the curves are really wacky with lots of erratic peaks…\n\n\nShow/hide code\ngcurves_thin_sm &lt;- gcurves_thin %&gt;% \n  dplyr::group_by(plate, well) %&gt;% \n  dplyr::mutate(OD600_smooth_md = slider::slide_dbl(OD600, median, .before = 2, .after = 2)) %&gt;% \n  dplyr::mutate(OD600_smooth_avg = slider::slide_dbl(OD600, mean, .before = 2, .after = 2)) %&gt;% \n  dplyr::mutate(OD600_smooth_md_avg = slider::slide_dbl(OD600_smooth_md, mean, .before = 2, .after = 2)) %&gt;% \n  ungroup()\n\nreadr::write_tsv(gcurves_thin_sm, here::here(data_cl, \"gcurves_smoothed_thinned.tsv\"))",
    "crumbs": [
      "3. Clones workflow (STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html#bact-conditions",
    "href": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html#bact-conditions",
    "title": "Inspection of growth curves",
    "section": "4.1 Bact conditions",
    "text": "4.1 Bact conditions\n\n4.1.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Growth curves for the bacteria only conditions on Plate 1. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.1.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Growth curves for the bacteria only conditions on Plate 2. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.1.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Growth curves for the bacteria only conditions on Plate 3. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.1.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Growth curves for the bacteria only conditions on Plate 4. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.1.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Growth curves for bacteria only conditions on Plate 5. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.1.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Growth curves for bacteria only conditions on Plate 6. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.1.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Growth curves for bacteria only conditions on Plate 7. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.1.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Growth curves for bacteria only conditions on Plate 8. Orange solid line is raw data, blue line is 5-point rolling mean smooth.",
    "crumbs": [
      "3. Clones workflow (STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html#streptomycin-conditions",
    "href": "R/strep_only/monocultures/clone_phenotyping/01_growth_curve_qc.html#streptomycin-conditions",
    "title": "Inspection of growth curves",
    "section": "4.2 Streptomycin conditions",
    "text": "4.2 Streptomycin conditions\n\n4.2.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Growth curves for the Streptomycin conditions on Plate 1. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.2.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Growth curves for the Streptomycin conditions on Plate 2. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.2.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Growth curves for the Streptomycin conditions on Plate 3. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.2.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Growth curves for the Streptomycin conditions on Plate 4. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.2.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Growth curves for Streptomycin conditions on Plate 5. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.2.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Growth curves for Streptomycin conditions on Plate 6. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.2.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Growth curves for Streptomycin conditions on Plate 7. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n4.2.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Growth curves for Streptomycin conditions on Plate 8. Orange solid line is raw data, blue line is 5-point rolling mean smooth.",
    "crumbs": [
      "3. Clones workflow (STR)",
      "i) Inspect/Smooth curves"
    ]
  },
  {
    "objectID": "R/strep_only/communities/cell_density/01_analysis.html",
    "href": "R/strep_only/communities/cell_density/01_analysis.html",
    "title": "Process and plot bacteria densities",
    "section": "",
    "text": "This code loads required libraries and sets global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(withr)\nlibrary(Rtsne)\nlibrary(patchwork)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\nThis code reads optical density data - OD600 and creates variables used later\n\n\nShow/hide code\nod &lt;- readr::read_tsv(here::here(data_ds, \"OD600.tsv\")) %&gt;%\n  dplyr::group_by(measure_env, evolution_env) %&gt;%\n  dplyr::mutate(mean_od = median(od600)) %&gt;%\n  dplyr::ungroup() %&gt;%\n  dplyr::mutate(\n    measure_env_short = dplyr::case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    home_env_short = dplyr::case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "1. Community densities workflow (STR)",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/strep_only/communities/cell_density/01_analysis.html#read-and-format-optical-density-data",
    "href": "R/strep_only/communities/cell_density/01_analysis.html#read-and-format-optical-density-data",
    "title": "Process and plot bacteria densities",
    "section": "",
    "text": "This code reads optical density data - OD600 and creates variables used later\n\n\nShow/hide code\nod &lt;- readr::read_tsv(here::here(data_ds, \"OD600.tsv\")) %&gt;%\n  dplyr::group_by(measure_env, evolution_env) %&gt;%\n  dplyr::mutate(mean_od = median(od600)) %&gt;%\n  dplyr::ungroup() %&gt;%\n  dplyr::mutate(\n    measure_env_short = dplyr::case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    home_env_short = dplyr::case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "1. Community densities workflow (STR)",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/strep_only/communities/amplicon_sp_counts/02_composition_analysis.html",
    "href": "R/strep_only/communities/amplicon_sp_counts/02_composition_analysis.html",
    "title": "Analysis of community compositions",
    "section": "",
    "text": "Loads required libraries and sets global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(Rtsne)\nlibrary(patchwork)\nlibrary(philentropy)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "ii) Community composition"
    ]
  },
  {
    "objectID": "R/strep_only/communities/amplicon_sp_counts/02_composition_analysis.html#jsd-to-ancestor-no-samples-filtered",
    "href": "R/strep_only/communities/amplicon_sp_counts/02_composition_analysis.html#jsd-to-ancestor-no-samples-filtered",
    "title": "Analysis of community compositions",
    "section": "6.1 JSD to ancestor no samples filtered",
    "text": "6.1 JSD to ancestor no samples filtered\n\n\nShow/hide code\n# create a matrix of species frequencies\nprob_mat &lt;- counts_f %&gt;% \n  dplyr::select(sample, strainID, f) %&gt;% \n  tidyr::pivot_wider(names_from = strainID, values_from = f) %&gt;% \n  tibble::column_to_rownames(var = \"sample\") %&gt;% \n  as.matrix()\n\n# calculate JSD between all pairs using philentropy::JSD\njsd_mat &lt;- philentropy::JSD(prob_mat)\n\n# get nonredundant pairings\nind &lt;- which(upper.tri(jsd_mat, diag = TRUE), arr.ind = TRUE)\nnn &lt;- list(rownames(prob_mat), rownames(prob_mat))\njsddf &lt;- data.frame(sample.x = nn[[1]][ind[, 1]],\n           sample.y = nn[[2]][ind[, 2]],\n           jsd = jsd_mat[ind])\n\n# metadata for joining\nmd &lt;- dplyr::distinct(counts_f, sample, replicate, transfer, measure_env_short, home_env_short)\n\n# convert to long format\njsddf_long_md &lt;- jsddf %&gt;% \n  dplyr::left_join(md, by = join_by(sample.x==sample)) %&gt;% \n  dplyr::left_join(md, by = join_by(sample.y==sample))\n\n\nFilter JSD pairs to only those that are relative to ancestral community in each measurement environment. Also calculate mean and boostrapped 95CI using HMisc\n\n\nShow/hide code\njsddf_long_md_filt &lt;- jsddf_long_md %&gt;% \n  dplyr::filter(measure_env_short.x == measure_env_short.y) %&gt;% \n  dplyr::filter(home_env_short.x != home_env_short.y & transfer.x == transfer.y & home_env_short.x == \"Home: Anc\") %&gt;% \n  dplyr::summarize(ggplot2::mean_cl_boot(jsd), .by=c(transfer.y, home_env_short.y, measure_env_short.y)) %&gt;% \n  dplyr::mutate(home_env_short.y = factor(home_env_short.y))\n\n\nHmmm…. not sure what exactly this is telling, but I am calculating the within home/measurement divergence as some kind of variability baseline.\n\n\nShow/hide code\nintrarepvar &lt;- jsddf_long_md %&gt;% \n  dplyr::filter(measure_env_short.x == measure_env_short.y & home_env_short.x == home_env_short.y & transfer.x == transfer.y) %&gt;% \n  dplyr::summarize(ggplot2::mean_cl_boot(jsd), .by=c(transfer.y, home_env_short.y, measure_env_short.y)) %&gt;% \n  dplyr::filter(home_env_short.y != \"Home: Anc\") %&gt;% \n  dplyr::mutate(home_env_short.y = factor(home_env_short.y))\n\n\nMake plot of JSD to ancestral communities in each condition and save in raster/vector format\n\n\nShow/hide code\nplot_jsd &lt;- function(intra_df, df){\n  mycols &lt;- c(\"Home: B\" = \"#66c2a5\", \"Home: BS\" = \"#fc8d62\")\n  ggplot2::ggplot() +\n  ggplot2::geom_ribbon(data = intra_df, \n              aes(x = transfer.y, ymin = ymin, ymax=ymax, fill = home_env_short.y), alpha=0.25) + \n  ggplot2::geom_line(data = intra_df, \n            aes(x = transfer.y, y=y, color = home_env_short.y), alpha=0.5, lty=2) + \n  ggplot2::geom_point(data = df, aes(x = transfer.y, y = y, group = home_env_short.y, color = home_env_short.y)) +\n  ggplot2::geom_linerange(data = df, \n                 aes(x = transfer.y, ymin = ymin, ymax = ymax, color = home_env_short.y)) + \n  ggplot2::geom_line(data= df, \n            aes(x = transfer.y, y = y, group = home_env_short.y, color = home_env_short.y)) + \n  ggplot2::facet_grid(measure_env_short.y ~ home_env_short.y, scales = \"free_y\") + \n  ggplot2::labs(x = \"Growth Cycles\", y = \"Jensen-Shannon Divergence relative to ancestor\", color = \"Home\\nEnvironment\", fill = \"Home\\nEnvironment\") +\n  #ggplot2::scale_y_sqrt() +\n  ggplot2::scale_x_continuous(breaks = c(4, 8, 12), limits = c(3.5, 12.5)) +\n  ggplot2::scale_color_manual(values=mycols) +\n  ggplot2::scale_fill_manual(values=mycols) +\n  ggplot2::theme_bw() +\n  ggplot2::theme(\n    #panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n}\n\n\n\n\nShow/hide code\npjsd &lt;- plot_jsd(intrarepvar, jsddf_long_md_filt)\n\nggplot2::ggsave(\n  here::here(figs, \"community_jsd_to_anc.svg\"),\n  pjsd,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(figs, \"community_jsd_to_anc.png\"),\n  pjsd,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Mean \\(\\pm\\) 95% CI of the pairwise Jensen-Shannon Divergence between the ancestral/clonal community composition (Figure 1 C) and the community composition in YSK Home environments (Home, grid columns) for each measurement environment (Meas, grid rows) in the transplantation experiment (see also Figure 1 D). Mean divergences are nested within Growth Cycles (horizontal axis) where one growth cycle is 7 days. Dashed lines indicate mean and ribbons indicate 95% CI for the mean within-condition Jensen-Shannon Divergence and is meant as an indicator of replicate variability within each Home/Measurement treatment combination.",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "ii) Community composition"
    ]
  },
  {
    "objectID": "R/strep_only/communities/amplicon_sp_counts/02_composition_analysis.html#jsd-to-ancestor---idiosyncratic-samples-filtered",
    "href": "R/strep_only/communities/amplicon_sp_counts/02_composition_analysis.html#jsd-to-ancestor---idiosyncratic-samples-filtered",
    "title": "Analysis of community compositions",
    "section": "6.2 JSD to ancestor - idiosyncratic samples filtered",
    "text": "6.2 JSD to ancestor - idiosyncratic samples filtered\nIn Figure 1 is it clear that some of the replicates in samples from YSK have a very different composition from the others. This is likely due to rapid resistance evolution of HAMBI 1972 in those particular replicates from YSK (will need to verify with the metagenomes). HAMBI_1972 is normally very sensitive to STR. The idea in this section is to repeat the JSD to ancestor analysis but exclude these idiosyncratic replicates - A and F from YSK BS, C and E from YSK B. We want to make sure that the trends in JSD relative to the ancestral community is not being driven primarily by these outlier replicates.\nFilter JSD pairs to only those that are relative to ancestral community in each measurement environment. Also exclude the replicates mentioned above. Finally calculate mean and boostrapped 95CI using HMisc.\n\n\nShow/hide code\njsddf_long_md_filt2 &lt;- jsddf_long_md %&gt;% \n  dplyr::filter(measure_env_short.x == measure_env_short.y) %&gt;% \n  dplyr::filter(home_env_short.x != home_env_short.y & transfer.x == transfer.y & home_env_short.x == \"Home: Anc\") %&gt;% \n  dplyr::filter(!((measure_env_short.x == \"Meas: BS\" & home_env_short.y == \"Home: BS\") & str_detect(replicate.x, \"A|F\") | str_detect(replicate.y, \"A|F\"))) %&gt;% \n  dplyr::filter(!((measure_env_short.x == \"Meas: BS\" & home_env_short.y == \"Home: B\") & str_detect(replicate.x, \"C|E\") | str_detect(replicate.y, \"C|E\"))) %&gt;% \n  dplyr::summarize(ggplot2::mean_cl_boot(jsd), .by=c(transfer.y, home_env_short.y, measure_env_short.y)) %&gt;% \n  dplyr::mutate(home_env_short.y = factor(home_env_short.y))\n\n\nCalculating the within home/measurement divergence as some kind of variability baseline but with the outlier replicates excluded.\n\n\nShow/hide code\nintrarepvar2 &lt;- jsddf_long_md %&gt;% \n  dplyr::filter(measure_env_short.x == measure_env_short.y & home_env_short.x == home_env_short.y & transfer.x == transfer.y) %&gt;% \n    dplyr::filter(!((measure_env_short.x == \"Meas: BS\" & home_env_short.y == \"Home: BS\") & str_detect(replicate.x, \"A|F\") | str_detect(replicate.y, \"A|F\"))) %&gt;% \n  dplyr::filter(!((measure_env_short.x == \"Meas: BS\" & home_env_short.y == \"Home: B\") & str_detect(replicate.x, \"C|E\") | str_detect(replicate.y, \"C|E\"))) %&gt;% \n  dplyr::summarize(ggplot2::mean_cl_boot(jsd), .by=c(transfer.y, home_env_short.y, measure_env_short.y)) %&gt;% \n  dplyr::filter(home_env_short.y != \"Home: Anc\") %&gt;% \n  dplyr::mutate(home_env_short.y = factor(home_env_short.y))\n\n\nMake plot of JSD to ancestral communities in each condition and save in raster/vector format\n\n\nShow/hide code\npjsd2 &lt;- plot_jsd(intrarepvar2, jsddf_long_md_filt2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Same as in Figure 3 but with excluding the idiosyncratic replicates A and F from YSK Strep and C and E from YSK Bact.\n\n\n\nSo here it does appear that the trends still hold but now the JSD to ancestor always exceeds variation within each environment/evolutionary history.",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "ii) Community composition"
    ]
  },
  {
    "objectID": "R/strep_only/communities/amplicon_sp_counts/02_composition_analysis.html#jsd-to-ysk-founder-community",
    "href": "R/strep_only/communities/amplicon_sp_counts/02_composition_analysis.html#jsd-to-ysk-founder-community",
    "title": "Analysis of community compositions",
    "section": "6.3 JSD to YSK founder community",
    "text": "6.3 JSD to YSK founder community\nHere I just wanted to check how each community with an YSK evolutionary history compares to the original YSK source material\n\nShow/hide code\njsddf_long_md %&gt;% \n  dplyr::filter(transfer.x == 0 | transfer.y == 0) %&gt;% \n  dplyr::filter(home_env_short.x != \"Home: Anc\") %&gt;% \n  dplyr::filter(str_remove(measure_env_short.y, \"Meas: \") == str_remove(home_env_short.y, \"Home: \")) %&gt;% \n  #dplyr::filter(home_env_short.x == home_env_short.y) %&gt;% \n  dplyr::filter(replicate.x == replicate.y) %&gt;% \n  ggplot(aes(x= replicate.x, y = jsd)) +\n  geom_jitter(aes(color = factor(transfer.y)), height = 0.01, width = 0.1) + \n  facet_grid(measure_env_short.y ~ home_env_short.x) +\n  ggplot2::labs(x = \"Replicate microcosm\", y = \"Jensen-Shannon Divergence relative YSK source\", color = \"Transfer\") +\n  ggplot2::theme_bw() +\n  ggplot2::theme(\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: JSD relative to 58 week YSK source material (nested by replicate) for each treatment/YSK history and transfer in the main experiment. Excludes sames that were inoculated with the ancestral community.",
    "crumbs": [
      "2. Community composition workflow (STR)",
      "ii) Community composition"
    ]
  }
]