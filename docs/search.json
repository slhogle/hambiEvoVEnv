[
  {
    "objectID": "R/20240318_BTK_illumina_v3/02_composition_analysis.html",
    "href": "R/20240318_BTK_illumina_v3/02_composition_analysis.html",
    "title": "Community composition analysis",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(withr)\nlibrary(Rtsne)\nlibrary(patchwork)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"20240318_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"20240318_BTK_illumina_v3\")\nfigs &lt;- here::here(\"figs\", \"20240318_BTK_illumina_v3\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\nfs::dir_create(figs)\n\n\n\n\n\nsptable &lt;- read_tsv(here::here(data, \"species_counts_md.tsv\")) %&gt;% \n  mutate(transfer = day/7)\n\ncounts_f &lt;- sptable %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f=count_correct/sum(count_correct)) %&gt;% \n  ungroup() %&gt;% \n  mutate(measure_env_short = case_when(measure_env == \"bact\" ~ \"Meas: B\",\n                                       measure_env == \"bact_pred\" ~ \"Meas: BP\",\n                                       measure_env == \"bact_strep\" ~ \"Meas: BS\",\n                                       measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\")) %&gt;% \n  mutate(home_env_short = case_when(evolution_env == \"anc\" ~ \"Home: Anc\",\n                                    evolution_env == \"bact\" ~ \"Home: B\",\n                                    evolution_env == \"bact_pred\" ~ \"Home: BP\",\n                                    evolution_env == \"bact_strep\" ~ \"Home: BS\",\n                                    evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\")) %&gt;% \n  mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\n\n\n\n\n# these are communities of a (supposedly) known composition. Can be used with metacal\npos_ctrl_samples &lt;- counts_f %&gt;% \n  filter(str_detect(sample, \"pos_ctrl\"))\n\n# these are samples taken directly from YSK and represent the composition of the communities used to start the experiment\nt0_samples &lt;- counts_f %&gt;% \n  filter(!str_detect(sample, \"pos_ctrl\")) %&gt;% \n  filter(day == 0)\n\n# only samples from the experiment\ncounts_f_experiment &lt;- anti_join(counts_f, pos_ctrl_samples) %&gt;% \n  anti_join(., t0_samples) %&gt;% \n  mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\nJoining with `by = join_by(sample, strainID, genus, species, count,\ncount_correct, replicate, day, measure_env, evolution_env, transfer, f,\nmeasure_env_short, home_env_short)`\nJoining with `by = join_by(sample, strainID, genus, species, count,\ncount_correct, replicate, day, measure_env, evolution_env, transfer, f,\nmeasure_env_short, home_env_short)`",
    "crumbs": [
      "Community composition amplicon",
      "2. Analysis of community composition"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#libraries-and-global-variables",
    "href": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#libraries-and-global-variables",
    "title": "Community composition analysis",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(withr)\nlibrary(Rtsne)\nlibrary(patchwork)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "Community composition amplicon",
      "2. Analysis of community composition"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#required-directories",
    "href": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#required-directories",
    "title": "Community composition analysis",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"20240318_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"20240318_BTK_illumina_v3\")\nfigs &lt;- here::here(\"figs\", \"20240318_BTK_illumina_v3\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\nfs::dir_create(figs)",
    "crumbs": [
      "Community composition amplicon",
      "2. Analysis of community composition"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#read-and-format-16s-amplicon-data",
    "href": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#read-and-format-16s-amplicon-data",
    "title": "Community composition analysis",
    "section": "",
    "text": "sptable &lt;- read_tsv(here::here(data, \"species_counts_md.tsv\")) %&gt;% \n  mutate(transfer = day/7)\n\ncounts_f &lt;- sptable %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f=count_correct/sum(count_correct)) %&gt;% \n  ungroup() %&gt;% \n  mutate(measure_env_short = case_when(measure_env == \"bact\" ~ \"Meas: B\",\n                                       measure_env == \"bact_pred\" ~ \"Meas: BP\",\n                                       measure_env == \"bact_strep\" ~ \"Meas: BS\",\n                                       measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\")) %&gt;% \n  mutate(home_env_short = case_when(evolution_env == \"anc\" ~ \"Home: Anc\",\n                                    evolution_env == \"bact\" ~ \"Home: B\",\n                                    evolution_env == \"bact_pred\" ~ \"Home: BP\",\n                                    evolution_env == \"bact_strep\" ~ \"Home: BS\",\n                                    evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\")) %&gt;% \n  mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))",
    "crumbs": [
      "Community composition amplicon",
      "2. Analysis of community composition"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#tidying",
    "href": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#tidying",
    "title": "Community composition analysis",
    "section": "",
    "text": "# these are communities of a (supposedly) known composition. Can be used with metacal\npos_ctrl_samples &lt;- counts_f %&gt;% \n  filter(str_detect(sample, \"pos_ctrl\"))\n\n# these are samples taken directly from YSK and represent the composition of the communities used to start the experiment\nt0_samples &lt;- counts_f %&gt;% \n  filter(!str_detect(sample, \"pos_ctrl\")) %&gt;% \n  filter(day == 0)\n\n# only samples from the experiment\ncounts_f_experiment &lt;- anti_join(counts_f, pos_ctrl_samples) %&gt;% \n  anti_join(., t0_samples) %&gt;% \n  mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\nJoining with `by = join_by(sample, strainID, genus, species, count,\ncount_correct, replicate, day, measure_env, evolution_env, transfer, f,\nmeasure_env_short, home_env_short)`\nJoining with `by = join_by(sample, strainID, genus, species, count,\ncount_correct, replicate, day, measure_env, evolution_env, transfer, f,\nmeasure_env_short, home_env_short)`",
    "crumbs": [
      "Community composition amplicon",
      "2. Analysis of community composition"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#save",
    "href": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#save",
    "title": "Community composition analysis",
    "section": "2.1 Save",
    "text": "2.1 Save\n\nggsave(here::here(figs, \"species_composition_bar.svg\"), pbar, width=8, height=10, units=\"in\",\n       device=\"svg\")",
    "crumbs": [
      "Community composition amplicon",
      "2. Analysis of community composition"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#plot-with-home-and-measure-environments-highlighted",
    "href": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#plot-with-home-and-measure-environments-highlighted",
    "title": "Community composition analysis",
    "section": "3.1 Plot with home and measure environments highlighted",
    "text": "3.1 Plot with home and measure environments highlighted\n\n# plotting function\nptsne &lt;- function(tsne_obj, variable, colors){\n  data.frame(tsne_obj$Y) %&gt;% \n  cbind(distinct(dplyr::select(counts_f_experiment, sample, replicate, transfer, measure_env_short, home_env_short))) %&gt;% \n  ggplot() +\n  geom_point(aes(x= X2, y = X1, color = {{ variable }}), size = 3, alpha = 0.75) +\n  scale_y_continuous(breaks = c(10, 0, -10)) +\n  coord_fixed() + \n  labs(x = \"tSNE dimension 1\", \n       y = \"tSNE dimension 2\", \n       shape = \"Transfer\") +\n  scale_color_manual(values = colors) +\n  facet_grid(~transfer, labeller = label_both) +\n  theme_bw() +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  ) \n}\n\nMake the patchwork layout\n\npm &lt;- ptsne(mymat_tsne, measure_env_short, c(\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\")) +\n  labs(color = \"Measure\\nenvironment\")\nph &lt;- ptsne(mymat_tsne, home_env_short, c(\"#fdbf6f\", \"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\")) +\n  labs(color = \"Home\\nenvironment\")\n\npt &lt;- pm + ph +\n  plot_layout(guides = 'collect', nrow = 2) +\n  plot_annotation(tag_levels = 'A')\n\nplot the figure\n\n\n\n\npt\n\n\n\n\n\n\n\n\n\n\nFigure 2: Dimesnional reduction of bacterial community composition using t-SNE. Each point represents a replicate microcosm sampled at serial transfers 4, 8, and 12 (grid columns). In A) point colors depict the experimental measurement condition from the transplantation experiment. In B) point colors depict the evolutionary history of the inoculating communities (“home environment”).",
    "crumbs": [
      "Community composition amplicon",
      "2. Analysis of community composition"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#save-1",
    "href": "R/20240318_BTK_illumina_v3/02_composition_analysis.html#save-1",
    "title": "Community composition analysis",
    "section": "3.1 Save",
    "text": "3.1 Save\n\nggsave(here::here(figs, \"tsne.svg\"), pt, width=8, height=6, units=\"in\",\n       device=\"svg\")",
    "crumbs": [
      "Community composition amplicon",
      "2. Analysis of community composition"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/01_format_rbec_tab.html",
    "href": "R/20240318_BTK_illumina_v3/01_format_rbec_tab.html",
    "title": "Formatting Rbec output",
    "section": "",
    "text": "1 Introduction\nContains both results from hambiYSKpleiotropy experiment and also a test of the boilprep extraction method from the tipping point experiment.\n\n\n2 Libraries and global variables\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(archive)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n3 Global vars\n\ndata_raw &lt;- here::here(\"_data_raw\", \"20240318_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"20240318_BTK_illumina_v3\")\namplicontar &lt;- here::here(data_raw, \"rbec_output.tar.gz\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n# create temporary location to decompress\ntmpdir &lt;- fs::file_temp()\n\n\n\n4 Untar Rbec output tarball\n\narchive::archive_extract(\n  amplicontar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)\n\n\n\n5 Read and format tables\n\n# set up directory structure\ntabdir &lt;- here::here(tmpdir, \"rbec_output\")\nsamppaths &lt;- fs::dir_ls(tabdir)\nsampnames &lt;- path_split(samppaths) %&gt;% \n  map_chr(dplyr::last)\n\n\n\n6 Read metadata\n\nmddf &lt;- read_tsv(here::here(data_raw, \"20240318_BTK_illumina_v3_metadata.tsv\"))\n\nRows: 414 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (10): pool, fusion_fwd, fusion_rev, sample, project, lib_prep, replicate...\ndbl  (2): amp_conc, day\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n7 Data\n\ntax_locus_copynum &lt;- tibble::tribble(\n     ~strainID, ~rRNA16S_cn, ~rRNA16S_locus,             ~genus,        ~species,\n  \"HAMBI_0006\",          7L,  \"H0006_04757\",      \"Pseudomonas\",        \"putida\",\n  \"HAMBI_0097\",          7L,  \"H0097_00044\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_02759\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_01762\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0105\",          4L,  \"H0105_02306\",    \"Agrobacterium\",   \"tumefaciens\",\n  \"HAMBI_0262\",          3L,  \"H0262_00030\",    \"Brevundimonas\",       \"bullata\",\n  \"HAMBI_0403\",          9L,  \"H0403_00517\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_0403\",          9L,  \"H0403_00522\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_1279\",          7L,  \"H1279_03627\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_00125\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_03957\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1287\",          7L,  \"H1287_03997\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1287\",          7L,  \"H1287_03402\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1292\",          7L,  \"H1292_03239\",       \"Morganella\",      \"morganii\",\n  \"HAMBI_1299\",          8L,  \"H1299_04293\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1299_01283\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1279_03957\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1842\",          4L,  \"H1842_01650\",      \"Sphingobium\",    \"yanoikuyae\",\n  \"HAMBI_1896\",          4L,  \"H1896_00963\", \"Sphingobacterium\",  \"spiritivorum\",\n  \"HAMBI_1972\",         10L,  \"H1972_00343\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1972\",         10L,  \"H1972_03531\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1977\",          5L,  \"H1977_00118\",      \"Pseudomonas\",  \"chlororaphis\",\n  \"HAMBI_1988\",          5L,  \"H1988_05160\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05152\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05165\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_2159\",          4L,  \"H2159_01406\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2159\",          4L,  \"H2159_05851\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2160\",          3L,  \"H2160_00530\",       \"Bordetella\",         \"avium\",\n  \"HAMBI_2164\",          5L,  \"H2164_03337\",      \"Cupriavidus\",    \"oxalaticus\",\n  \"HAMBI_2443\",          3L,  \"H2443_00128\",       \"Paracoccus\", \"denitrificans\",\n  \"HAMBI_2494\",          4L,  \"H2494_03389\", \"Paraburkholderia\",   \"kururiensis\",\n  \"HAMBI_2659\",          4L,  \"H2659_00367\", \"Stenotrophomonas\",   \"maltophilia\",\n  \"HAMBI_2792\",          4L,  \"H2792_00549\",        \"Moraxella\",         \"canis\",\n  \"HAMBI_3031\",          2L,  \"H3031_00830\",         \"Niabella\",  \"yanshanensis\",\n  \"HAMBI_3237\",          6L,  \"H3237_00875\",       \"Microvirga\",   \"lotononidis\",\n  \"HAMBI_1923\",          6L,  \"H1923_00876\",   \"Flavobacterium\",      \"odoratum\"\n  )\n\n\n\n8 Functions\n\n# this function \nnormalize_by_copy &lt;- function(.data, tlc = tax_locus_copynum){\n  .data %&gt;% \n    # join with the copy number data frame. We join by the locus tag so this will add H1279_03957 to HAMBI_1299\n    dplyr::left_join(tlc, by = join_by(rRNA16S_locus)) %&gt;%\n    # get total number of mapping reads per species. This aggregates all the difference ASVs per species\n    dplyr::summarize(count = sum(count), .by = c(sample, strainID, rRNA16S_cn)) %&gt;% \n    # group by sample\n    dplyr::group_by(sample) %&gt;% \n    # calculate a corrected count which is simply the count divided by copy num for each species\n    # dividide by the sum of count divided by copy num for whole sample multiplied by the total\n    # number of mapped reads per sample\n    dplyr::mutate(count_correct = round(sum(count)*(count/rRNA16S_cn)/sum(count/rRNA16S_cn))) %&gt;%  \n    dplyr::ungroup() %&gt;% \n    dplyr::select(sample, strainID, count, count_correct)\n  }\n\n# this function replaces missing species counts with zero\ncompletecombos &lt;- function(.data, tlc = tax_locus_copynum, countname = count, remove1923 = TRUE){\n \n  # get unique strainIDs\n  strainID &lt;- unique(tlc$strainID)\n  # table for assigning genus and species names. Doesn't matter if 1923 is there or not\n  # because it is filter joined later\n  tax &lt;- dplyr::distinct(dplyr::select(tlc, strainID, genus, species))\n  if (remove1923) {\n    # get unique strainIDs but exclude 1923 if remove1923 is true\n    strainID &lt;- strainID[strainID != \"HAMBI_1923\"]\n  }\n  \n  dplyr::bind_rows(tibble::tibble(strainID = strainID, sample = \"dummy\"), .data) %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(sample == \"dummy\", 1, {{ countname }})) %&gt;% \n    tidyr::complete(sample, strainID) %&gt;% \n    dplyr::filter(sample != \"dummy\") %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(is.na({{ countname }}), 0, {{ countname }})) %&gt;% \n    tidyr::replace_na(list(count_correct = 0)) %&gt;% \n    dplyr::left_join(dplyr::distinct(dplyr::select(tlc, strainID, genus, species))) %&gt;% \n    dplyr::relocate(genus, species, .after = strainID)\n}\n\n\n\n9 Read raw counts tables\n\nstraintabs &lt;- paste0(samppaths, \"/strain_table.txt\") %&gt;% \n  set_names(sampnames) %&gt;% \n  map_df(\n  read_tsv,\n  skip = 1,\n  col_names = c(\"rRNA16S_locus\",\"count\"),\n  show_col_types = FALSE, \n  .id = \"sample\") \n\n\n\n10 Format\nNormalize counts by 16S copy number\n\nstraintabs_norm &lt;- normalize_by_copy(straintabs)\n\nWarning in dplyr::left_join(., tlc, by = join_by(rRNA16S_locus)): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 77 of `x` matches multiple rows in `y`.\nℹ Row 21 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\nComplete all combinations of 23 species\n\nstraintabs_norm_fmt &lt;- completecombos(straintabs_norm, tlc = tax_locus_copynum, countname = count, remove1923 = TRUE) \n\nJoining with `by = join_by(strainID)`\n\n\n\nfinaltable &lt;- left_join(straintabs_norm_fmt, mddf)\n\nJoining with `by = join_by(sample)`\n\n\n\nfinaltip &lt;- finaltable %&gt;% \n  filter(project == \"tipping_points\") %&gt;% \n  dplyr::select(-c(pool:project), -lib_prep, -measure_env, -evolution_env)\n\nfinalpleio &lt;- finaltable %&gt;% \n  filter(project == \"amanda_chapt01\") %&gt;% \n  dplyr::select(-c(pool:project), -lib_prep, -evo_hist, -amp_conc)\n\n\n\n11 Write results\n\nwrite_tsv(finalpleio, here::here(data, \"species_counts_md.tsv\"))\n\nwrite_tsv(finaltip, here::here(data, \"species_counts_md_tippingpoints.tsv\"))\n\n\n\n12 Clean up\nremove decompressed coverage directory from temp location\n\nfs::dir_delete(tmpdir)",
    "crumbs": [
      "Community composition amplicon",
      "1. Data wrangling"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data anlalysis for the project hambiYSKpleiotropy",
    "section": "",
    "text": "“TBD”\nPreprint available from bioRxiv"
  },
  {
    "objectID": "index.html#manuscript",
    "href": "index.html#manuscript",
    "title": "Data anlalysis for the project hambiYSKpleiotropy",
    "section": "",
    "text": "“TBD”\nPreprint available from bioRxiv"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Data anlalysis for the project hambiYSKpleiotropy",
    "section": "2 Introduction",
    "text": "2 Introduction\nThis is project contains data from the HAMBI species Long-term Community Selection Experiment (YSK) that Amanda Silvenoinen used in her first PhD thesis experiment. Now Niina Smolander has taken over this project under my supervision."
  },
  {
    "objectID": "index.html#the-long-term-community-evolution-experiment-ysk",
    "href": "index.html#the-long-term-community-evolution-experiment-ysk",
    "title": "Data anlalysis for the project hambiYSKpleiotropy",
    "section": "3 The long-term community evolution experiment (YSK)",
    "text": "3 The long-term community evolution experiment (YSK)\nThe YSK experiment has been growing 24 HAMBI species in a community over a long-term period under four treatments:\n\nbact is the HAMBI community without any additional environmnetal stress - i.e. the control\nbact_strep is the HAMBI community with streptomycin (what concentration?)\nbact_pred is the HAMBI community grown with Tetrahymena thermophila ciliate predator\nbact_pred_strep is the HAMBI community grown with both the predator and the streptomycin.\n\nIn YSK 6 biological replicates were established for each of the four conditions above. These 4 \\(\\times\\) 6 microcosms have been serially transferred (every 7 days) for now almost 150 transfers (2 years 11 months) allowing species to sort and evolution to occur."
  },
  {
    "objectID": "index.html#experiment-overview",
    "href": "index.html#experiment-overview",
    "title": "Data anlalysis for the project hambiYSKpleiotropy",
    "section": "4 Experiment overview",
    "text": "4 Experiment overview\nAfter ?? weeks of regular transfers of YSK, Amanda transplanted the 6 \\(\\times\\) microcosms per environment into each of the other environments resulting in a full factorial treatment design. She also included a treatment where a naive/ancestral HAMBI community was exposed to YSK conditions. She serially transferred this transplant experiment every 7 days into fresh media (same conditions as YSK) for a total of 12 weeks/transfers (84 days). Considering a weekly dilution factor of 1/10 in the serial transfer series, then \\(\\mathrm{log_2(10)} \\approx 3.3\\) generations will have elapsed resulting in an evolutionary scale of \\(3.3 \\times 12 \\approx 40\\) elapsed generations during the transplant experiment."
  },
  {
    "objectID": "index.html#measurements-and-data-types",
    "href": "index.html#measurements-and-data-types",
    "title": "Data anlalysis for the project hambiYSKpleiotropy",
    "section": "5 Measurements and data types",
    "text": "5 Measurements and data types\n\nCommunity DNA was sampled at all transfers.\n16S rRNA amplicon sequencing was performed at transfers 0, 4 (28 days), 8 (56 days), and 12 (84 days)\nCommunity genome (metagenome) sequencing was performed at transfers XYZ\nCiliate cell density and bacterial optical density (\\(\\mathrm{OD_{600}}\\)) were measured at every weekly transfer\nAfter X transfers, 32 clones were isolated from each replicate of the transplant microcosms. High-resolution growth curves were obtained for the clones (obtained using the log-phase 600)"
  },
  {
    "objectID": "index.html#code",
    "href": "index.html#code",
    "title": "Data anlalysis for the project hambiYSKpleiotropy",
    "section": "6 Code",
    "text": "6 Code\n Data and code here is provided under GPL3. Feel free to use or remix as you see fit.\n\n6.1 Project structure\n\n/R contains R scripts\n/data contains data that has been processed in some way for later use\n/_data_raw contains unprocessed data scraped from compute cluster\n/figs contains figures generated from R scripts"
  },
  {
    "objectID": "index.html#availability",
    "href": "index.html#availability",
    "title": "Data anlalysis for the project hambiYSKpleiotropy",
    "section": "7 Availability",
    "text": "7 Availability\nThe rendered project site is available at https://hambidoubleevohi-slhogl-14191cd40bf1aa9a3beb400287f1505ccad06ec.utugit.fi/. The website has been produced using Quarto notebooks.\nThis GitLab repository (https://gitlab.utu.fi/slhogl/hambiYSKpleiotropy) hosts the code and data for this project. The rendered webpage can be fully recreated using the code at https://gitlab.utu.fi/slhogl/hambiYSKpleiotropy."
  },
  {
    "objectID": "index.html#reproducibility",
    "href": "index.html#reproducibility",
    "title": "Data anlalysis for the project hambiYSKpleiotropy",
    "section": "8 Reproducibility",
    "text": "8 Reproducibility\nThe project uses renv to create reproducible environment to execute the code in this project. See here for a brief overview on collaboration and reproduction of the entire project. To get up and running you can do:\ninstall.packages(\"renv\")\nrenv::restore()"
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html",
    "href": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"20240318_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"20240318_BTK_illumina_v3\")\nfigs &lt;- here::here(\"figs\", \"20240318_BTK_illumina_v3\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\nfs::dir_create(figs)\n\n\n\n\n\nsptable &lt;- read_tsv(here::here(data, \"species_counts_md.tsv\")) %&gt;% \n  mutate(transfer = day/7)\n\ncounts_f &lt;- sptable %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f=norm_count/sum(norm_count)) %&gt;% \n  ungroup() %&gt;% \n  mutate(measure_env_short = case_when(measure_env == \"bact\" ~ \"Meas: B\",\n                                       measure_env == \"bact_pred\" ~ \"Meas: BP\",\n                                       measure_env == \"bact_strep\" ~ \"Meas: BS\",\n                                       measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\")) %&gt;% \n  mutate(home_env_short = case_when(evolution_env == \"anc\" ~ \"Home: Anc\",\n                                    evolution_env == \"bact\" ~ \"Home: B\",\n                                    evolution_env == \"bact_pred\" ~ \"Home: BP\",\n                                    evolution_env == \"bact_strep\" ~ \"Home: BS\",\n                                    evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\")) %&gt;% \n  mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\n\n\n\n\n# these are communities of a (supposedly) known composition. Can be used with metacal\npos_ctrl_samples &lt;- counts_f %&gt;% \n  filter(str_detect(sample, \"pos_ctrl\"))\n\n# these are samples taken directly from YSK and represent the composition of the communities used to start the experiment\nt0_samples &lt;- counts_f %&gt;% \n  filter(!str_detect(sample, \"pos_ctrl\")) %&gt;% \n  filter(day == 0)\n\n# only samples from the experiment\ncounts_f_experiment &lt;- anti_join(counts_f, pos_ctrl_samples) %&gt;% \n  anti_join(., t0_samples) %&gt;% \n  mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\nJoining with `by = join_by(sample, strainID, count, norm_count, replicate, day,\nmeasure_env, evolution_env, rRNA16S_cn, transfer, f, measure_env_short,\nhome_env_short)`\nJoining with `by = join_by(sample, strainID, count, norm_count, replicate, day,\nmeasure_env, evolution_env, rRNA16S_cn, transfer, f, measure_env_short,\nhome_env_short)`\n\n\n\n\n\nHere we’ll use the same filtering criteria as in the t-SNE analysis from section 3 of the last analysis.\n\ncounts_f_experiment %&gt;% \n  group_by(strainID) %&gt;% \n  summarize(n_samples = n(),\n            n_gt0 = sum(count &gt; 0),\n            p_gt0 = n_gt0 / n_samples) %&gt;% \n  ungroup() %&gt;% \n  arrange(n_gt0)\n\n\n  \n\n\n\nBriefly, we will use the centered log-ratio transformation for the species abundances. The centered log-ratio can be interpreted as the log-fold change of species i relative to the average microbe in a sample. The formula for the transformation is:\n\\[\n\\text{clr}(\\mathbf x)= \\left(log\n\\frac{x_i}{g(\\mathbf x)} \\right)_{i=1,...,D} \\qquad \\text{with} \\quad\ng(\\mathbf x) = \\left(\\prod_{i=1}^Dx_i\\right)^{1/D} =\n\\exp\\left(\\frac{1}{D}\\sum_{i=1}^D \\log x_i\\right)\\text{,}\n\\]\nWe will use the implementation of centered log-ratio transform in the compositions package\n\nlowstrainsv &lt;- c(\n  \"HAMBI_0097\",\n  \"HAMBI_2792\"\n)\n\nmymat &lt;- counts_f_experiment %&gt;% \n  filter(strainID %nin% lowstrainsv) %&gt;% \n  dplyr::select(sample, strainID, count) %&gt;% \n  mutate(count = count + 1) %&gt;% \n  # important to arrange by sample as this makes some later joins easier\n  arrange(sample) %&gt;% \n  pivot_wider(names_from = \"strainID\", values_from = \"count\") %&gt;% \n  column_to_rownames(var = \"sample\") %&gt;% \n  data.frame()\n\n# calculate clr transform\nset.seed(12353)\nbalclr &lt;- compositions::clr(mymat)",
    "crumbs": [
      "Community composition amplicon",
      "3. Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#libraries-and-global-variables",
    "href": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#libraries-and-global-variables",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "Community composition amplicon",
      "3. Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#required-directories",
    "href": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#required-directories",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"20240318_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"20240318_BTK_illumina_v3\")\nfigs &lt;- here::here(\"figs\", \"20240318_BTK_illumina_v3\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\nfs::dir_create(figs)",
    "crumbs": [
      "Community composition amplicon",
      "3. Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#read-and-format-16s-amplicon-data",
    "href": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#read-and-format-16s-amplicon-data",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "sptable &lt;- read_tsv(here::here(data, \"species_counts_md.tsv\")) %&gt;% \n  mutate(transfer = day/7)\n\ncounts_f &lt;- sptable %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f=norm_count/sum(norm_count)) %&gt;% \n  ungroup() %&gt;% \n  mutate(measure_env_short = case_when(measure_env == \"bact\" ~ \"Meas: B\",\n                                       measure_env == \"bact_pred\" ~ \"Meas: BP\",\n                                       measure_env == \"bact_strep\" ~ \"Meas: BS\",\n                                       measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\")) %&gt;% \n  mutate(home_env_short = case_when(evolution_env == \"anc\" ~ \"Home: Anc\",\n                                    evolution_env == \"bact\" ~ \"Home: B\",\n                                    evolution_env == \"bact_pred\" ~ \"Home: BP\",\n                                    evolution_env == \"bact_strep\" ~ \"Home: BS\",\n                                    evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\")) %&gt;% \n  mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))",
    "crumbs": [
      "Community composition amplicon",
      "3. Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#tidying",
    "href": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#tidying",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "# these are communities of a (supposedly) known composition. Can be used with metacal\npos_ctrl_samples &lt;- counts_f %&gt;% \n  filter(str_detect(sample, \"pos_ctrl\"))\n\n# these are samples taken directly from YSK and represent the composition of the communities used to start the experiment\nt0_samples &lt;- counts_f %&gt;% \n  filter(!str_detect(sample, \"pos_ctrl\")) %&gt;% \n  filter(day == 0)\n\n# only samples from the experiment\ncounts_f_experiment &lt;- anti_join(counts_f, pos_ctrl_samples) %&gt;% \n  anti_join(., t0_samples) %&gt;% \n  mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\nJoining with `by = join_by(sample, strainID, count, norm_count, replicate, day,\nmeasure_env, evolution_env, rRNA16S_cn, transfer, f, measure_env_short,\nhome_env_short)`\nJoining with `by = join_by(sample, strainID, count, norm_count, replicate, day,\nmeasure_env, evolution_env, rRNA16S_cn, transfer, f, measure_env_short,\nhome_env_short)`",
    "crumbs": [
      "Community composition amplicon",
      "3. Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#data-normalization",
    "href": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#data-normalization",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "Here we’ll use the same filtering criteria as in the t-SNE analysis from section 3 of the last analysis.\n\ncounts_f_experiment %&gt;% \n  group_by(strainID) %&gt;% \n  summarize(n_samples = n(),\n            n_gt0 = sum(count &gt; 0),\n            p_gt0 = n_gt0 / n_samples) %&gt;% \n  ungroup() %&gt;% \n  arrange(n_gt0)\n\n\n  \n\n\n\nBriefly, we will use the centered log-ratio transformation for the species abundances. The centered log-ratio can be interpreted as the log-fold change of species i relative to the average microbe in a sample. The formula for the transformation is:\n\\[\n\\text{clr}(\\mathbf x)= \\left(log\n\\frac{x_i}{g(\\mathbf x)} \\right)_{i=1,...,D} \\qquad \\text{with} \\quad\ng(\\mathbf x) = \\left(\\prod_{i=1}^Dx_i\\right)^{1/D} =\n\\exp\\left(\\frac{1}{D}\\sum_{i=1}^D \\log x_i\\right)\\text{,}\n\\]\nWe will use the implementation of centered log-ratio transform in the compositions package\n\nlowstrainsv &lt;- c(\n  \"HAMBI_0097\",\n  \"HAMBI_2792\"\n)\n\nmymat &lt;- counts_f_experiment %&gt;% \n  filter(strainID %nin% lowstrainsv) %&gt;% \n  dplyr::select(sample, strainID, count) %&gt;% \n  mutate(count = count + 1) %&gt;% \n  # important to arrange by sample as this makes some later joins easier\n  arrange(sample) %&gt;% \n  pivot_wider(names_from = \"strainID\", values_from = \"count\") %&gt;% \n  column_to_rownames(var = \"sample\") %&gt;% \n  data.frame()\n\n# calculate clr transform\nset.seed(12353)\nbalclr &lt;- compositions::clr(mymat)",
    "crumbs": [
      "Community composition amplicon",
      "3. Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#classes-ancesteral-b-bp-bs-and-bps",
    "href": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#classes-ancesteral-b-bp-bs-and-bps",
    "title": "Community composition analysis using machine learning",
    "section": "2.1 5 classes (ancesteral, B, BP, BS, and BPS)",
    "text": "2.1 5 classes (ancesteral, B, BP, BS, and BPS)\nFirst were going to try and predict all 5 different home evolution environments\n\n2.1.1 Spliting\nSplit the data using the default 3:1 ratio of training-to-test. Here we also set the strata argument. This argument makes sure that both sides of the split have roughly the same distribution for each value of strata. If a numeric variable is passed to strata then it is binned and distributions are matched within bins. In this case there will be roughly the same distribution of the 5 classes within each side of the test/train split.\n\nbalclr_5c &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_ae, -home_env_sns, -home_env_pnp) %&gt;% \n  drop_na\n\ntable(balclr_5c$home_env_5c)\n\n\n            anc            bact       bact_pred bact_pred_strep      bact_strep \n             72              70              71              70              72 \n\n\nThe data is balanced\n\nset.seed(1501)\nbalclr_5c_split &lt;- initial_split(balclr_5c, strata = home_env_5c)\nbalclr_5c_train &lt;- training(balclr_5c_split)\nbalclr_5c_test  &lt;- testing(balclr_5c_split)\n\nResample the training set using five repeats of 10-fold cross-validation\n\nset.seed(1502)\n\nbalclr_5c_folds &lt;- \n   vfold_cv(balclr_5c_train, strata = home_env_5c)\n\n\n\n2.1.2 Recipe\nFirst we need to preprocess the data so that it is in optimal format for Ml. Some useful steps include:\n\nstep_novel(): converts all nominal variables to factors and takes care of other issues related to categorical variables.\nstep_normalize(): normalizes (center and scales) the numeric variables to have a standard deviation of one and a mean of zero. (i.e., z-standardization).\nstep_dummy(): converts our factor column ocean_proximity into numeric binary (0 and 1) variables.\n\nNote that this step may cause problems if your categorical variable has too many levels - especially if some of the levels are very infrequent. In this case you should either drop the variable or pool infrequently occurring values into an “other” category with step_other. This steps has to be performed before step_dummy.\n\nstep_zv(): removes any numeric variables that have zero variance.\nstep_corr(): will remove predictor variables that have large correlations with other predictor variables.\n\nEdit: data is already in centered log-ratio transform and further normalization doesn’t really help.\n\nbalclr_5c_rec &lt;- recipe(home_env_5c ~ ., data = balclr_5c_train) %&gt;% \n  #step_novel(all_nominal(), -all_outcomes()) %&gt;%\n  #step_normalize(all_numeric(), -all_outcomes()) %&gt;% \n  step_dummy(all_nominal(), -all_outcomes()) #%&gt;%\n  #step_zv(all_numeric(), -all_outcomes()) %&gt;% \n  #step_corr(all_predictors(), threshold = 0.7, method = \"spearman\")\n\nYou can take a peek at the what the preprocessing recipe does using prep and juice\n\nbalclr_5c_rec %&gt;% \n  # perform the recipe on training data\n  prep() %&gt;% \n  # extract only the preprocessed dataframe \n  juice()\n\n\n  \n\n\n\n\n\n2.1.3 Model specifications\nThe process of specifying models is:\n\nPick a model type\nSet the engine\nSet the mode: regression or classification\n\n\nlibrary(rules)\nlibrary(baguette)\n\nsvm_r_spec &lt;- \n   svm_rbf(cost = tune(), rbf_sigma = tune()) %&gt;% \n   set_engine(\"kernlab\") %&gt;% \n   set_mode(\"classification\")\n\nsvm_p_spec &lt;- \n   svm_poly(cost = tune(), degree = tune()) %&gt;% \n   set_engine(\"kernlab\") %&gt;% \n   set_mode(\"classification\")\n\ncart_spec &lt;- \n   decision_tree(cost_complexity = tune(), min_n = tune()) %&gt;% \n   set_engine(\"rpart\") %&gt;% \n   set_mode(\"classification\")\n\nbag_cart_spec &lt;- \n   bag_tree() %&gt;% \n   set_engine(\"rpart\", times = 50L) %&gt;% \n   set_mode(\"classification\")\n\nrf_spec &lt;- \n   rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %&gt;% \n   set_engine(\"ranger\", importance = \"impurity\") %&gt;% \n   set_mode(\"classification\")\n\nxgb_spec &lt;- \n   boost_tree(tree_depth = tune(), learn_rate = tune(), loss_reduction = tune(), \n              min_n = tune(), sample_size = tune(), trees = tune()) %&gt;% \n   set_engine(\"xgboost\") %&gt;% \n   set_mode(\"classification\")\n\nnnet_spec &lt;- \n   mlp(hidden_units = tune(), penalty = tune(), epochs = tune()) %&gt;% \n   set_engine(\"nnet\", MaxNWts = 2600) %&gt;% \n   set_mode(\"classification\")\n\nfda_spec &lt;- \n   discrim_flexible(prod_degree = tune()) %&gt;%  #&lt;- use GCV to choose terms\n   set_engine(\"earth\") %&gt;% \n   set_mode(\"classification\")\n\nbart_spec &lt;- \n  bart(trees = 1000, prior_terminal_node_coef = tune(), prior_terminal_node_expo = tune()) %&gt;% \n  set_engine(\"dbarts\") %&gt;% \n  set_mode(\"classification\")\n\n\n\n2.1.4 Create workflow set\nNow we need to specify the workflows that will be followed for the different model types\n\nbalclr_5c_wf &lt;- \n   workflow_set(\n      preproc = list(balclr_5c = balclr_5c_rec), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        #bart = bart_spec, \n        #fda = fda_spec,\n        RF = rf_spec)\n   )\n\nbalclr_5c_wf\n\n\n  \n\n\n\n\n\n2.1.5 Tune\nThis takes a long time to run\n\nbalclr_5c_grid_results &lt;-\n   workflow_map(balclr_5c_wf, \n      seed = 1578,\n      resamples = balclr_5c_folds,\n      grid = 15,\n      control = control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nwrite_rds(balclr_5c_grid_results, here::here(data, \"model_tune_5_class.rds\"))\n\n\nbalclr_5c_grid_results &lt;- read_rds(here::here(data, \"model_tune_5_class.rds\"))\n\n\n\n2.1.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. Gradient boosting and random forest have basically the same performance with boosting doing slighly better\n\nmymetric &lt;- \"roc_auc\"\n\nautoplot(\n  balclr_5c_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n   geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n2.1.6.1 Peformance metrics for best model\n\ngetmymetrics &lt;- function(gridresults, myworkflow, mymetric, mysplit){\n  best_results &lt;- gridresults %&gt;% \n   extract_workflow_set_result(myworkflow) %&gt;% \n   select_best(metric = mymetric)\n  \n   gridresults %&gt;% \n     extract_workflow(myworkflow) %&gt;% \n     finalize_workflow(best_results) %&gt;% \n     last_fit(split = mysplit,\n             metrics = metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec))\n}\n\n\nset.seed(23784)\nbalclr_5c_rf_test_results &lt;- getmymetrics(balclr_5c_grid_results, \"balclr_5c_RF\", \"roc_auc\", balclr_5c_split)\nbalclr_5c_boosting_test_results &lt;- getmymetrics(balclr_5c_grid_results, \"balclr_5c_boosting\", \"roc_auc\", balclr_5c_split)\n\n\ncollect_metrics(balclr_5c_rf_test_results) %&gt;% \n  dplyr::select(metric = .metric, random_forest = .estimate, estimate_type = .estimator) %&gt;% \n  left_join(collect_metrics(balclr_5c_boosting_test_results) %&gt;% \n              dplyr::select(metric = .metric, boosting = .estimate, estimate_type = .estimator)) %&gt;% \n  relocate(estimate_type, metric)\n\nJoining with `by = join_by(metric, estimate_type)`\n\n\n\n  \n\n\n\n\n\n2.1.6.2 ROC-curve\nThis is a useful resource for understanding ROC curves and PR curves.\nROC curves here indicate that there is decent performance for the evolution environments of the ancestral clones, bacteria only, and bacteria plus ciliates. Performance is worse for treatments with streptomycin (see the PR curves). This is consistent with the strong overlap in community composition that we saw between strep and strep plus ciliate treatments. If the community response of the treatments is similiar it will be difficult to identify discriminating patterns in the data.\n\nbalclr_5c_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  roc_curve(home_env_5c, .pred_anc:.pred_bact_strep) %&gt;% \n  autoplot() +\n  labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\nbalclr_5c_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  pr_curve(home_env_5c, .pred_anc:.pred_bact_strep) %&gt;% \n  autoplot() +\n  labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n2.1.6.3 Confusion matrix\nThe confusion matrix shows that for ciliates evolution environment (bact_pred), the model is only getting the evolution environment correct about half the time (10 correct/8 incorrect) which is basically the same as guessing. The best performing home environments are the ancestral and the combined predators and streptomycin treatments.\n\nbalclr_5c_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  conf_mat(home_env_5c, .pred_class) %&gt;%\n  autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n2.1.6.4 Probability distributions for the 5 classes\nThis plot gives some insight as to which classes the model has trouble distinguishing.\n\nbalclr_5c_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  pivot_longer(c(.pred_anc, .pred_bact,  \n            .pred_bact_pred, .pred_bact_pred_strep, .pred_bact_strep)) %&gt;% \n  ggplot() +\n  geom_density(aes(x = value, \n                   fill = home_env_5c), \n               alpha = 0.5) +\n  labs(x = \"Prediction Probability\", y = \"Density\") +\n  facet_wrap(~name)",
    "crumbs": [
      "Community composition amplicon",
      "3. Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#classes-ancestral-clones-vs-coevolved-history",
    "href": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#classes-ancestral-clones-vs-coevolved-history",
    "title": "Community composition analysis using machine learning",
    "section": "2.2 2 classes (ancestral clones vs coevolved history)",
    "text": "2.2 2 classes (ancestral clones vs coevolved history)\nBased on the above analysis and from inspecting the community composition data it appears that ancestral/clonal community has a distinct response to the measurement conditions compared with all the other evolutionary histories. Here instead of trying to predict 5 different home environment classes we just want to predict whether the bacteria had a coevolutionary history from the YSK experiment or not. However, this introduces an additional challenge because now the classes we will be trying to predict are imbalanced.\n\n2.2.1 Spliting\nDone the same as in Section 2.1.1 from the 5-class classification.\n\nbalclr_ae &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_5c, -home_env_sns, -home_env_pnp) %&gt;% \n  mutate(replicate = factor(replicate),\n         transfer = factor(transfer),\n         measure_env = factor(measure_env),\n         home_env_ae = factor(home_env_ae))\n\ntable(balclr_ae$home_env_ae)\n\n\nanc evo \n 72 283 \n\n\nSo in this case the classes from the data are clearly not balanced… We will try and address that in the recipe step using the themis package.\n\nset.seed(1467)\n\nbalclr_ae_split &lt;- initial_split(balclr_ae, strata = home_env_ae)\nbalclr_ae_train &lt;- training(balclr_ae_split)\nbalclr_ae_test  &lt;- testing(balclr_ae_split)\n\n\nset.seed(1468)\n\nbalclr_ae_folds &lt;- \n   vfold_cv(balclr_ae_train, strata = home_env_ae)\n\n\n\n2.2.2 Recipe\nDone the same as in Section 2.1.2 from the 5-class classification.\n\nbalclr_ae_rec &lt;- recipe(home_env_ae ~ ., data = balclr_ae_train) %&gt;% \n  step_dummy(all_nominal(), -all_outcomes())\n\nbalclr_ae_rec_rose &lt;- recipe(home_env_ae ~ ., data = balclr_ae_train) %&gt;% \n  step_rose(home_env_ae) %&gt;% \n  step_dummy(all_nominal(), -all_outcomes())\n\n\n\n2.2.3 Model specifications\nUsing the same model specifications as in Section 2.1.3 from the 5-class classification.\n\n\n2.2.4 Create workflow set\nSame process as in Section 2.1.4 from the 5-class classification.\n\nbalclr_ae_wf &lt;- \n   workflow_set(\n      preproc = list(balclr_ae = balclr_ae_rec, \n                     balclr_ae_rose = balclr_ae_rec_rose), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        bart = bart_spec, \n        fda = fda_spec,\n        RF = rf_spec\n      )\n   )\n\n\n\n2.2.5 Tune\nSame as in Section 2.1.5 from the 5-class classification. Warning this takes some time…\n\nbalclr_ae_grid_results &lt;-\n   workflow_map(balclr_ae_wf, \n      seed = 1469,\n      resamples = balclr_ae_folds,\n      grid = 15,\n      control = control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nwrite_rds(balclr_ae_grid_results, here::here(data, \"model_tune_ae.rds\"))\n\n\nbalclr_ae_grid_results &lt;- read_rds(here::here(data, \"model_tune_ae.rds\"))\n\n\n\n2.2.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. We’ll use the J index and the ROC auc as suggested in the tidymodels unbalanced class tutorial.\n\nThe area under the ROC curve is an overall assessment of performance across all cutoffs. Values near one indicate very good results while values near 0.5 would imply that the model is very poor (i.e. no better than guessing)\nThe J index (a.k.a. Youden’s J statistic) is sensitivity + specificity - 1. Values near one are once again best.\n\nIf a model is poorly calibrated, the ROC curve value might not show diminished performance. However, the J index would be lower for models with pathological distributions for the class probabilities. The yardstick package will be used to compute these metrics.\nJ index\n\n# which metric to visualize\nmymetric &lt;- \"j_index\"\n\nautoplot(\n  balclr_ae_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n   geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n# which metric to visualize\nmymetric &lt;- \"roc_auc\"\n\nautoplot(\n  balclr_ae_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n   geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nIt looks like ROSE preprocessing step helped with the J-index. Class imbalance sampling methods tend to greatly improve metrics based on the hard class predictions (i.e., the categorical predictions) because the default cutoff tends to be a better balance of sensitivity and specificity.\n\n2.2.6.1 Peformance metrics for best model\n\nset.seed(4671)\nbalclr_ae_boosting_test_results &lt;- getmymetrics(balclr_ae_grid_results, \"balclr_ae_rose_boosting\", \"j_index\", balclr_ae_split)\nbalclr_ae_rf_test_results &lt;- getmymetrics(balclr_ae_grid_results, \"balclr_ae_rose_RF\", \"j_index\", balclr_ae_split)\n\n\ncollect_metrics(balclr_ae_rf_test_results) %&gt;% \n  dplyr::select(metric = .metric, random_forest = .estimate, estimate_type = .estimator) %&gt;% \n  left_join(collect_metrics(balclr_ae_boosting_test_results) %&gt;% \n              dplyr::select(metric = .metric, boosting = .estimate, estimate_type = .estimator)) %&gt;% \n  relocate(estimate_type, metric)\n\nJoining with `by = join_by(metric, estimate_type)`\n\n\n\n  \n\n\n\nAgain gradient boosting seems to be doing the best here.\n\n\n2.2.6.2 ROC-curve\nWith unbalaced classes like we have here, it is best to look at both the ROC curve and the PR (precision-recall) curve. See here\n\nbalclr_ae_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  roc_curve(home_env_ae, .pred_anc) %&gt;% \n  autoplot() +\n  labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\nbalclr_ae_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  pr_curve(home_env_ae, .pred_anc) %&gt;% \n  autoplot() +\n  labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n2.2.6.3 Confusion matrix\nThe model is doing pretty well finding the communiuties with a coevolutionary history, but it is doing less well at finding the ancestral communities. It is getting the ancestral correct 2/3 of the time.\n\nbalclr_ae_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  conf_mat(home_env_ae, .pred_class) %&gt;%\n  autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n2.2.6.4 Probability distributions for the 2 classes\n\nbalclr_ae_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  ggplot() +\n  geom_density(aes(x = .pred_evo, \n                   fill = home_env_ae), \n               alpha = 0.5) +\n  labs(x = \"Prediction Probability\", y = \"Density\")",
    "crumbs": [
      "Community composition amplicon",
      "3. Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#classes-streptomycin-history-vs-no-streptomycin-history",
    "href": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#classes-streptomycin-history-vs-no-streptomycin-history",
    "title": "Community composition analysis using machine learning",
    "section": "2.3 2 classes (streptomycin history vs no streptomycin history)",
    "text": "2.3 2 classes (streptomycin history vs no streptomycin history)\nNow we will try and predict whether the evolutionary history of the communities included exposure to streptomycin\n\n2.3.1 Spliting\nDone the same as in Section 2.1.1 from the 5-class classification.\n\nbalclr_sns &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_5c, -home_env_ae, -home_env_pnp) %&gt;% \n  mutate(replicate = factor(replicate),\n         transfer = factor(transfer),\n         measure_env = factor(measure_env),\n         home_env_sns = factor(home_env_sns)) %&gt;% \n  # we omit the ancestral samples to keep it more balanced\n  drop_na()\n\ntable(balclr_sns$home_env_sns)\n\n\nnostrep   strep \n    141     142 \n\n\n\nset.seed(1567)\n\nbalclr_sns_split &lt;- initial_split(balclr_sns, strata = home_env_sns)\nbalclr_sns_train &lt;- training(balclr_sns_split)\nbalclr_sns_test  &lt;- testing(balclr_sns_split)\n\n\nset.seed(1568)\n\nbalclr_sns_folds &lt;- \n   vfold_cv(balclr_sns_train, strata = home_env_sns)\n\n\n\n2.3.2 Recipe\nDone the same as in Section 2.1.2 from the 5-class classification.\n\nbalclr_sns_rec &lt;- recipe(home_env_sns ~ ., data = balclr_sns_train) %&gt;% \n  step_dummy(all_nominal(), -all_outcomes())\n\n\n\n2.3.3 Model specifications\nUsing the same model specifications as in Section 2.1.3 from the 5-class classification.\n\n\n2.3.4 Create workflow set\nSame process as in Section 2.1.4 from the 5-class classification.\n\nlibrary(discrim)\n\nbalclr_sns_wf &lt;- \n   workflow_set(\n      preproc = list(balclr_sns = balclr_sns_rec), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        #bart = bart_spec, \n        #fda = fda_spec,\n        RF = rf_spec\n      )\n   )\n\n\n\n2.3.5 Tune\nSame as in Section 2.1.5 from the 5-class classification. Warning this takes some time…\n\nbalclr_sns_grid_results &lt;-\n   workflow_map(balclr_sns_wf, \n      seed = 1569,\n      resamples = balclr_sns_folds,\n      grid = 15,\n      control = control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nwrite_rds(balclr_sns_grid_results, here::here(data, \"model_tune_sns.rds\"))\n\n\nbalclr_sns_grid_results &lt;- read_rds(here::here(data, \"model_tune_sns.rds\"))\n\n\n\n2.3.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. It appears that based on all metrics the random forest performs the best.\n\nmymetric &lt;- \"roc_auc\"\n\nautoplot(\n  balclr_sns_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n   geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n2.3.6.1 Peformance metrics for best model\nAll performance metrics are almost identical (making same overall predictions) with RF just having higher ROC auc\n\nset.seed(4671)\nbalclr_sns_rf_test_results &lt;- getmymetrics(balclr_sns_grid_results, \"balclr_sns_RF\", \"roc_auc\", balclr_sns_split)\nbalclr_sns_boosting_test_results &lt;- getmymetrics(balclr_sns_grid_results, \"balclr_sns_boosting\", \"roc_auc\", balclr_sns_split)\n\n\ncollect_metrics(balclr_sns_rf_test_results) %&gt;% \n  dplyr::select(metric = .metric, random_forest = .estimate, estimate_type = .estimator) %&gt;% \n  left_join(collect_metrics(balclr_sns_boosting_test_results) %&gt;% \n              dplyr::select(metric = .metric, boosting = .estimate, estimate_type = .estimator)) %&gt;% \n  relocate(estimate_type, metric)\n\nJoining with `by = join_by(metric, estimate_type)`\n\n\n\n  \n\n\n\n\n\n2.3.6.2 ROC and PR curves\nROC curves indicate that there is good performance for the evolution environments that either contain streptomycin or do not.\n\nbalclr_sns_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  roc_curve(home_env_sns, .pred_nostrep) %&gt;% \n  autoplot() +\n  labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\nbalclr_sns_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  pr_curve(home_env_sns, .pred_nostrep) %&gt;% \n  autoplot() +\n  labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n2.3.6.3 Confusion matrix\n\nbalclr_sns_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  conf_mat(home_env_sns, .pred_class) %&gt;%\n  autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n2.3.6.4 Probability distributions for the 2 classes\n\nbalclr_sns_boosting_test_results %&gt;% \n  collect_predictions() %&gt;%\n  ggplot() +\n  geom_density(aes(x = .pred_strep, \n                   fill = home_env_sns), \n               alpha = 0.5) +\n  labs(x = \"Prediction Probability\", y = \"Density\")",
    "crumbs": [
      "Community composition amplicon",
      "3. Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#classes-predation-history-vs-no-predation-history",
    "href": "R/20240318_BTK_illumina_v3/03_machine_learn_home_env.html#classes-predation-history-vs-no-predation-history",
    "title": "Community composition analysis using machine learning",
    "section": "2.4 2 classes (predation history vs no predation history)",
    "text": "2.4 2 classes (predation history vs no predation history)\n\n2.4.1 Spliting\nDone the same as in Section 2.1.1 from the 5-class classification.\n\nbalclr_pnp &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_5c, -home_env_ae, -home_env_sns) %&gt;% \n  mutate(replicate = factor(replicate),\n         transfer = factor(transfer),\n         measure_env = factor(measure_env),\n         home_env_pnp = factor(home_env_pnp)) %&gt;% \n  # we omit the ancestral samples to keep it more balanced\n  drop_na()\n\ntable(balclr_pnp$home_env_pnp)\n\n\nnopred   pred \n   142    141 \n\n\n\nset.seed(1567)\n\nbalclr_pnp_split &lt;- initial_split(balclr_pnp, strata = home_env_pnp)\nbalclr_pnp_train &lt;- training(balclr_pnp_split)\nbalclr_pnp_test  &lt;- testing(balclr_pnp_split)\n\n\nset.seed(1568)\n\nbalclr_pnp_folds &lt;- \n   vfold_cv(balclr_pnp_train, strata = home_env_pnp)\n\n\n\n2.4.2 Recipe\nDone the same as in Section 2.1.2 from the 5-class classification.\n\nbalclr_pnp_rec &lt;- recipe(home_env_pnp ~ ., data = balclr_pnp_train) %&gt;% \n  step_dummy(all_nominal(), -all_outcomes())\n\n\n\n2.4.3 Model specifications\nUsing the same model specifications as in Section 2.1.3 from the 5-class classification.\n\n\n2.4.4 Create workflow set\nSame process as in Section 2.1.4 from the 5-class classification.\n\nbalclr_pnp_wf &lt;- \n   workflow_set(\n      preproc = list(balclr_pnp = balclr_pnp_rec), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        bart = bart_spec, \n        fda = fda_spec,\n        RF = rf_spec\n      )\n   )\n\n\n\n2.4.5 Tune\nSame as in Section 2.1.5 from the 5-class classification. Warning this takes some time…\n\nbalclr_pnp_grid_results &lt;-\n   workflow_map(balclr_pnp_wf, \n      seed = 1569,\n      resamples = balclr_pnp_folds,\n      grid = 25,\n      control = control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nwrite_rds(balclr_pnp_grid_results, here::here(data, \"model_tune_pnp.rds\"))\n\n\nbalclr_pnp_grid_results &lt;- read_rds(here::here(data, \"model_tune_pnp.rds\"))\n\n\n\n2.4.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. It appears that based on all metrics the random forest performs the best.\n\nmymetric &lt;- \"roc_auc\"\n\nautoplot(\n  balclr_pnp_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n   geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n2.4.6.1 Peformance metrics for best model\nClearly here random forest is doing better\n\nset.seed(87605)\nbalclr_pnp_boosting_test_results &lt;- getmymetrics(balclr_pnp_grid_results, \"balclr_pnp_boosting\", \"j_index\", balclr_pnp_split)\nbalclr_pnp_rf_test_results &lt;- getmymetrics(balclr_pnp_grid_results, \"balclr_pnp_RF\", \"j_index\", balclr_pnp_split)\n\n\ncollect_metrics(balclr_pnp_rf_test_results) %&gt;% \n  dplyr::select(metric = .metric, random_forest = .estimate, estimate_type = .estimator) %&gt;% \n  left_join(collect_metrics(balclr_pnp_boosting_test_results) %&gt;% \n              dplyr::select(metric = .metric, boosting = .estimate, estimate_type = .estimator)) %&gt;% \n  relocate(estimate_type, metric)\n\nJoining with `by = join_by(metric, estimate_type)`\n\n\n\n  \n\n\n\n\n\n2.4.6.2 ROC-curve\nROC curves indicate that there is good performance for the evolution environments that either contain streptomycin or do not.\n\nbalclr_pnp_rf_test_results %&gt;% \n  collect_predictions() %&gt;%\n  roc_curve(home_env_pnp, .pred_nopred) %&gt;% \n  autoplot() +\n  labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\nbalclr_pnp_rf_test_results %&gt;% \n  collect_predictions() %&gt;%\n  pr_curve(home_env_pnp, .pred_nopred) %&gt;% \n  autoplot() +\n  labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n2.4.6.3 Confusion matrix\n\nbalclr_pnp_rf_test_results %&gt;% \n  collect_predictions() %&gt;%\n  conf_mat(home_env_pnp, .pred_class) %&gt;%\n  autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n2.4.6.4 Probability distributions for the 2 classes\n\nbalclr_pnp_rf_test_results %&gt;% \n  collect_predictions() %&gt;%\n  ggplot() +\n  geom_density(aes(x = .pred_pred, \n                   fill = home_env_pnp), \n               alpha = 0.5) +\n  labs(x = \"Prediction Probability\", y = \"Density\")",
    "crumbs": [
      "Community composition amplicon",
      "3. Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html",
    "title": "Formatting growth curves",
    "section": "",
    "text": "library(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)"
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#subtract-baseline",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#subtract-baseline",
    "title": "Formatting growth curves",
    "section": "3.1 Subtract baseline",
    "text": "3.1 Subtract baseline\nMany of the curves start off at quite a high baseline - we will need to sutract out this value\n\nbaseline &lt;- gcurves_slurped_fmt %&gt;% \n  # first 10 minutes\n  filter(seconds &lt; 1000) %&gt;% \n  summarize(baseline = median(OD600), .by = c(plate, well))\n\ngcurves_slurped_fmt_bl &lt;- left_join(gcurves_slurped_fmt, baseline) %&gt;% \n  mutate(OD600_b = OD600 - baseline) %&gt;% \n  mutate(OD600_b = if_else(OD600_b &lt; 0, 0, OD600_b))\n\nJoining with `by = join_by(plate, well)`"
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#smoothing",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#smoothing",
    "title": "Formatting growth curves",
    "section": "3.2 Smoothing",
    "text": "3.2 Smoothing\nHere we will smooth out some of the higher frequency noise in the curves. A span of 0.15 seems to work pretty well here.\n\ngcurves_slurped_fmt_bl_sm &lt;- gcurves_slurped_fmt_bl %&gt;% \n  group_by(plate, well) %&gt;% \n  mutate(OD600_smooth = gcplyr::smooth_data(x = seconds, y = OD600_b, subset_by = well, sm_method = \"loess\", span = 0.15)) %&gt;% \n  ungroup()"
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#plot-inspect",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#plot-inspect",
    "title": "Formatting growth curves",
    "section": "6.3 Plot inspect",
    "text": "6.3 Plot inspect\n\nplotplate &lt;- function(df, plate){\n  df %&gt;% \n    filter(plate == {{ plate }}) %&gt;% \n    ggplot(aes(x = seconds)) +\n    geom_line(aes(y=OD600_b), color = \"blue\") + \n    geom_line(aes(y=OD600_smooth), color = \"red\") + \n    scale_x_continuous(\n      breaks = seq(0, 48 * 60 * 60, 12 * 60 * 60),\n      labels = seq(0, 48, 12)) +\n    facet_wrap(~ well, nrow = 8)\n}\n\n\n6.3.1 Bact conditions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Growth curves for the bacteria only conditions on Plate 1. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Growth curves for the bacteria only conditions on Plate 2. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Growth curves for the bacteria only conditions on Plate 3. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Growth curves for the bacteria only conditions on Plate 4. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Growth curves for the bacteria only conditions on Plate 5. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Growth curves for the bacteria only conditions on Plate 6. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Growth curves for the bacteria only conditions on Plate 7. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Growth curves for the bacteria only conditions on Plate 8. Blue line is raw data, red line is smoothed."
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#load-required-packages",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#load-required-packages",
    "title": "Formatting growth curves",
    "section": "",
    "text": "library(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))"
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#global-variables",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#global-variables",
    "title": "Formatting growth curves",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)"
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#metadata",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#metadata",
    "title": "Formatting growth curves",
    "section": "2.1 Metadata",
    "text": "2.1 Metadata\n\nmddf &lt;- read_tsv(\n  here::here(data_raw, \"metadata.tsv\"),\n  col_types = list(\n    plate = col_character(),\n    well = col_character(),\n    clone_id = col_double(),\n    experiment_treatment = col_character(),\n    LTCSE_treatment = col_character(),\n    replicate = col_character(),\n    lagtime = col_time(format = \"%T\"),\n    max_growth_death_rate = col_double(),\n    time_to_stationary = col_time(format = \"%T\")\n  )\n) %&gt;% mutate(Group = 1,\n         Flag = 0,\n         Subset = 1)\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)"
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#raw-growth-curves",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#raw-growth-curves",
    "title": "Formatting growth curves",
    "section": "2.2 Raw growth curves",
    "text": "2.2 Raw growth curves\n\ngcurves_slurped &lt;- readr::read_delim(samppaths, \n                          comment = \"#\", \n                          delim = \";\",\n                          escape_double = FALSE,\n                          trim_ws = TRUE, \n                          id = \"file_name\") \n\nRows: 9248 Columns: 98\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \";\"\ndbl  (96): A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, B1, B2, B3, B4...\ntime  (1): Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ngcurves_slurped_fmt &lt;- gcurves_slurped %&gt;% \n  mutate(plate = str_extract(file_name, \"A\\\\d_\\\\d\")) %&gt;% \n  dplyr::select(-file_name) %&gt;% \n  relocate(plate) %&gt;% \n  mutate(seconds=round(lubridate::period_to_seconds(lubridate::hms(Time)))) %&gt;%\n  dplyr::select(-Time) %&gt;% \n  pivot_longer(c(-plate, -seconds), names_to = \"well\", values_to = \"OD600\")"
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#bact-conditions",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#bact-conditions",
    "title": "Formatting growth curves",
    "section": "4.1 Bact conditions",
    "text": "4.1 Bact conditions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Growth curves for the bacteria only conditions on Plate 1. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Growth curves for the bacteria only conditions on Plate 2. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Growth curves for the bacteria only conditions on Plate 3. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Growth curves for the bacteria only conditions on Plate 4. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Growth curves for bacteria only conditions on Plate 5. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Growth curves for bacteria only conditions on Plate 6. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Growth curves for bacteria only conditions on Plate 7. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Growth curves for bacteria only conditions on Plate 8. Blue line is raw data, red line is smoothed."
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#predator-conditions",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#predator-conditions",
    "title": "Formatting growth curves",
    "section": "4.2 Predator conditions",
    "text": "4.2 Predator conditions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Growth curves for the ciliate conditions on Plate 1. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Growth curves for the ciliate conditions on Plate 2. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Growth curves for the ciliate conditions on Plate 3. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Growth curves for the ciliate conditions on Plate 4. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Growth curves for ciliate conditions on Plate 5. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Growth curves for ciliate conditions on Plate 6. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Growth curves for ciliate conditions on Plate 7. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Growth curves for ciliate conditions on Plate 8. Blue line is raw data, red line is smoothed."
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#streptomycin-conditions",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#streptomycin-conditions",
    "title": "Formatting growth curves",
    "section": "4.3 Streptomycin conditions",
    "text": "4.3 Streptomycin conditions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17: Growth curves for the Streptomycin conditions on Plate 1. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: Growth curves for the Streptomycin conditions on Plate 2. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Growth curves for the Streptomycin conditions on Plate 3. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 20: Growth curves for the Streptomycin conditions on Plate 4. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 21: Growth curves for Streptomycin conditions on Plate 5. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 22: Growth curves for Streptomycin conditions on Plate 6. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 23: Growth curves for Streptomycin conditions on Plate 7. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 24: Growth curves for Streptomycin conditions on Plate 8. Blue line is raw data, red line is smoothed."
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_format_growthcurves.html#predator-streptomycin-conditions",
    "href": "R/20230112_clone_phenotyping/01_format_growthcurves.html#predator-streptomycin-conditions",
    "title": "Formatting growth curves",
    "section": "4.4 Predator + Streptomycin conditions",
    "text": "4.4 Predator + Streptomycin conditions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 25: Growth curves for the Ciliate + Streptomycin conditions on Plate 1. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 26: Growth curves for the Ciliate + Streptomycin conditions on Plate 2. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 27: Growth curves for the Ciliate + Streptomycin conditions on Plate 3. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 28: Growth curves for the Ciliate + Streptomycin conditions on Plate 4. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 29: Growth curves for Ciliate + Streptomycin conditions on Plate 5. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30: Growth curves for Ciliate + Streptomycin conditions on Plate 6. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 31: Growth curves for Ciliate + Streptomycin conditions on Plate 7. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 32: Growth curves for Ciliate + Streptomycin conditions on Plate 8. Blue line is raw data, red line is smoothed."
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html",
    "title": "Analysis of growth curves",
    "section": "",
    "text": "library(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nlibrary(gcplyr)\n\n## \n## gcplyr (Version 1.9.0, Build Date: 2024-03-11)\n## See http://github.com/mikeblazanin/gcplyr for additional documentation\n## Please cite software as:\n##   Blazanin, Michael. 2023. gcplyr: an R package for microbial growth\n##   curve data analysis. bioRxiv doi: 10.1101/2023.04.30.538883\n## \n\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n\n\n\n\nmddf &lt;- read_tsv(\n  here::here(data_raw, \"metadata.tsv\"),\n  col_types = list(\n    plate = col_character(),\n    well = col_character(),\n    clone_id = col_double(),\n    experiment_treatment = col_character(),\n    LTCSE_treatment = col_character(),\n    replicate = col_character(),\n    lagtime = col_time(format = \"%T\"),\n    max_growth_death_rate = col_double(),\n    time_to_stationary = col_time(format = \"%T\")\n  )\n) %&gt;% mutate(Group = 1, Flag = 0, Subset = 1)\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)\n\n\n\n\n\n\ngcurves_slurped_fmt_bl_sm &lt;- read_rds(here::here(data, \"growth_curves_smoothed.rds\"))",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#load-required-packages",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#load-required-packages",
    "title": "Analysis of growth curves",
    "section": "",
    "text": "library(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nlibrary(gcplyr)\n\n## \n## gcplyr (Version 1.9.0, Build Date: 2024-03-11)\n## See http://github.com/mikeblazanin/gcplyr for additional documentation\n## Please cite software as:\n##   Blazanin, Michael. 2023. gcplyr: an R package for microbial growth\n##   curve data analysis. bioRxiv doi: 10.1101/2023.04.30.538883\n## \n\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#global-variables",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#global-variables",
    "title": "Analysis of growth curves",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#metadata",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#metadata",
    "title": "Analysis of growth curves",
    "section": "",
    "text": "mddf &lt;- read_tsv(\n  here::here(data_raw, \"metadata.tsv\"),\n  col_types = list(\n    plate = col_character(),\n    well = col_character(),\n    clone_id = col_double(),\n    experiment_treatment = col_character(),\n    LTCSE_treatment = col_character(),\n    replicate = col_character(),\n    lagtime = col_time(format = \"%T\"),\n    max_growth_death_rate = col_double(),\n    time_to_stationary = col_time(format = \"%T\")\n  )\n) %&gt;% mutate(Group = 1, Flag = 0, Subset = 1)\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#previously-smoothed-growth-curves",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#previously-smoothed-growth-curves",
    "title": "Analysis of growth curves",
    "section": "",
    "text": "gcurves_slurped_fmt_bl_sm &lt;- read_rds(here::here(data, \"growth_curves_smoothed.rds\"))",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#derivatives",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#derivatives",
    "title": "Analysis of growth curves",
    "section": "2.1 Derivatives",
    "text": "2.1 Derivatives\nHere we will calculate for each growth curve: - the plain derivative - the slope of the original density data - the per-capita derivative - the growth rate of the cells\n\n#This takes a long time to run\ngcurves_slurped_fmt_bl_sm_dv &lt;- gcurves_slurped_fmt_bl_sm %&gt;% \n  group_by(plate, well) %&gt;% \n  mutate(deriv = gcplyr::calc_deriv(x = hours, y = OD600_smooth_md_avg),\n         deriv_percap5 = gcplyr::calc_deriv(x = hours, y = OD600_smooth_md_avg, \n                                        percapita = TRUE, blank = 0,\n                                        window_width_n = 5, trans_y = \"log\"),\n         doub_time = gcplyr::doubling_time(y = deriv_percap5)) %&gt;% \n  ungroup()\n\n# save for later\nwrite_rds(gcurves_slurped_fmt_bl_sm_dv, here::here(data, \"growth_curves_deriv.rds\"))",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#growth-summary-statistics",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#growth-summary-statistics",
    "title": "Analysis of growth curves",
    "section": "2.2 Growth summary statistics",
    "text": "2.2 Growth summary statistics\n\ngcurves_slurped_fmt_bl_sm_dv_sum &lt;- gcurves_slurped_fmt_bl_sm_dv %&gt;% \n  summarize(lag_time = gcplyr::lag_time(y = OD600_smooth_md_avg, x = hours, deriv = deriv_percap5),\n            max_percap = gcplyr::max_gc(deriv_percap5),\n            max_percap_time = hours[gcplyr::which_max_gc(deriv_percap5)],\n            max_percap_dens = OD600_smooth_md_avg[gcplyr::which_max_gc(deriv_percap5)],\n            doub_time = gcplyr::doubling_time(y = max_percap),\n            min_dens = gcplyr::min_gc(OD600_smooth_md_avg),\n            max_dens = gcplyr::max_gc(OD600_smooth_md_avg, na.rm = TRUE),\n            auc = auc(x = hours, y = OD600_smooth_md_avg),\n            .by = c(plate, well))\n\n# save for later\nwrite_rds(gcurves_slurped_fmt_bl_sm_dv_sum, here::here(data, \"growth_curves_summary.rds\"))",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#bact-conditions",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#bact-conditions",
    "title": "Analysis of growth curves",
    "section": "3.1 Bact conditions",
    "text": "3.1 Bact conditions\n\n3.1.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Growth curves for the bacteria only conditions on Plate 1. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.1.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Growth curves for the bacteria only conditions on Plate 2. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.1.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Growth curves for the bacteria only conditions on Plate 3. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.1.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Growth curves for the bacteria only conditions on Plate 4. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.1.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Growth curves for bacteria only conditions on Plate 5. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.1.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Growth curves for bacteria only conditions on Plate 6. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.1.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Growth curves for bacteria only conditions on Plate 7. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.1.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Growth curves for bacteria only conditions on Plate 8. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#predator-conditions",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#predator-conditions",
    "title": "Analysis of growth curves",
    "section": "3.2 Predator conditions",
    "text": "3.2 Predator conditions\n\n3.2.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Growth curves for the ciliate conditions on Plate 1. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.2.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Growth curves for the ciliate conditions on Plate 2. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.2.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Growth curves for the ciliate conditions on Plate 3. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.2.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Growth curves for the ciliate conditions on Plate 4. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.2.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Growth curves for ciliate conditions on Plate 5. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.2.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Growth curves for ciliate conditions on Plate 6. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.2.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Growth curves for ciliate conditions on Plate 7. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.2.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Growth curves for ciliate conditions on Plate 8. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#streptomycin-conditions",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#streptomycin-conditions",
    "title": "Analysis of growth curves",
    "section": "3.3 Streptomycin conditions",
    "text": "3.3 Streptomycin conditions\n\n3.3.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17: Growth curves for the Streptomycin conditions on Plate 1. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.3.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: Growth curves for the Streptomycin conditions on Plate 2. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.3.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Growth curves for the Streptomycin conditions on Plate 3. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.3.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 20: Growth curves for the Streptomycin conditions on Plate 4. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.3.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 21: Growth curves for Streptomycin conditions on Plate 5. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.3.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 22: Growth curves for Streptomycin conditions on Plate 6. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.3.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 23: Growth curves for Streptomycin conditions on Plate 7. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.3.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 24: Growth curves for Streptomycin conditions on Plate 8. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#predator-streptomycin-conditions",
    "href": "R/20230112_clone_phenotyping/02_growth_curve_analysis.html#predator-streptomycin-conditions",
    "title": "Analysis of growth curves",
    "section": "3.4 Predator + Streptomycin conditions",
    "text": "3.4 Predator + Streptomycin conditions\n\n3.4.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 25: Growth curves for the Ciliate + Streptomycin conditions on Plate 1. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.4.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 26: Growth curves for the Ciliate + Streptomycin conditions on Plate 2. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.4.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 27: Growth curves for the Ciliate + Streptomycin conditions on Plate 3. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.4.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 28: Growth curves for the Ciliate + Streptomycin conditions on Plate 4. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.4.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 29: Growth curves for Ciliate + Streptomycin conditions on Plate 5. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.4.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30: Growth curves for Ciliate + Streptomycin conditions on Plate 6. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.4.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 31: Growth curves for Ciliate + Streptomycin conditions on Plate 7. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.\n\n\n\n\n\n3.4.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 32: Growth curves for Ciliate + Streptomycin conditions on Plate 8. The blue line is the running-median then running-average smoothed growth curve, the red line indicates the maximum realized growth rate \\((\\mu_{max})\\), the vertical black dashed line is the lag time, and the horizontal black line is the minimum density from the growth curve.",
    "crumbs": [
      "Clone phenotyping",
      "2. Growth curve analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html",
    "title": "Formatting growth curves",
    "section": "",
    "text": "library(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#load-required-packages",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#load-required-packages",
    "title": "Formatting growth curves",
    "section": "",
    "text": "library(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#global-variables",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#global-variables",
    "title": "Formatting growth curves",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#raw-growth-curves",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#raw-growth-curves",
    "title": "Formatting growth curves",
    "section": "2.1 Raw growth curves",
    "text": "2.1 Raw growth curves\n\ngcurves_slurped &lt;- readr::read_delim(samppaths, \n                          comment = \"#\", \n                          delim = \";\",\n                          escape_double = FALSE,\n                          trim_ws = TRUE, \n                          id = \"file_name\") \n\nRows: 9248 Columns: 98\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \";\"\ndbl  (96): A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, B1, B2, B3, B4...\ntime  (1): Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ngcurves_slurped_fmt &lt;- gcurves_slurped %&gt;% \n  mutate(plate = str_extract(file_name, \"A\\\\d_\\\\d\")) %&gt;% \n  dplyr::select(-file_name) %&gt;% \n  relocate(plate) %&gt;% \n  mutate(hours = lubridate::time_length(lubridate::hms(Time), unit = \"hours\")) %&gt;% \n  dplyr::select(-Time) %&gt;% \n  pivot_longer(c(-plate, -hours), names_to = \"well\", values_to = \"OD600\") %&gt;% \n  mutate(well = factor(well, levels = paste(rep(LETTERS[1:8], each = 12), 1:12, sep = \"\")))",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#subtract-baseline",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#subtract-baseline",
    "title": "Formatting growth curves",
    "section": "3.1 Subtract baseline",
    "text": "3.1 Subtract baseline\nMany of the curves start off at quite a high baseline - we will need to subtract out this value\n\nbaseline &lt;- gcurves_slurped_fmt %&gt;% \n  # first 10 minutes\n  filter(hours &lt; 0.33) %&gt;% \n  summarize(baseline = median(OD600), .by = c(plate, well))\n\ngcurves_slurped_fmt_bl &lt;- left_join(gcurves_slurped_fmt, baseline) %&gt;% \n  mutate(OD600_b = OD600 - baseline) %&gt;% \n  mutate(OD600_b = if_else(OD600_b &lt; 0, 0.01, OD600_b + 0.01))\n\nJoining with `by = join_by(plate, well)`",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#smoothing",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#smoothing",
    "title": "Formatting growth curves",
    "section": "3.2 Smoothing",
    "text": "3.2 Smoothing\nFor the growth curves we may need to do some smoothing because these were run before the optimized logphase600 protocol was in place (better breatheasy seals plus new sealing tool).\n\nSee here for a useful thread:\nThis answer seems most promising\nPotentially also promising",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#bact-conditions",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#bact-conditions",
    "title": "Formatting growth curves",
    "section": "4.1 Bact conditions",
    "text": "4.1 Bact conditions\n\n4.1.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Growth curves for the bacteria only conditions on Plate 1. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.1.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Growth curves for the bacteria only conditions on Plate 2. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.1.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Growth curves for the bacteria only conditions on Plate 3. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.1.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Growth curves for the bacteria only conditions on Plate 4. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.1.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Growth curves for bacteria only conditions on Plate 5. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.1.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Growth curves for bacteria only conditions on Plate 6. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.1.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Growth curves for bacteria only conditions on Plate 7. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.1.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Growth curves for bacteria only conditions on Plate 8. Blue line is raw data, red line is smoothed.",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#predator-conditions",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#predator-conditions",
    "title": "Formatting growth curves",
    "section": "4.2 Predator conditions",
    "text": "4.2 Predator conditions\n\n4.2.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Growth curves for the ciliate conditions on Plate 1. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.2.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Growth curves for the ciliate conditions on Plate 2. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.2.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Growth curves for the ciliate conditions on Plate 3. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.2.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Growth curves for the ciliate conditions on Plate 4. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.2.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Growth curves for ciliate conditions on Plate 5. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.2.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Growth curves for ciliate conditions on Plate 6. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.2.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Growth curves for ciliate conditions on Plate 7. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.2.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Growth curves for ciliate conditions on Plate 8. Blue line is raw data, red line is smoothed.",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#streptomycin-conditions",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#streptomycin-conditions",
    "title": "Formatting growth curves",
    "section": "4.3 Streptomycin conditions",
    "text": "4.3 Streptomycin conditions\n\n4.3.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17: Growth curves for the Streptomycin conditions on Plate 1. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.3.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: Growth curves for the Streptomycin conditions on Plate 2. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.3.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Growth curves for the Streptomycin conditions on Plate 3. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.3.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 20: Growth curves for the Streptomycin conditions on Plate 4. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.3.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 21: Growth curves for Streptomycin conditions on Plate 5. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.3.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 22: Growth curves for Streptomycin conditions on Plate 6. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.3.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 23: Growth curves for Streptomycin conditions on Plate 7. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.3.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 24: Growth curves for Streptomycin conditions on Plate 8. Blue line is raw data, red line is smoothed.",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#predator-streptomycin-conditions",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#predator-streptomycin-conditions",
    "title": "Formatting growth curves",
    "section": "4.4 Predator + Streptomycin conditions",
    "text": "4.4 Predator + Streptomycin conditions\n\n4.4.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 25: Growth curves for the Ciliate + Streptomycin conditions on Plate 1. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.4.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 26: Growth curves for the Ciliate + Streptomycin conditions on Plate 2. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.4.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 27: Growth curves for the Ciliate + Streptomycin conditions on Plate 3. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.4.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 28: Growth curves for the Ciliate + Streptomycin conditions on Plate 4. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.4.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 29: Growth curves for Ciliate + Streptomycin conditions on Plate 5. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.4.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30: Growth curves for Ciliate + Streptomycin conditions on Plate 6. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.4.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 31: Growth curves for Ciliate + Streptomycin conditions on Plate 7. Blue line is raw data, red line is smoothed.\n\n\n\n\n\n4.4.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 32: Growth curves for Ciliate + Streptomycin conditions on Plate 8. Blue line is raw data, red line is smoothed.",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/cell_density/01_plotting.html",
    "href": "R/cell_density/01_plotting.html",
    "title": "Cell density",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(withr)\nlibrary(Rtsne)\nlibrary(patchwork)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"cell_density\")\ndata &lt;- here::here(\"data\", \"cell_density\")\nfigs &lt;- here::here(\"figs\", \"cell_density\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\nfs::dir_create(figs)\n\n\n\n\n\nod &lt;- readr::read_tsv(here::here(data, \"OD600.tsv\")) %&gt;%\n  group_by(measure_env, evolution_env) %&gt;%\n  mutate(mean_od = median(od600)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    measure_env_short = case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    home_env_short = case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )\n\n\n\n\n\ntetra &lt;- readr::read_tsv(here::here(data, \"tetrahymena.tsv\")) %&gt;%\n  group_by(measure_env, evolution_env) %&gt;%\n  mutate(mean_cil = median(ciliate_per_ml)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    measure_env_short = case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    home_env_short = case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )"
  },
  {
    "objectID": "R/cell_density/01_plotting.html#libraries-and-global-variables",
    "href": "R/cell_density/01_plotting.html#libraries-and-global-variables",
    "title": "Cell density",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(withr)\nlibrary(Rtsne)\nlibrary(patchwork)\nsource(here::here(\"R\", \"utils_generic.R\"))"
  },
  {
    "objectID": "R/cell_density/01_plotting.html#required-directories",
    "href": "R/cell_density/01_plotting.html#required-directories",
    "title": "Cell density",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"cell_density\")\ndata &lt;- here::here(\"data\", \"cell_density\")\nfigs &lt;- here::here(\"figs\", \"cell_density\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\nfs::dir_create(figs)"
  },
  {
    "objectID": "R/cell_density/01_plotting.html#read-and-format-optical-density-data",
    "href": "R/cell_density/01_plotting.html#read-and-format-optical-density-data",
    "title": "Cell density",
    "section": "",
    "text": "od &lt;- readr::read_tsv(here::here(data, \"OD600.tsv\")) %&gt;%\n  group_by(measure_env, evolution_env) %&gt;%\n  mutate(mean_od = median(od600)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    measure_env_short = case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    home_env_short = case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )"
  },
  {
    "objectID": "R/cell_density/01_plotting.html#read-and-format-ciliate-density-data",
    "href": "R/cell_density/01_plotting.html#read-and-format-ciliate-density-data",
    "title": "Cell density",
    "section": "",
    "text": "tetra &lt;- readr::read_tsv(here::here(data, \"tetrahymena.tsv\")) %&gt;%\n  group_by(measure_env, evolution_env) %&gt;%\n  mutate(mean_cil = median(ciliate_per_ml)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    measure_env_short = case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    home_env_short = case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )"
  },
  {
    "objectID": "R/cell_density/01_plotting.html#od600",
    "href": "R/cell_density/01_plotting.html#od600",
    "title": "Cell density",
    "section": "2.1 OD600",
    "text": "2.1 OD600\n\npod &lt;- ggplot(od, aes(x = transfer, y = od600)) +\n  geom_line(aes(color = replicate)) +\n  geom_hline(aes(yintercept = mean_od), linetype = \"dashed\") + \n  scale_x_continuous(breaks = c(2, 4, 6, 8, 10, 12)) +\n  labs(y = \"Optical Density (600 nm)\", x = \"Experiment transfer (weeks)\", color = \"Replicate\") +\n  facet_grid(measure_env_short ~ home_env_short) +\n  theme_bw() +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n\nggsave(here::here(figs, \"optical_density.svg\"), pod, width=8, height=6, units=\"in\",\n      device=\"svg\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Bacterial optical density (vertical axis) with respect to experimental transfer (horizontal axis). The different replicate microcosms are denoted by color. Optical density for the microscosms is displayed with respect to measurement environment (grid rows) and evolutionary history (grid columns, “home” environment)."
  },
  {
    "objectID": "R/cell_density/01_plotting.html#ciliate-density",
    "href": "R/cell_density/01_plotting.html#ciliate-density",
    "title": "Cell density",
    "section": "2.2 Ciliate density",
    "text": "2.2 Ciliate density\n\nptet &lt;- ggplot(tetra, aes(x = transfer, y = ciliate_per_ml)) +\n  geom_line(aes(color = replicate)) +\n  geom_hline(aes(yintercept = mean_cil), linetype = \"dashed\") + \n  scale_x_continuous(breaks = c(2, 4, 6, 8, 10, 12)) +\n  facet_grid(measure_env_short ~ home_env_short) +\n  labs(y = \"Ciliate Density (cells per ml)\", x = \"Experiment transfer (weeks)\", color = \"Replicate\") +\n  theme_bw() +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n\nggsave(here::here(figs, \"optical_density.svg\"), ptet, width=8, height=4, units=\"in\",\n      device=\"svg\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Ciliate density (vertical axis, cells per ml) with respect to experimental transfer (horizontal axis). The different replicate microcosms are denoted by color. Predator density is displayed with respect to measurement environment (grid rows) and evolutionary history (grid columns, “home” environment)."
  },
  {
    "objectID": "R/cell_density/01_analysis.html",
    "href": "R/cell_density/01_analysis.html",
    "title": "Cell density",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(withr)\nlibrary(Rtsne)\nlibrary(patchwork)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"cell_density\")\ndata &lt;- here::here(\"data\", \"cell_density\")\nfigs &lt;- here::here(\"figs\", \"cell_density\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\nfs::dir_create(figs)\n\n\n\n\n\nod &lt;- readr::read_tsv(here::here(data, \"OD600.tsv\")) %&gt;%\n  group_by(measure_env, evolution_env) %&gt;%\n  mutate(mean_od = median(od600)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    measure_env_short = case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    home_env_short = case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )\n\n\n\n\n\ntetra &lt;- readr::read_tsv(here::here(data, \"tetrahymena.tsv\")) %&gt;%\n  group_by(measure_env, evolution_env) %&gt;%\n  mutate(mean_cil = median(ciliate_per_ml)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    measure_env_short = case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    home_env_short = case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "Bacteria and ciliate population densities",
      "1. Analysis"
    ]
  },
  {
    "objectID": "R/cell_density/01_analysis.html#libraries-and-global-variables",
    "href": "R/cell_density/01_analysis.html#libraries-and-global-variables",
    "title": "Cell density",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(withr)\nlibrary(Rtsne)\nlibrary(patchwork)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "Bacteria and ciliate population densities",
      "1. Analysis"
    ]
  },
  {
    "objectID": "R/cell_density/01_analysis.html#required-directories",
    "href": "R/cell_density/01_analysis.html#required-directories",
    "title": "Cell density",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"cell_density\")\ndata &lt;- here::here(\"data\", \"cell_density\")\nfigs &lt;- here::here(\"figs\", \"cell_density\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\nfs::dir_create(figs)",
    "crumbs": [
      "Bacteria and ciliate population densities",
      "1. Analysis"
    ]
  },
  {
    "objectID": "R/cell_density/01_analysis.html#read-and-format-optical-density-data",
    "href": "R/cell_density/01_analysis.html#read-and-format-optical-density-data",
    "title": "Cell density",
    "section": "",
    "text": "od &lt;- readr::read_tsv(here::here(data, \"OD600.tsv\")) %&gt;%\n  group_by(measure_env, evolution_env) %&gt;%\n  mutate(mean_od = median(od600)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    measure_env_short = case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    home_env_short = case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "Bacteria and ciliate population densities",
      "1. Analysis"
    ]
  },
  {
    "objectID": "R/cell_density/01_analysis.html#read-and-format-ciliate-density-data",
    "href": "R/cell_density/01_analysis.html#read-and-format-ciliate-density-data",
    "title": "Cell density",
    "section": "",
    "text": "tetra &lt;- readr::read_tsv(here::here(data, \"tetrahymena.tsv\")) %&gt;%\n  group_by(measure_env, evolution_env) %&gt;%\n  mutate(mean_cil = median(ciliate_per_ml)) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    measure_env_short = case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    home_env_short = case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "Bacteria and ciliate population densities",
      "1. Analysis"
    ]
  },
  {
    "objectID": "R/cell_density/01_analysis.html#od600",
    "href": "R/cell_density/01_analysis.html#od600",
    "title": "Cell density",
    "section": "2.1 OD600",
    "text": "2.1 OD600\n\npod &lt;- ggplot(od, aes(x = transfer, y = od600)) +\n  geom_line(aes(color = replicate)) +\n  geom_hline(aes(yintercept = mean_od), linetype = \"dashed\") + \n  scale_x_continuous(breaks = c(2, 4, 6, 8, 10, 12)) +\n  labs(y = \"Optical Density (600 nm)\", x = \"Experiment transfer (weeks)\", color = \"Replicate\") +\n  facet_grid(measure_env_short ~ home_env_short) +\n  theme_bw() +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n\nggsave(here::here(figs, \"optical_density.svg\"), pod, width=8, height=6, units=\"in\",\n      device=\"svg\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Bacterial optical density (vertical axis) with respect to experimental transfer (horizontal axis). The different replicate microcosms are denoted by color. Optical density for the microscosms is displayed with respect to measurement environment (grid rows) and evolutionary history (grid columns, “home” environment).",
    "crumbs": [
      "Bacteria and ciliate population densities",
      "1. Analysis"
    ]
  },
  {
    "objectID": "R/cell_density/01_analysis.html#ciliate-density",
    "href": "R/cell_density/01_analysis.html#ciliate-density",
    "title": "Cell density",
    "section": "2.2 Ciliate density",
    "text": "2.2 Ciliate density\n\nptet &lt;- ggplot(tetra, aes(x = transfer, y = ciliate_per_ml)) +\n  geom_line(aes(color = replicate)) +\n  geom_hline(aes(yintercept = mean_cil), linetype = \"dashed\") + \n  scale_x_continuous(breaks = c(2, 4, 6, 8, 10, 12)) +\n  facet_grid(measure_env_short ~ home_env_short) +\n  labs(y = \"Ciliate Density (cells per ml)\", x = \"Experiment transfer (weeks)\", color = \"Replicate\") +\n  theme_bw() +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n\nggsave(here::here(figs, \"optical_density.svg\"), ptet, width=8, height=4, units=\"in\",\n      device=\"svg\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Ciliate density (vertical axis, cells per ml) with respect to experimental transfer (horizontal axis). The different replicate microcosms are denoted by color. Predator density is displayed with respect to measurement environment (grid rows) and evolutionary history (grid columns, “home” environment).",
    "crumbs": [
      "Bacteria and ciliate population densities",
      "1. Analysis"
    ]
  },
  {
    "objectID": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#smoothing-1",
    "href": "R/20230112_clone_phenotyping/01_growth_curve_qc.html#smoothing-1",
    "title": "Formatting growth curves",
    "section": "3.3 Smoothing",
    "text": "3.3 Smoothing\nHere we will smooth out some of the higher frequency noise in the curves. First we wil smooth using a moving median approach then smooth that using a moving average approach.\n\ngcurves_slurped_fmt_bl_sm &lt;- gcurves_slurped_fmt_bl %&gt;% \n  group_by(plate, well) %&gt;% \n  mutate(OD600_smooth_md = gcplyr::smooth_data(x = hours, y = OD600_b, \n                                            sm_method = \"moving-median\", \n                                            window_width_n = 9)) %&gt;% \n  mutate(OD600_smooth_md_avg = gcplyr::smooth_data(x = hours, y = OD600_smooth_md, \n                                            sm_method = \"moving-average\", \n                                            window_width_n = 9)) %&gt;% \n  ungroup()\n\n# save for later\nwrite_rds(gcurves_slurped_fmt_bl_sm, here::here(data, \"growth_curves_smoothed.rds\"))\n\nWe will also try a min then mean smoothing approach. Some of the curves are really wacky with lots of erratic peaks. Taking a moving minimum will try and make sure we exclude the big peaks, but it will also probably distort the curves to some extent\n\ngcurves_slurped_fmt_bl_sm2 &lt;- gcurves_slurped_fmt_bl %&gt;% \n  group_by(plate, well) %&gt;% \n  mutate(OD600_smooth_min = slider::slide_dbl(OD600_b, min, .before = 4, .after = 5)) %&gt;% \n  mutate(OD600_smooth_min_avg = slider::slide_dbl(OD600_smooth_min, mean, .before = 4, .after = 5)) %&gt;% \n  ungroup()\n\n\ngcurves_slurped_fmt_bl_sm3 &lt;- left_join(gcurves_slurped_fmt_bl_sm, gcurves_slurped_fmt_bl_sm2)\n\nJoining with `by = join_by(plate, hours, well, OD600, baseline, OD600_b)`",
    "crumbs": [
      "Clone phenotyping",
      "1. Growth curve quality control"
    ]
  },
  {
    "objectID": "R/communities/amplicon/01_composition_analysis.html",
    "href": "R/communities/amplicon/01_composition_analysis.html",
    "title": "Community composition analysis",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(Rtsne)\nlibrary(patchwork)\nlibrary(philentropy)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"communities\", \"20240318_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\",  \"communities\", \"20240318_BTK_illumina_v3\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\n\n\n\n\n\nsptable &lt;- readr::read_tsv(here::here(data, \"species_counts_md.tsv\")) %&gt;% \n  dplyr::mutate(transfer = day/7)\n\ncounts_f &lt;- sptable %&gt;% \n  dplyr::group_by(sample) %&gt;% \n  dplyr::mutate(f=count_correct/sum(count_correct)) %&gt;% \n  dplyr::ungroup() %&gt;% \n  dplyr::mutate(measure_env_short = dplyr::case_when(measure_env == \"bact\" ~ \"Meas: B\",\n                                       measure_env == \"bact_pred\" ~ \"Meas: BP\",\n                                       measure_env == \"bact_strep\" ~ \"Meas: BS\",\n                                       measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\")) %&gt;% \n  dplyr::mutate(home_env_short = dplyr::case_when(evolution_env == \"anc\" ~ \"Home: Anc\",\n                                    evolution_env == \"bact\" ~ \"Home: B\",\n                                    evolution_env == \"bact_pred\" ~ \"Home: BP\",\n                                    evolution_env == \"bact_strep\" ~ \"Home: BS\",\n                                    evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\")) %&gt;% \n  dplyr::mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\n\n\n\n\n# these are communities of a (supposedly) known composition. Can be used with metacal\npos_ctrl_samples &lt;- counts_f %&gt;% \n  dplyr::filter(str_detect(sample, \"pos_ctrl\"))\n\n# these are samples taken directly from YSK and represent the composition of the communities used to start the experiment\nt0_samples &lt;- counts_f %&gt;% \n  dplyr::filter(!str_detect(sample, \"pos_ctrl\")) %&gt;% \n  dplyr::filter(day == 0)\n\n# only samples from the experiment\ncounts_f_experiment &lt;- dplyr::anti_join(counts_f, pos_ctrl_samples) %&gt;% \n  dplyr::anti_join(., t0_samples) %&gt;% \n  dplyr::mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "ii) Analysis of community composition"
    ]
  },
  {
    "objectID": "R/communities/amplicon/01_composition_analysis.html#libraries-and-global-variables",
    "href": "R/communities/amplicon/01_composition_analysis.html#libraries-and-global-variables",
    "title": "Community composition analysis",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(Rtsne)\nlibrary(patchwork)\nlibrary(philentropy)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "ii) Analysis of community composition"
    ]
  },
  {
    "objectID": "R/communities/amplicon/01_composition_analysis.html#required-directories",
    "href": "R/communities/amplicon/01_composition_analysis.html#required-directories",
    "title": "Community composition analysis",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"communities\", \"20240318_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\",  \"communities\", \"20240318_BTK_illumina_v3\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "ii) Analysis of community composition"
    ]
  },
  {
    "objectID": "R/communities/amplicon/01_composition_analysis.html#read-and-format-16s-amplicon-data",
    "href": "R/communities/amplicon/01_composition_analysis.html#read-and-format-16s-amplicon-data",
    "title": "Community composition analysis",
    "section": "",
    "text": "sptable &lt;- readr::read_tsv(here::here(data, \"species_counts_md.tsv\")) %&gt;% \n  dplyr::mutate(transfer = day/7)\n\ncounts_f &lt;- sptable %&gt;% \n  dplyr::group_by(sample) %&gt;% \n  dplyr::mutate(f=count_correct/sum(count_correct)) %&gt;% \n  dplyr::ungroup() %&gt;% \n  dplyr::mutate(measure_env_short = dplyr::case_when(measure_env == \"bact\" ~ \"Meas: B\",\n                                       measure_env == \"bact_pred\" ~ \"Meas: BP\",\n                                       measure_env == \"bact_strep\" ~ \"Meas: BS\",\n                                       measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\")) %&gt;% \n  dplyr::mutate(home_env_short = dplyr::case_when(evolution_env == \"anc\" ~ \"Home: Anc\",\n                                    evolution_env == \"bact\" ~ \"Home: B\",\n                                    evolution_env == \"bact_pred\" ~ \"Home: BP\",\n                                    evolution_env == \"bact_strep\" ~ \"Home: BS\",\n                                    evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\")) %&gt;% \n  dplyr::mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "ii) Analysis of community composition"
    ]
  },
  {
    "objectID": "R/communities/amplicon/01_composition_analysis.html#tidying",
    "href": "R/communities/amplicon/01_composition_analysis.html#tidying",
    "title": "Community composition analysis",
    "section": "",
    "text": "# these are communities of a (supposedly) known composition. Can be used with metacal\npos_ctrl_samples &lt;- counts_f %&gt;% \n  dplyr::filter(str_detect(sample, \"pos_ctrl\"))\n\n# these are samples taken directly from YSK and represent the composition of the communities used to start the experiment\nt0_samples &lt;- counts_f %&gt;% \n  dplyr::filter(!str_detect(sample, \"pos_ctrl\")) %&gt;% \n  dplyr::filter(day == 0)\n\n# only samples from the experiment\ncounts_f_experiment &lt;- dplyr::anti_join(counts_f, pos_ctrl_samples) %&gt;% \n  dplyr::anti_join(., t0_samples) %&gt;% \n  dplyr::mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "ii) Analysis of community composition"
    ]
  },
  {
    "objectID": "R/communities/cell_density/01_analysis.html",
    "href": "R/communities/cell_density/01_analysis.html",
    "title": "Cell density",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(withr)\nlibrary(Rtsne)\nlibrary(patchwork)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"communities\", \"cell_density\")\ndata &lt;- here::here(\"data\", \"communities\", \"cell_density\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\n\n\n\n\n\nod &lt;- readr::read_tsv(here::here(data, \"OD600.tsv\")) %&gt;%\n  dplyr::group_by(measure_env, evolution_env) %&gt;%\n  dplyr::mutate(mean_od = median(od600)) %&gt;%\n  dplyr::ungroup() %&gt;%\n  dplyr::mutate(\n    measure_env_short = dplyr::case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    home_env_short = dplyr::case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )\n\n\n\n\n\ntetra &lt;- readr::read_tsv(here::here(data, \"tetrahymena.tsv\")) %&gt;%\n  dplyr::group_by(measure_env, evolution_env) %&gt;%\n  dplyr::mutate(mean_cil = median(ciliate_per_ml)) %&gt;%\n  dplyr::ungroup() %&gt;%\n  dplyr::mutate(\n    measure_env_short = dplyr::case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    home_env_short = dplyr::case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "1. Community growth - Bacteria and ciliate densities",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/communities/cell_density/01_analysis.html#libraries-and-global-variables",
    "href": "R/communities/cell_density/01_analysis.html#libraries-and-global-variables",
    "title": "Cell density",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(scales)\nlibrary(ggh4x)\nlibrary(withr)\nlibrary(Rtsne)\nlibrary(patchwork)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "1. Community growth - Bacteria and ciliate densities",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/communities/cell_density/01_analysis.html#required-directories",
    "href": "R/communities/cell_density/01_analysis.html#required-directories",
    "title": "Cell density",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"communities\", \"cell_density\")\ndata &lt;- here::here(\"data\", \"communities\", \"cell_density\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)",
    "crumbs": [
      "1. Community growth - Bacteria and ciliate densities",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/communities/cell_density/01_analysis.html#read-and-format-optical-density-data",
    "href": "R/communities/cell_density/01_analysis.html#read-and-format-optical-density-data",
    "title": "Cell density",
    "section": "",
    "text": "od &lt;- readr::read_tsv(here::here(data, \"OD600.tsv\")) %&gt;%\n  dplyr::group_by(measure_env, evolution_env) %&gt;%\n  dplyr::mutate(mean_od = median(od600)) %&gt;%\n  dplyr::ungroup() %&gt;%\n  dplyr::mutate(\n    measure_env_short = dplyr::case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    home_env_short = dplyr::case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "1. Community growth - Bacteria and ciliate densities",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/communities/cell_density/01_analysis.html#read-and-format-ciliate-density-data",
    "href": "R/communities/cell_density/01_analysis.html#read-and-format-ciliate-density-data",
    "title": "Cell density",
    "section": "",
    "text": "tetra &lt;- readr::read_tsv(here::here(data, \"tetrahymena.tsv\")) %&gt;%\n  dplyr::group_by(measure_env, evolution_env) %&gt;%\n  dplyr::mutate(mean_cil = median(ciliate_per_ml)) %&gt;%\n  dplyr::ungroup() %&gt;%\n  dplyr::mutate(\n    measure_env_short = dplyr::case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    home_env_short = dplyr::case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  dplyr::mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate)\n  )",
    "crumbs": [
      "1. Community growth - Bacteria and ciliate densities",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/communities/cell_density/01_analysis.html#od600",
    "href": "R/communities/cell_density/01_analysis.html#od600",
    "title": "Cell density",
    "section": "2.1 OD600",
    "text": "2.1 OD600\n\npod &lt;- ggplot2::ggplot(od, aes(x = transfer, y = od600)) +\n  ggplot2::geom_line(aes(color = replicate)) +\n  ggplot2::geom_hline(aes(yintercept = mean_od), linetype = \"dashed\") + \n  ggplot2::scale_x_continuous(breaks = c(2, 4, 6, 8, 10, 12)) +\n  ggplot2::labs(y = \"Optical Density (600 nm)\", x = \"Experiment transfer (weeks)\", color = \"Replicate\") +\n  ggplot2::facet_grid(measure_env_short ~ home_env_short) +\n  ggplot2::theme_bw() +\n  ggplot2::theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n\nggplot2::ggsave(\n  here::here(\"figs\", \"community_optical_density.svg\"),\n  pod,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(\"figs\", \"community_optical_density.png\"),\n  pod,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Bacterial optical density (vertical axis) with respect to experimental transfer (horizontal axis). The different replicate microcosms are denoted by color. Optical density for the microscosms is displayed with respect to measurement environment (grid rows) and evolutionary history (grid columns, “home” environment).",
    "crumbs": [
      "1. Community growth - Bacteria and ciliate densities",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/communities/cell_density/01_analysis.html#ciliate-density",
    "href": "R/communities/cell_density/01_analysis.html#ciliate-density",
    "title": "Cell density",
    "section": "2.2 Ciliate density",
    "text": "2.2 Ciliate density\n\nptet &lt;- ggplot(tetra, aes(x = transfer, y = ciliate_per_ml)) +\n  geom_line(aes(color = replicate)) +\n  geom_hline(aes(yintercept = mean_cil), linetype = \"dashed\") + \n  scale_x_continuous(breaks = c(2, 4, 6, 8, 10, 12)) +\n  facet_grid(measure_env_short ~ home_env_short) +\n  labs(y = \"Ciliate Density (cells per ml)\", x = \"Experiment transfer (weeks)\", color = \"Replicate\") +\n  theme_bw() +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n  )\n\nggplot2::ggsave(\n  here::here(\"figs\", \"community_ciliate_density.svg\"),\n  ptet,\n  width = 8,\n  height = 4,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(\"figs\", \"community_ciliate_density.png\"),\n  ptet,\n  width = 8,\n  height = 4,\n  units = \"in\",\n  device = \"png\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Ciliate density (vertical axis, cells per ml) with respect to experimental transfer (horizontal axis). The different replicate microcosms are denoted by color. Predator density is displayed with respect to measurement environment (grid rows) and evolutionary history (grid columns, “home” environment).",
    "crumbs": [
      "1. Community growth - Bacteria and ciliate densities",
      "i) Process and plot densities"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html",
    "href": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html",
    "title": "Formatting Rbec output",
    "section": "",
    "text": "Contains both results from hambiYSKpleiotropy experiment and also a test of the boilprep extraction method from the tipping point experiment.",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "i) 20240318_BTK_illumina_v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#libraries",
    "href": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#libraries",
    "title": "Formatting Rbec output",
    "section": "2.1 Libraries",
    "text": "2.1 Libraries\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(archive)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "i) 20240318_BTK_illumina_v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#global-variables",
    "href": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#global-variables",
    "title": "Formatting Rbec output",
    "section": "2.2 Global variables",
    "text": "2.2 Global variables\n\ndata_raw &lt;- here::here(\"_data_raw\", \"communities\", \"20240318_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"communities\", \"20240318_BTK_illumina_v3\")\namplicontar &lt;- here::here(data_raw, \"rbec_output.tar.gz\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n# create temporary location to decompress\ntmpdir &lt;- fs::file_temp()",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "i) 20240318_BTK_illumina_v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#data",
    "href": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#data",
    "title": "Formatting Rbec output",
    "section": "2.3 Data",
    "text": "2.3 Data\n\ntax_locus_copynum &lt;- tibble::tribble(\n     ~strainID, ~rRNA16S_cn, ~rRNA16S_locus,             ~genus,        ~species,\n  \"HAMBI_0006\",          7L,  \"H0006_04757\",      \"Pseudomonas\",        \"putida\",\n  \"HAMBI_0097\",          7L,  \"H0097_00044\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_02759\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0097\",          7L,  \"H0097_01762\",    \"Acinetobacter\",     \"johnsonii\",\n  \"HAMBI_0105\",          4L,  \"H0105_02306\",    \"Agrobacterium\",   \"tumefaciens\",\n  \"HAMBI_0262\",          3L,  \"H0262_00030\",    \"Brevundimonas\",       \"bullata\",\n  \"HAMBI_0403\",          9L,  \"H0403_00517\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_0403\",          9L,  \"H0403_00522\",        \"Comamonas\",  \"testosteroni\",\n  \"HAMBI_1279\",          7L,  \"H1279_03627\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_00125\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1279\",          7L,  \"H1279_03957\",           \"Hafnia\",         \"alvei\",\n  \"HAMBI_1287\",          7L,  \"H1287_03997\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1287\",          7L,  \"H1287_03402\",      \"Citrobacter\",        \"koseri\",\n  \"HAMBI_1292\",          7L,  \"H1292_03239\",       \"Morganella\",      \"morganii\",\n  \"HAMBI_1299\",          8L,  \"H1299_04293\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1299_01283\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1299\",          8L,  \"H1279_03957\",         \"Kluyvera\",    \"intermedia\",\n  \"HAMBI_1842\",          4L,  \"H1842_01650\",      \"Sphingobium\",    \"yanoikuyae\",\n  \"HAMBI_1896\",          4L,  \"H1896_00963\", \"Sphingobacterium\",  \"spiritivorum\",\n  \"HAMBI_1972\",         10L,  \"H1972_00343\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1972\",         10L,  \"H1972_03531\",        \"Aeromonas\",        \"caviae\",\n  \"HAMBI_1977\",          5L,  \"H1977_00118\",      \"Pseudomonas\",  \"chlororaphis\",\n  \"HAMBI_1988\",          5L,  \"H1988_05160\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05152\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_1988\",          5L,  \"H1988_05165\",     \"Chitinophaga\",        \"sancti\",\n  \"HAMBI_2159\",          4L,  \"H2159_01406\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2159\",          4L,  \"H2159_05851\",        \"Trinickia\",   \"caryophylli\",\n  \"HAMBI_2160\",          3L,  \"H2160_00530\",       \"Bordetella\",         \"avium\",\n  \"HAMBI_2164\",          5L,  \"H2164_03337\",      \"Cupriavidus\",    \"oxalaticus\",\n  \"HAMBI_2443\",          3L,  \"H2443_00128\",       \"Paracoccus\", \"denitrificans\",\n  \"HAMBI_2494\",          4L,  \"H2494_03389\", \"Paraburkholderia\",   \"kururiensis\",\n  \"HAMBI_2659\",          4L,  \"H2659_00367\", \"Stenotrophomonas\",   \"maltophilia\",\n  \"HAMBI_2792\",          4L,  \"H2792_00549\",        \"Moraxella\",         \"canis\",\n  \"HAMBI_3031\",          2L,  \"H3031_00830\",         \"Niabella\",  \"yanshanensis\",\n  \"HAMBI_3237\",          6L,  \"H3237_00875\",       \"Microvirga\",   \"lotononidis\",\n  \"HAMBI_1923\",          6L,  \"H1923_00876\",   \"Flavobacterium\",      \"odoratum\"\n  )",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "i) 20240318_BTK_illumina_v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#functions",
    "href": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#functions",
    "title": "Formatting Rbec output",
    "section": "2.4 Functions",
    "text": "2.4 Functions\n\n# this function \nnormalize_by_copy &lt;- function(.data, tlc = tax_locus_copynum){\n  .data %&gt;% \n    # join with the copy number data frame. We join by the locus tag so this will add H1279_03957 to HAMBI_1299\n    dplyr::left_join(tlc, by = join_by(rRNA16S_locus)) %&gt;%\n    # get total number of mapping reads per species. This aggregates all the difference ASVs per species\n    dplyr::summarize(count = sum(count), .by = c(sample, strainID, rRNA16S_cn)) %&gt;% \n    # group by sample\n    dplyr::group_by(sample) %&gt;% \n    # calculate a corrected count which is simply the count divided by copy num for each species\n    # dividide by the sum of count divided by copy num for whole sample multiplied by the total\n    # number of mapped reads per sample\n    dplyr::mutate(count_correct = round(sum(count)*(count/rRNA16S_cn)/sum(count/rRNA16S_cn))) %&gt;%  \n    dplyr::ungroup() %&gt;% \n    dplyr::select(sample, strainID, count, count_correct)\n  }\n\n# this function replaces missing species counts with zero\ncompletecombos &lt;- function(.data, tlc = tax_locus_copynum, countname = count, remove1923 = TRUE){\n \n  # get unique strainIDs\n  strainID &lt;- unique(tlc$strainID)\n  # table for assigning genus and species names. Doesn't matter if 1923 is there or not\n  # because it is filter joined later\n  tax &lt;- dplyr::distinct(dplyr::select(tlc, strainID, genus, species))\n  if (remove1923) {\n    # get unique strainIDs but exclude 1923 if remove1923 is true\n    strainID &lt;- strainID[strainID != \"HAMBI_1923\"]\n  }\n  \n  dplyr::bind_rows(tibble::tibble(strainID = strainID, sample = \"dummy\"), .data) %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(sample == \"dummy\", 1, {{ countname }})) %&gt;% \n    tidyr::complete(sample, strainID) %&gt;% \n    dplyr::filter(sample != \"dummy\") %&gt;% \n    dplyr::mutate( \"{{ countname }}\" := dplyr::if_else(is.na({{ countname }}), 0, {{ countname }})) %&gt;% \n    tidyr::replace_na(list(count_correct = 0)) %&gt;% \n    dplyr::left_join(dplyr::distinct(dplyr::select(tlc, strainID, genus, species))) %&gt;% \n    dplyr::relocate(genus, species, .after = strainID)\n}",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "i) 20240318_BTK_illumina_v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#untar-rbec-output-tarball",
    "href": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#untar-rbec-output-tarball",
    "title": "Formatting Rbec output",
    "section": "4.1 Untar Rbec output tarball",
    "text": "4.1 Untar Rbec output tarball\n\narchive::archive_extract(\n  amplicontar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "i) 20240318_BTK_illumina_v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#setup-directory-structure",
    "href": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#setup-directory-structure",
    "title": "Formatting Rbec output",
    "section": "4.2 Setup directory structure",
    "text": "4.2 Setup directory structure\n\ntabdir &lt;- here::here(tmpdir, \"rbec_output\")\nsamppaths &lt;- fs::dir_ls(tabdir)\nsampnames &lt;- fs::path_split(samppaths) %&gt;% \n  purrr::map_chr(dplyr::last)",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "i) 20240318_BTK_illumina_v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#read",
    "href": "R/communities/amplicon/20240318_BTK_illumina_v3/01_format_rbec_tab.html#read",
    "title": "Formatting Rbec output",
    "section": "4.3 Read",
    "text": "4.3 Read\n\nstraintabs &lt;- paste0(samppaths, \"/strain_table.txt\") %&gt;% \n  purrr::set_names(sampnames) %&gt;% \n  purrr::map(\n  readr::read_tsv,\n  skip = 1,\n  col_names = c(\"rRNA16S_locus\",\"count\"),\n  show_col_types = FALSE) %&gt;% \n  purrr::list_rbind(names_to = \"sample\")",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "i) 20240318_BTK_illumina_v3 / Data wrangling and QC"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"communities\", \"20240318_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"communities\", \"20240318_BTK_illumina_v3\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)\n\n\n\n\n\nsptable &lt;- readr::read_tsv(here::here(data, \"species_counts_md.tsv\")) %&gt;% \n  dplyr::mutate(transfer = day/7)\n\ncounts_f &lt;- sptable %&gt;% \n  dplyr::group_by(sample) %&gt;% \n  dplyr::mutate(f=count_correct/sum(count_correct)) %&gt;% \n  dplyr::ungroup() %&gt;% \n  dplyr::mutate(measure_env_short = dplyr::case_when(measure_env == \"bact\" ~ \"Meas: B\",\n                                       measure_env == \"bact_pred\" ~ \"Meas: BP\",\n                                       measure_env == \"bact_strep\" ~ \"Meas: BS\",\n                                       measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\")) %&gt;% \n  dplyr::mutate(home_env_short = dplyr::case_when(evolution_env == \"anc\" ~ \"Home: Anc\",\n                                    evolution_env == \"bact\" ~ \"Home: B\",\n                                    evolution_env == \"bact_pred\" ~ \"Home: BP\",\n                                    evolution_env == \"bact_strep\" ~ \"Home: BS\",\n                                    evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\")) %&gt;% \n  dplyr::mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\n\n\n\n\ncelldens &lt;- readr::read_tsv(here::here(\"data\", \"communities\", \"cell_density\", \"density4ML.tsv\"))\n\nRows: 360 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (3): measure_env, evolution_env, replicate\ndbl (3): transfer, od600, ciliate_per_ml\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n\n\n# these are communities of a (supposedly) known composition. Can be used with metacal\npos_ctrl_samples &lt;- counts_f %&gt;% \n  dplyr::filter(str_detect(sample, \"pos_ctrl\"))\n\n# these are samples taken directly from YSK and represent the composition of the communities used to start the experiment\nt0_samples &lt;- counts_f %&gt;% \n  dplyr::filter(!str_detect(sample, \"pos_ctrl\")) %&gt;% \n  dplyr::filter(day == 0)\n\n# only samples from the experiment\ncounts_f_experiment &lt;- anti_join(counts_f, pos_ctrl_samples) %&gt;% \n  dplyr::anti_join(., t0_samples) %&gt;% \n  dplyr::mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\nJoining with `by = join_by(sample, strainID, genus, species, count,\ncount_correct, replicate, day, measure_env, evolution_env, transfer, f,\nmeasure_env_short, home_env_short)`\nJoining with `by = join_by(sample, strainID, genus, species, count,\ncount_correct, replicate, day, measure_env, evolution_env, transfer, f,\nmeasure_env_short, home_env_short)`\n\n\n\n\n\nHere we’ll use the same filtering criteria as in the t-SNE analysis from section 3 of the last analysis.\n\ncounts_f_experiment %&gt;% \n  dplyr::group_by(strainID) %&gt;% \n  dplyr::summarize(n_samples = n(),\n            n_gt0 = sum(count &gt; 0),\n            p_gt0 = n_gt0 / n_samples) %&gt;% \n  dplyr::ungroup() %&gt;% \n  dplyr::arrange(n_gt0)\n\n\n  \n\n\n\nBriefly, we will use the centered log-ratio transformation for the species abundances. The centered log-ratio can be interpreted as the log-fold change of species i relative to the average microbe in a sample. The formula for the transformation is:\n\\[\n\\text{clr}(\\mathbf x)= \\left(log\n\\frac{x_i}{g(\\mathbf x)} \\right)_{i=1,...,D} \\qquad \\text{with} \\quad\ng(\\mathbf x) = \\left(\\prod_{i=1}^Dx_i\\right)^{1/D} =\n\\exp\\left(\\frac{1}{D}\\sum_{i=1}^D \\log x_i\\right)\\text{,}\n\\]\nWe will use the implementation of centered log-ratio transform in the compositions package\n\nset.seed(12353)\n\nlowstrainsv &lt;- c(\n  \"HAMBI_0097\",\n  \"HAMBI_2792\"\n)\n\nmymat &lt;- counts_f_experiment %&gt;% \n  dplyr::filter(strainID %nin% lowstrainsv) %&gt;% \n  dplyr::select(sample, strainID, count) %&gt;% \n  dplyr::mutate(count = count + 1) %&gt;% \n  # important to arrange by sample as this makes some later joins easier\n  dplyr::arrange(sample) %&gt;% \n  tidyr::pivot_wider(names_from = \"strainID\", values_from = \"count\") %&gt;% \n  tibble::column_to_rownames(var = \"sample\") %&gt;% \n  data.frame()\n\n# calculate clr transform\nbalclr &lt;- compositions::clr(mymat)",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html#libraries-and-global-variables",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html#libraries-and-global-variables",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "library(tidyverse)\nlibrary(here)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html#required-directories",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html#required-directories",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"communities\", \"20240318_BTK_illumina_v3\")\ndata &lt;- here::here(\"data\", \"communities\", \"20240318_BTK_illumina_v3\")\n\n# make processed data and figs directories if they don't exist\nfs::dir_create(data)",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html#read-and-format-16s-amplicon-data",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html#read-and-format-16s-amplicon-data",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "sptable &lt;- readr::read_tsv(here::here(data, \"species_counts_md.tsv\")) %&gt;% \n  dplyr::mutate(transfer = day/7)\n\ncounts_f &lt;- sptable %&gt;% \n  dplyr::group_by(sample) %&gt;% \n  dplyr::mutate(f=count_correct/sum(count_correct)) %&gt;% \n  dplyr::ungroup() %&gt;% \n  dplyr::mutate(measure_env_short = dplyr::case_when(measure_env == \"bact\" ~ \"Meas: B\",\n                                       measure_env == \"bact_pred\" ~ \"Meas: BP\",\n                                       measure_env == \"bact_strep\" ~ \"Meas: BS\",\n                                       measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\")) %&gt;% \n  dplyr::mutate(home_env_short = dplyr::case_when(evolution_env == \"anc\" ~ \"Home: Anc\",\n                                    evolution_env == \"bact\" ~ \"Home: B\",\n                                    evolution_env == \"bact_pred\" ~ \"Home: BP\",\n                                    evolution_env == \"bact_strep\" ~ \"Home: BS\",\n                                    evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\")) %&gt;% \n  dplyr::mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html#read-population-density-data",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html#read-population-density-data",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "celldens &lt;- readr::read_tsv(here::here(\"data\", \"communities\", \"cell_density\", \"density4ML.tsv\"))\n\nRows: 360 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (3): measure_env, evolution_env, replicate\ndbl (3): transfer, od600, ciliate_per_ml\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html#tidying",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html#tidying",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "# these are communities of a (supposedly) known composition. Can be used with metacal\npos_ctrl_samples &lt;- counts_f %&gt;% \n  dplyr::filter(str_detect(sample, \"pos_ctrl\"))\n\n# these are samples taken directly from YSK and represent the composition of the communities used to start the experiment\nt0_samples &lt;- counts_f %&gt;% \n  dplyr::filter(!str_detect(sample, \"pos_ctrl\")) %&gt;% \n  dplyr::filter(day == 0)\n\n# only samples from the experiment\ncounts_f_experiment &lt;- anti_join(counts_f, pos_ctrl_samples) %&gt;% \n  dplyr::anti_join(., t0_samples) %&gt;% \n  dplyr::mutate(measure_env_short = factor(measure_env_short, levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")),\n         home_env_short = factor(home_env_short, levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")),\n         day = factor(day),\n         replicate = factor(replicate),\n         strainID = factor(strainID, levels = names(hambi_colors)))\n\nJoining with `by = join_by(sample, strainID, genus, species, count,\ncount_correct, replicate, day, measure_env, evolution_env, transfer, f,\nmeasure_env_short, home_env_short)`\nJoining with `by = join_by(sample, strainID, genus, species, count,\ncount_correct, replicate, day, measure_env, evolution_env, transfer, f,\nmeasure_env_short, home_env_short)`",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html#data-normalization",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html#data-normalization",
    "title": "Community composition analysis using machine learning",
    "section": "",
    "text": "Here we’ll use the same filtering criteria as in the t-SNE analysis from section 3 of the last analysis.\n\ncounts_f_experiment %&gt;% \n  dplyr::group_by(strainID) %&gt;% \n  dplyr::summarize(n_samples = n(),\n            n_gt0 = sum(count &gt; 0),\n            p_gt0 = n_gt0 / n_samples) %&gt;% \n  dplyr::ungroup() %&gt;% \n  dplyr::arrange(n_gt0)\n\n\n  \n\n\n\nBriefly, we will use the centered log-ratio transformation for the species abundances. The centered log-ratio can be interpreted as the log-fold change of species i relative to the average microbe in a sample. The formula for the transformation is:\n\\[\n\\text{clr}(\\mathbf x)= \\left(log\n\\frac{x_i}{g(\\mathbf x)} \\right)_{i=1,...,D} \\qquad \\text{with} \\quad\ng(\\mathbf x) = \\left(\\prod_{i=1}^Dx_i\\right)^{1/D} =\n\\exp\\left(\\frac{1}{D}\\sum_{i=1}^D \\log x_i\\right)\\text{,}\n\\]\nWe will use the implementation of centered log-ratio transform in the compositions package\n\nset.seed(12353)\n\nlowstrainsv &lt;- c(\n  \"HAMBI_0097\",\n  \"HAMBI_2792\"\n)\n\nmymat &lt;- counts_f_experiment %&gt;% \n  dplyr::filter(strainID %nin% lowstrainsv) %&gt;% \n  dplyr::select(sample, strainID, count) %&gt;% \n  dplyr::mutate(count = count + 1) %&gt;% \n  # important to arrange by sample as this makes some later joins easier\n  dplyr::arrange(sample) %&gt;% \n  tidyr::pivot_wider(names_from = \"strainID\", values_from = \"count\") %&gt;% \n  tibble::column_to_rownames(var = \"sample\") %&gt;% \n  data.frame()\n\n# calculate clr transform\nbalclr &lt;- compositions::clr(mymat)",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html#classes-ancesteral-b-bp-bs-and-bps",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html#classes-ancesteral-b-bp-bs-and-bps",
    "title": "Community composition analysis using machine learning",
    "section": "2.1 5 classes (ancesteral, B, BP, BS, and BPS)",
    "text": "2.1 5 classes (ancesteral, B, BP, BS, and BPS)\nFirst were going to try and predict all 5 different home evolution environments\n\n2.1.1 Spliting\nSplit the data using the default 3:1 ratio of training-to-test. Here we also set the strata argument. This argument makes sure that both sides of the split have roughly the same distribution for each value of strata. If a numeric variable is passed to strata then it is binned and distributions are matched within bins. In this case there will be roughly the same distribution of the 5 classes within each side of the test/train split.\n\nbalclr_5c &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_ae, -home_env_sns, -home_env_pnp) %&gt;% \n  tidyr::drop_na()\n\ntable(balclr_5c$home_env_5c)\n\n\n            anc            bact       bact_pred bact_pred_strep      bact_strep \n             72              70              71              70              72 \n\n\nThe data is balanced\n\nset.seed(1501)\nbalclr_5c_split &lt;- rsample::initial_split(balclr_5c, strata = home_env_5c)\nbalclr_5c_train &lt;- rsample::training(balclr_5c_split)\nbalclr_5c_test  &lt;- rsample::testing(balclr_5c_split)\n\nResample the training set using five repeats of 10-fold cross-validation\n\nset.seed(1502)\nbalclr_5c_folds &lt;- rsample::vfold_cv(balclr_5c_train, strata = home_env_5c)\n\n\n\n2.1.2 Recipe\nFirst we need to preprocess the data so that it is in optimal format for Ml. Some useful steps include:\n\nstep_novel(): converts all nominal variables to factors and takes care of other issues related to categorical variables.\nstep_normalize(): normalizes (center and scales) the numeric variables to have a standard deviation of one and a mean of zero. (i.e., z-standardization).\nstep_dummy(): converts our factor column ocean_proximity into numeric binary (0 and 1) variables.\n\nNote that this step may cause problems if your categorical variable has too many levels - especially if some of the levels are very infrequent. In this case you should either drop the variable or pool infrequently occurring values into an “other” category with step_other. This steps has to be performed before step_dummy.\n\nstep_zv(): removes any numeric variables that have zero variance.\nstep_corr(): will remove predictor variables that have large correlations with other predictor variables.\n\nEdit: data is already in centered log-ratio transform and further normalization doesn’t really help.\n\nbalclr_5c_rec &lt;- recipes::recipe(home_env_5c ~ ., data = balclr_5c_train) %&gt;% \n  #step_novel(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_normalize(od600, ciliate_per_ml) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_zv(od600, ciliate_per_ml)# %&gt;% \n  #step_corr(all_predictors(), threshold = 0.7, method = \"spearman\")\n\nYou can take a peek at the what the preprocessing recipe does using prep and juice\n\nbalclr_5c_rec %&gt;% \n  # perform the recipe on training data\n  recipes::prep() %&gt;% \n  # extract only the preprocessed dataframe \n  recipes::bake(new_data = NULL)\n\n\n  \n\n\n\n\n\n2.1.3 Model specifications\nThe process of specifying models is:\n\nPick a model type\nSet the engine\nSet the mode: regression or classification\n\n\nlibrary(rules)\nlibrary(baguette)\n\nsvm_r_spec &lt;- \n   parsnip::svm_rbf(cost = tune(), rbf_sigma = tune()) %&gt;% \n   parsnip::set_engine(\"kernlab\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nsvm_p_spec &lt;- \n   parsnip::svm_poly(cost = tune(), degree = tune()) %&gt;% \n   parsnip::set_engine(\"kernlab\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\ncart_spec &lt;- \n   parsnip::decision_tree(cost_complexity = tune(), min_n = tune()) %&gt;% \n   parsnip::set_engine(\"rpart\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nbag_cart_spec &lt;- \n   parsnip::bag_tree() %&gt;% \n   parsnip::set_engine(\"rpart\", times = 50L) %&gt;% \n   parsnip::set_mode(\"classification\")\n\nrf_spec &lt;- \n   parsnip::rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %&gt;% \n   parsnip::set_engine(\"ranger\", importance = \"impurity\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nxgb_spec &lt;- \n   parsnip::boost_tree(tree_depth = tune(), learn_rate = tune(), loss_reduction = tune(), \n              min_n = tune(), sample_size = tune(), trees = tune()) %&gt;% \n   parsnip::set_engine(\"xgboost\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nnnet_spec &lt;- \n   parsnip::mlp(hidden_units = tune(), penalty = tune(), epochs = tune()) %&gt;% \n   parsnip::set_engine(\"nnet\", MaxNWts = 2600) %&gt;% \n   parsnip::set_mode(\"classification\")\n\nfda_spec &lt;- \n   parsnip::discrim_flexible(prod_degree = tune()) %&gt;%  #&lt;- use GCV to choose terms\n   parsnip::set_engine(\"earth\") %&gt;% \n   parsnip::set_mode(\"classification\")\n\nbart_spec &lt;- \n  parsnip::bart(trees = 1000, prior_terminal_node_coef = tune(), prior_terminal_node_expo = tune()) %&gt;% \n  parsnip::set_engine(\"dbarts\") %&gt;% \n  parsnip::set_mode(\"classification\")\n\n\n\n2.1.4 Create workflow set\nNow we need to specify the workflows that will be followed for the different model types\n\nbalclr_5c_wf &lt;- \n   workflowsets::workflow_set(\n      preproc = list(balclr_5c = balclr_5c_rec), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        #bart = bart_spec, \n        #fda = fda_spec,\n        RF = rf_spec)\n   )\n\nbalclr_5c_wf\n\n\n  \n\n\n\n\n\n2.1.5 Tune\nThis takes a long time to run\n\nbalclr_5c_grid_results &lt;-\n   workflowsets::workflow_map(balclr_5c_wf, \n      seed = 1578,\n      resamples = balclr_5c_folds,\n      grid = 15,\n      control = tune::control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nreadr::write_rds(balclr_5c_grid_results, here::here(data, \"model_tune_5_class.rds\"))\n\n\nbalclr_5c_grid_results &lt;- readr::read_rds(here::here(data, \"model_tune_5_class.rds\"))\n\n\n\n2.1.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. Gradient boosting and random forest have basically the same performance with random forest doing slightly better\n\nmymetric &lt;- \"roc_auc\"\n\ntune::autoplot(\n  balclr_5c_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n2.1.6.1 Peformance metrics for best model\n\ngetmymetrics &lt;- function(gridresults, myworkflow, mymetric, mysplit){\n  best_results &lt;- gridresults %&gt;% \n   workflowsets::extract_workflow_set_result(myworkflow) %&gt;% \n   tune::select_best(metric = mymetric)\n  \n   gridresults %&gt;% \n     hardhat::extract_workflow(myworkflow) %&gt;% \n     tune::finalize_workflow(best_results) %&gt;% \n     tune::last_fit(split = mysplit,\n             metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec))\n}\n\n\nset.seed(23784)\nbalclr_5c_rf_test_results &lt;- getmymetrics(balclr_5c_grid_results,\n                                          \"balclr_5c_RF\",\n                                          \"roc_auc\",\n                                          balclr_5c_split)\nbalclr_5c_boosting_test_results &lt;- getmymetrics(balclr_5c_grid_results,\n                                                \"balclr_5c_boosting\",\n                                                \"roc_auc\",\n                                                balclr_5c_split)\n\n\ncollect_metrics(balclr_5c_rf_test_results) %&gt;%\n  dplyr::select(metric = .metric,\n                random_forest = .estimate,\n                estimate_type = .estimator) %&gt;%\n  dplyr::left_join(\n    tune::collect_metrics(balclr_5c_boosting_test_results) %&gt;%\n      dplyr::select(\n        metric = .metric,\n        boosting = .estimate,\n        estimate_type = .estimator\n      )\n  ) %&gt;%\n  dplyr::relocate(estimate_type, metric)\n\nJoining with `by = join_by(metric, estimate_type)`\n\n\n\n  \n\n\n\n\n\n2.1.6.2 ROC-curve\nThis is a useful resource for understanding ROC curves and PR curves.\nROC curves here indicate that there is decent performance for the evolution environments of the ancestral clones, bacteria only, and bacteria plus ciliates. Performance is worse for treatments with streptomycin (see the PR curves). This is consistent with the strong overlap in community composition that we saw between strep and strep plus ciliate treatments. If the community response of the treatments is similiar it will be difficult to identify discriminating patterns in the data.\n\nbalclr_5c_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::roc_curve(home_env_5c, .pred_anc:.pred_bact_strep) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\nbalclr_5c_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::pr_curve(home_env_5c, .pred_anc:.pred_bact_strep) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n2.1.6.3 Confusion matrix\nThe confusion matrix shows that for ciliates evolution environment (bact_pred), the model is only getting the evolution environment correct about half the time (10 correct/8 incorrect) which is basically the same as guessing. The best performing home environments are the ancestral and the combined predators and streptomycin treatments.\n\nbalclr_5c_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::conf_mat(home_env_5c, .pred_class) %&gt;%\n  tune::autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n2.1.6.4 Probability distributions for the 5 classes\nThis plot gives some insight as to which classes the model has trouble distinguishing.\n\nbalclr_5c_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  tidyr::pivot_longer(c(\n    .pred_anc,\n    .pred_bact,\n    .pred_bact_pred,\n    .pred_bact_pred_strep,\n    .pred_bact_strep\n  )) %&gt;%\n  ggplot2::ggplot() +\n  ggplot2::geom_density(aes(x = value, fill = home_env_5c), alpha = 0.5) +\n  ggplot2::labs(x = \"Prediction Probability\", y = \"Density\") +\n  ggplot2::facet_wrap( ~ name)",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html#classes-ancestral-clones-vs-coevolved-history",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html#classes-ancestral-clones-vs-coevolved-history",
    "title": "Community composition analysis using machine learning",
    "section": "2.2 2 classes (ancestral clones vs coevolved history)",
    "text": "2.2 2 classes (ancestral clones vs coevolved history)\nBased on the above analysis and from inspecting the community composition data it appears that ancestral/clonal community has a distinct response to the measurement conditions compared with all the other evolutionary histories. Here instead of trying to predict 5 different home environment classes we just want to predict whether the bacteria had a coevolutionary history from the YSK experiment or not. However, this introduces an additional challenge because now the classes we will be trying to predict are imbalanced.\n\n2.2.1 Spliting\nDone the same as in Section 2.1.1 from the 5-class classification.\n\nbalclr_ae &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_5c, -home_env_sns, -home_env_pnp) %&gt;% \n  dplyr::mutate(replicate = factor(replicate),\n         transfer = factor(transfer),\n         measure_env = factor(measure_env),\n         home_env_ae = factor(home_env_ae))\n\ntable(balclr_ae$home_env_ae)\n\n\nanc evo \n 72 283 \n\n\nSo in this case the classes from the data are clearly not balanced… We will try and address that in the recipe step using the themis package.\n\nset.seed(1467)\nbalclr_ae_split &lt;- rsample::initial_split(balclr_ae, strata = home_env_ae)\nbalclr_ae_train &lt;- rsample::training(balclr_ae_split)\nbalclr_ae_test  &lt;- rsample::testing(balclr_ae_split)\n\n\nset.seed(1468)\nbalclr_ae_folds &lt;- rsample::vfold_cv(balclr_ae_train, strata = home_env_ae)\n\n\n\n2.2.2 Recipe\nDone the same as in Section 2.1.2 from the 5-class classification.\n\nbalclr_ae_rec &lt;- recipes::recipe(home_env_ae ~ ., data = balclr_ae_train) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes())\n\nbalclr_ae_rec_rose &lt;- recipes::recipe(home_env_ae ~ ., data = balclr_ae_train) %&gt;% \n  themis::step_rose(home_env_ae) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes())\n\n\n\n2.2.3 Model specifications\nUsing the same model specifications as in Section 2.1.3 from the 5-class classification.\n\n\n2.2.4 Create workflow set\nSame process as in Section 2.1.4 from the 5-class classification.\n\nbalclr_ae_wf &lt;- \n   workflowsets::workflow_set(\n      preproc = list(balclr_ae = balclr_ae_rec, \n                     balclr_ae_rose = balclr_ae_rec_rose), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        #bart = bart_spec, \n        #fda = fda_spec,\n        RF = rf_spec\n      )\n   )\n\n\n\n2.2.5 Tune\nSame as in Section 2.1.5 from the 5-class classification. Warning this takes some time…\n\nbalclr_ae_grid_results &lt;-\n   workflowsets::workflow_map(balclr_ae_wf, \n      seed = 1469,\n      resamples = balclr_ae_folds,\n      grid = 15,\n      control = tune::control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nreadr::write_rds(balclr_ae_grid_results, here::here(data, \"model_tune_ae.rds\"))\n\n\nbalclr_ae_grid_results &lt;- readr::read_rds(here::here(data, \"model_tune_ae.rds\"))\n\n\n\n2.2.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. We’ll use the J index and the ROC auc as suggested in the tidymodels unbalanced class tutorial.\n\nThe area under the ROC curve is an overall assessment of performance across all cutoffs. Values near one indicate very good results while values near 0.5 would imply that the model is very poor (i.e. no better than guessing)\nThe J index (a.k.a. Youden’s J statistic) is sensitivity + specificity - 1. Values near one are once again best.\n\nIf a model is poorly calibrated, the ROC curve value might not show diminished performance. However, the J index would be lower for models with pathological distributions for the class probabilities. The yardstick package will be used to compute these metrics.\nJ index\n\n# which metric to visualize\nmymetric &lt;- \"j_index\"\n\ntune::autoplot(\n  balclr_ae_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n# which metric to visualize\nmymetric &lt;- \"roc_auc\"\n\ntune::autoplot(\n  balclr_ae_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nIt looks like ROSE preprocessing step helped with the J-index. Class imbalance sampling methods tend to greatly improve metrics based on the hard class predictions (i.e., the categorical predictions) because the default cutoff tends to be a better balance of sensitivity and specificity.\n\n2.2.6.1 Peformance metrics for best model\n\nset.seed(4671)\nbalclr_ae_boosting_test_results &lt;- getmymetrics(balclr_ae_grid_results,\n                                                \"balclr_ae_rose_boosting\",\n                                                \"j_index\",\n                                                balclr_ae_split)\nbalclr_ae_rf_test_results &lt;- getmymetrics(balclr_ae_grid_results,\n                                          \"balclr_ae_rose_RF\",\n                                          \"j_index\",\n                                          balclr_ae_split)\n\n\ntune::collect_metrics(balclr_ae_rf_test_results) %&gt;%\n  dplyr::select(metric = .metric,\n                random_forest = .estimate,\n                estimate_type = .estimator) %&gt;%\n  dplyr::left_join(\n    tune::collect_metrics(balclr_ae_boosting_test_results) %&gt;%\n      dplyr::select(\n        metric = .metric,\n        boosting = .estimate,\n        estimate_type = .estimator\n      )\n  ) %&gt;%\n  dplyr::relocate(estimate_type, metric)\n\nJoining with `by = join_by(metric, estimate_type)`\n\n\n\n  \n\n\n\nAgain gradient boosting seems to be doing the best here.\n\n\n2.2.6.2 ROC-curve\nWith unbalaced classes like we have here, it is best to look at both the ROC curve and the PR (precision-recall) curve. See here\n\nbalclr_ae_boosting_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::roc_curve(home_env_ae, .pred_anc) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\nbalclr_ae_boosting_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::pr_curve(home_env_ae, .pred_anc) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n2.2.6.3 Confusion matrix\nThe model is doing pretty well finding the communiuties with a coevolutionary history, but it is doing less well at finding the ancestral communities. It is getting the ancestral correct 2/3 of the time.\n\nbalclr_ae_boosting_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::conf_mat(home_env_ae, .pred_class) %&gt;%\n  tune::autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n2.2.6.4 Probability distributions for the 2 classes\n\nbalclr_ae_boosting_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  ggplot2::ggplot() +\n  ggplot2::geom_density(aes(x = .pred_evo, fill = home_env_ae), alpha = 0.5) +\n  ggplot2::labs(x = \"Prediction Probability\", y = \"Density\")",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html#classes-streptomycin-history-vs-no-streptomycin-history",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html#classes-streptomycin-history-vs-no-streptomycin-history",
    "title": "Community composition analysis using machine learning",
    "section": "2.3 2 classes (streptomycin history vs no streptomycin history)",
    "text": "2.3 2 classes (streptomycin history vs no streptomycin history)\nNow we will try and predict whether the evolutionary history of the communities included exposure to streptomycin\n\n2.3.1 Spliting\nDone the same as in Section 2.1.1 from the 5-class classification.\n\nbalclr_sns &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_5c, -home_env_ae, -home_env_pnp) %&gt;% \n  dplyr::mutate(replicate = factor(replicate),\n         transfer = factor(transfer),\n         measure_env = factor(measure_env),\n         home_env_sns = factor(home_env_sns)) %&gt;% \n  # we omit the ancestral samples to keep it more balanced\n  tidyr::drop_na()\n\ntable(balclr_sns$home_env_sns)\n\n\nnostrep   strep \n    141     142 \n\n\n\nset.seed(1567)\nbalclr_sns_split &lt;- rsample::initial_split(balclr_sns, strata = home_env_sns)\nbalclr_sns_train &lt;- rsample::training(balclr_sns_split)\nbalclr_sns_test  &lt;- rsample::testing(balclr_sns_split)\n\n\nset.seed(1568)\nbalclr_sns_folds &lt;- rsample::vfold_cv(balclr_sns_train, strata = home_env_sns)\n\n\n\n2.3.2 Recipe\nDone the same as in Section 2.1.2 from the 5-class classification.\n\nbalclr_sns_rec &lt;- recipes::recipe(home_env_sns ~ ., data = balclr_sns_train) %&gt;% \n  recipes::step_normalize(od600, ciliate_per_ml) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_zv(od600, ciliate_per_ml)\n\n\n\n2.3.3 Model specifications\nUsing the same model specifications as in Section 2.1.3 from the 5-class classification.\n\n\n2.3.4 Create workflow set\nSame process as in Section 2.1.4 from the 5-class classification.\n\nlibrary(discrim)\n\nbalclr_sns_wf &lt;- \n   workflowsets::workflow_set(\n      preproc = list(balclr_sns = balclr_sns_rec), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        #bart = bart_spec, \n        #fda = fda_spec,\n        RF = rf_spec\n      )\n   )\n\n\n\n2.3.5 Tune\nSame as in Section 2.1.5 from the 5-class classification. Warning this takes some time…\n\nbalclr_sns_grid_results &lt;-\n   workflowsets::workflow_map(balclr_sns_wf, \n      seed = 1569,\n      resamples = balclr_sns_folds,\n      grid = 15,\n      control = tune::control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nreadr::write_rds(balclr_sns_grid_results, here::here(data, \"model_tune_sns.rds\"))\n\n\nbalclr_sns_grid_results &lt;- readr::read_rds(here::here(data, \"model_tune_sns.rds\"))\n\n\n\n2.3.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. It appears that based on all metrics the random forest performs the best.\n\nmymetric &lt;- \"roc_auc\"\n\ntune::autoplot(\n  balclr_sns_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n2.3.6.1 Peformance metrics for best model\nAll performance metrics are almost identical (making same overall predictions) with RF just having higher ROC auc\n\nset.seed(4671)\nbalclr_sns_rf_test_results &lt;- getmymetrics(balclr_sns_grid_results,\n                                           \"balclr_sns_RF\",\n                                           \"roc_auc\",\n                                           balclr_sns_split)\nbalclr_sns_boosting_test_results &lt;- getmymetrics(balclr_sns_grid_results,\n                                                 \"balclr_sns_boosting\",\n                                                 \"roc_auc\",\n                                                 balclr_sns_split)\n\n\ntune::collect_metrics(balclr_sns_rf_test_results) %&gt;%\n  dplyr::select(metric = .metric,\n                random_forest = .estimate,\n                estimate_type = .estimator) %&gt;%\n  dplyr::left_join(\n    tune::collect_metrics(balclr_sns_boosting_test_results) %&gt;%\n      dplyr::select(\n        metric = .metric,\n        boosting = .estimate,\n        estimate_type = .estimator\n      )\n  ) %&gt;%\n  dplyr::relocate(estimate_type, metric)\n\nJoining with `by = join_by(metric, estimate_type)`\n\n\n\n  \n\n\n\n\n\n2.3.6.2 ROC and PR curves\nROC curves indicate that there is good performance for the evolution environments that either contain streptomycin or do not.\n\nbalclr_sns_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::roc_curve(home_env_sns, .pred_nostrep) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\nbalclr_sns_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::pr_curve(home_env_sns, .pred_nostrep) %&gt;% \n  tune::autoplot() +\n  ggplot2::labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n2.3.6.3 Confusion matrix\n\nbalclr_sns_rf_test_results %&gt;% \n  tune::collect_predictions() %&gt;%\n  yardstick::conf_mat(home_env_sns, .pred_class) %&gt;%\n  tune::autoplot(type = \"heatmap\") \n\n\n\n\n\n\n\n\n\n\n2.3.6.4 Probability distributions for the 2 classes\n\nbalclr_sns_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  ggplot2::ggplot() +\n  ggplot2::geom_density(aes(x = .pred_strep, fill = home_env_sns), alpha = 0.5) +\n  ggplot2::labs(x = \"Prediction Probability\", y = \"Density\")",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/communities/amplicon/02_machine_learn_home_env.html#classes-predation-history-vs-no-predation-history",
    "href": "R/communities/amplicon/02_machine_learn_home_env.html#classes-predation-history-vs-no-predation-history",
    "title": "Community composition analysis using machine learning",
    "section": "2.4 2 classes (predation history vs no predation history)",
    "text": "2.4 2 classes (predation history vs no predation history)\n\n2.4.1 Spliting\nDone the same as in Section 2.1.1 from the 5-class classification.\n\nbalclr_pnp &lt;- balclr_md %&gt;% \n  dplyr::select(-home_env_5c, -home_env_ae, -home_env_sns) %&gt;% \n  dplyr::mutate(replicate = factor(replicate),\n         transfer = factor(transfer),\n         measure_env = factor(measure_env),\n         home_env_pnp = factor(home_env_pnp)) %&gt;% \n  # we omit the ancestral samples to keep it more balanced\n  tidyr::drop_na()\n\ntable(balclr_pnp$home_env_pnp)\n\n\nnopred   pred \n   142    141 \n\n\n\nset.seed(1567)\nbalclr_pnp_split &lt;- rsample::initial_split(balclr_pnp, strata = home_env_pnp)\nbalclr_pnp_train &lt;- rsample::training(balclr_pnp_split)\nbalclr_pnp_test  &lt;- rsample::testing(balclr_pnp_split)\n\n\nset.seed(1568)\nbalclr_pnp_folds &lt;- rsample::vfold_cv(balclr_pnp_train, strata = home_env_pnp)\n\n\n\n2.4.2 Recipe\nDone the same as in Section 2.1.2 from the 5-class classification.\n\nbalclr_pnp_rec &lt;- recipes::recipe(home_env_pnp ~ ., data = balclr_pnp_train) %&gt;% \n  recipes::step_normalize(od600, ciliate_per_ml) %&gt;% \n  recipes::step_dummy(all_nominal(), -all_outcomes()) %&gt;%\n  recipes::step_zv(od600, ciliate_per_ml)\n\n\n\n2.4.3 Model specifications\nUsing the same model specifications as in Section 2.1.3 from the 5-class classification.\n\n\n2.4.4 Create workflow set\nSame process as in Section 2.1.4 from the 5-class classification.\n\nbalclr_pnp_wf &lt;- \n   workflowsets::workflow_set(\n      preproc = list(balclr_pnp = balclr_pnp_rec), \n      models = list(\n        #SVM_radial = svm_r_spec, \n        #SVM_poly = svm_p_spec, \n        #CART = cart_spec, \n        #CART_bagged = bag_cart_spec,\n        #NNET = nnet_spec,\n        boosting = xgb_spec,\n        #bart = bart_spec, \n        #fda = fda_spec,\n        RF = rf_spec\n      )\n   )\n\n\n\n2.4.5 Tune\nSame as in Section 2.1.5 from the 5-class classification. Warning this takes some time…\n\nbalclr_pnp_grid_results &lt;-\n   workflowsets::workflow_map(balclr_pnp_wf, \n      seed = 1569,\n      resamples = balclr_pnp_folds,\n      grid = 25,\n      control = tune::control_grid(save_pred = TRUE, parallel_over = \"everything\", save_workflow = TRUE),\n      metrics = yardstick::metric_set(recall, precision, f_meas, j_index, accuracy, kap, roc_auc, sens, spec),\n   )\n\n# save this for later\nreadr::write_rds(balclr_pnp_grid_results, here::here(data, \"model_tune_pnp.rds\"))\n\n\nbalclr_pnp_grid_results &lt;- readr::read_rds(here::here(data, \"model_tune_pnp.rds\"))\n\n\n\n2.4.6 Best tuning parameters and best performing models\nFirst look at which of the models performed best. It appears that based on all metrics the random forest performs the best.\n\nmymetric &lt;- \"roc_auc\"\n\ntune::autoplot(\n  balclr_pnp_grid_results,\n  rank_metric = mymetric,  \n  metric = mymetric,       \n  # one point per workflow \n  select_best = TRUE) +\n  ggplot2::geom_text(aes(y = mean + 0.15, label = wflow_id), angle = 90, hjust = 1) +\n  ggplot2::theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n2.4.6.1 Peformance metrics for best model\nClearly here random forest is doing better\n\nset.seed(87605)\nbalclr_pnp_boosting_test_results &lt;- getmymetrics(balclr_pnp_grid_results,\n                                                 \"balclr_pnp_boosting\",\n                                                 \"j_index\",\n                                                 balclr_pnp_split)\nbalclr_pnp_rf_test_results &lt;- getmymetrics(balclr_pnp_grid_results,\n                                           \"balclr_pnp_RF\",\n                                           \"j_index\",\n                                           balclr_pnp_split)\n\n\ncollect_metrics(balclr_pnp_rf_test_results) %&gt;%\n  dplyr::select(metric = .metric,\n                random_forest = .estimate,\n                estimate_type = .estimator) %&gt;%\n  dplyr::left_join(\n    tune::collect_metrics(balclr_pnp_boosting_test_results) %&gt;%\n      dplyr::select(\n        metric = .metric,\n        boosting = .estimate,\n        estimate_type = .estimator\n      )\n  ) %&gt;%\n  dplyr::relocate(estimate_type, metric)\n\nJoining with `by = join_by(metric, estimate_type)`\n\n\n\n  \n\n\n\n\n\n2.4.6.2 ROC-curve\nROC curves indicate that there is good performance for the evolution environments that either contain streptomycin or do not.\n\nbalclr_pnp_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  yardstick::roc_curve(home_env_pnp, .pred_nopred) %&gt;%\n  tune::autoplot() +\n  ggplot2::labs(x = \"FP rate\", y = \"TP rate\")\n\n\n\n\n\n\n\n\n\nbalclr_pnp_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  yardstick::pr_curve(home_env_pnp, .pred_nopred) %&gt;%\n  tune::autoplot() +\n  ggplot2::labs(x = \"Recall\", y = \"Precision\")\n\n\n\n\n\n\n\n\n\n\n2.4.6.3 Confusion matrix\n\nbalclr_pnp_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  yardstick::conf_mat(home_env_pnp, .pred_class) %&gt;%\n  tune::autoplot(type = \"heatmap\")\n\n\n\n\n\n\n\n\n\n\n2.4.6.4 Probability distributions for the 2 classes\n\nbalclr_pnp_rf_test_results %&gt;%\n  tune::collect_predictions() %&gt;%\n  ggplot2::ggplot() +\n  ggplot2::geom_density(aes(x = .pred_pred, fill = home_env_pnp), alpha = 0.5) +\n  ggplot2::labs(x = \"Prediction Probability\", y = \"Density\")",
    "crumbs": [
      "2. Community growth - amplicon composition",
      "iii) Machine learning the home environment"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html",
    "title": "Formatting growth curves",
    "section": "",
    "text": "After XX transfers of the experiment 32 clones were randomly picked from each replicate/home environemnt/measurement environmentn on selective plates. These clones were grown in all the different YSK conditions (including in the presence of the Ciliate) for 48 hours on the log-phase 600 plate reader. From this data we can estimate the growth rate and the carrying capacity of each species in the different conditions.\nIn this notebook we will read the output from the log phase plate reader and format it for later plotting and analysis.",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#load-required-packages",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#load-required-packages",
    "title": "Formatting growth curves",
    "section": "2.1 Load required packages",
    "text": "2.1 Load required packages\n\nlibrary(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#global-variables",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#global-variables",
    "title": "Formatting growth curves",
    "section": "2.2 Global variables",
    "text": "2.2 Global variables\n\ndata_raw &lt;- here::here(\"_data_raw\", \"monocultures\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"monocultures\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#raw-growth-curves",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#raw-growth-curves",
    "title": "Formatting growth curves",
    "section": "3.1 Raw growth curves",
    "text": "3.1 Raw growth curves\n\ngcurves_slurped &lt;- readr::read_delim(samppaths, \n                          comment = \"#\", \n                          delim = \";\",\n                          escape_double = FALSE,\n                          trim_ws = TRUE, \n                          id = \"file_name\") \n\nRows: 9248 Columns: 98\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \";\"\ndbl  (96): A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, B1, B2, B3, B4...\ntime  (1): Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ngcurves_slurped_fmt &lt;- gcurves_slurped %&gt;% \n  dplyr::mutate(plate = str_extract(file_name, \"A\\\\d_\\\\d\")) %&gt;% \n  dplyr::select(-file_name) %&gt;% \n  dplyr::relocate(plate) %&gt;% \n  dplyr::mutate(hours = lubridate::time_length(lubridate::hms(Time), unit = \"hours\")) %&gt;% \n  dplyr::mutate(seconds = lubridate::time_length(lubridate::hms(Time), unit = \"seconds\")) %&gt;% \n  dplyr::select(-Time) %&gt;% \n  tidyr::pivot_longer(c(-plate, -hours, -seconds), names_to = \"well\", values_to = \"OD600\") %&gt;% \n  dplyr::mutate(well = factor(well, levels = paste(rep(LETTERS[1:8], each = 12), 1:12, sep = \"\")))",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#thinning",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#thinning",
    "title": "Formatting growth curves",
    "section": "4.1 Thinning",
    "text": "4.1 Thinning\n\nround_any &lt;- function(x, accuracy, f=round){\n  f(x/ accuracy) * accuracy\n}\n\ngcurves_thin &lt;- gcurves_slurped_fmt %&gt;% \n  dplyr::mutate(seconds = round_any(seconds, 100)) %&gt;% \n  # 1200 is 20 minutes so by ensuring modulo = 0 we include only time points\n  # 0, 20, 40, 60 minutes and so on...\n  dplyr::filter(seconds %% 1200 == 0)",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#smoothing",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#smoothing",
    "title": "Formatting growth curves",
    "section": "4.2 Smoothing",
    "text": "4.2 Smoothing\nFor the growth curves we may need to do some smoothing to reduce the “jaggedness” of the curves a bit because these were run before the optimized logphase600 protocol was in place (better breatheasy seals plus new sealing tool). e use the slider package with a 5 point rolling mean for each focal observation we take the mean including the focal point and two points before and after.\n\nSee here for a useful thread:\nThis answer seems most promising\nPotentially also promising\n\nHere we will smooth out some of the higher frequency noise in the curves. First we wil smooth using a moving median approach then smooth that using a moving average approach. We will also try a min then mean smoothing approach. Some of the curves are really wacky with lots of erratic peaks. Taking a moving minimum will try and make sure we exclude the big peaks, but it will also probably distort the curves to some extent\n\ngcurves_thin_sm &lt;- gcurves_thin %&gt;% \n  dplyr::group_by(plate, well) %&gt;% \n  dplyr::mutate(OD600_smooth_md = slider::slide_dbl(OD600, median, .before = 2, .after = 2)) %&gt;% \n  dplyr::mutate(OD600_smooth_avg = slider::slide_dbl(OD600, mean, .before = 2, .after = 2)) %&gt;% \n  dplyr::mutate(OD600_smooth_md_avg = slider::slide_dbl(OD600_smooth_md, mean, .before = 2, .after = 2)) %&gt;% \n  ungroup()\n\nreadr::write_tsv(gcurves_thin_sm, here::here(data, \"gcurves_smoothed_thinned.tsv\"))",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#bact-conditions",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#bact-conditions",
    "title": "Formatting growth curves",
    "section": "5.1 Bact conditions",
    "text": "5.1 Bact conditions\n\n5.1.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Growth curves for the bacteria only conditions on Plate 1. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Growth curves for the bacteria only conditions on Plate 2. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Growth curves for the bacteria only conditions on Plate 3. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Growth curves for the bacteria only conditions on Plate 4. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Growth curves for bacteria only conditions on Plate 5. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Growth curves for bacteria only conditions on Plate 6. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Growth curves for bacteria only conditions on Plate 7. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.1.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Growth curves for bacteria only conditions on Plate 8. Orange solid line is raw data, blue line is 5-point rolling mean smooth.",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#predator-conditions",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#predator-conditions",
    "title": "Formatting growth curves",
    "section": "5.2 Predator conditions",
    "text": "5.2 Predator conditions\n\n5.2.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Growth curves for the ciliate conditions on Plate 1. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Growth curves for the ciliate conditions on Plate 2. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Growth curves for the ciliate conditions on Plate 3. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Growth curves for the ciliate conditions on Plate 4. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Growth curves for ciliate conditions on Plate 5. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Growth curves for ciliate conditions on Plate 6. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Growth curves for ciliate conditions on Plate 7. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.2.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Growth curves for ciliate conditions on Plate 8. Orange solid line is raw data, blue line is 5-point rolling mean smooth.",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#streptomycin-conditions",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#streptomycin-conditions",
    "title": "Formatting growth curves",
    "section": "5.3 Streptomycin conditions",
    "text": "5.3 Streptomycin conditions\n\n5.3.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17: Growth curves for the Streptomycin conditions on Plate 1. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: Growth curves for the Streptomycin conditions on Plate 2. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Growth curves for the Streptomycin conditions on Plate 3. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 20: Growth curves for the Streptomycin conditions on Plate 4. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 21: Growth curves for Streptomycin conditions on Plate 5. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 22: Growth curves for Streptomycin conditions on Plate 6. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 23: Growth curves for Streptomycin conditions on Plate 7. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.3.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 24: Growth curves for Streptomycin conditions on Plate 8. Orange solid line is raw data, blue line is 5-point rolling mean smooth.",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#predator-streptomycin-conditions",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#predator-streptomycin-conditions",
    "title": "Formatting growth curves",
    "section": "5.4 Predator + Streptomycin conditions",
    "text": "5.4 Predator + Streptomycin conditions\n\n5.4.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 25: Growth curves for the Ciliate + Streptomycin conditions on Plate 1. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 26: Growth curves for the Ciliate + Streptomycin conditions on Plate 2. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 27: Growth curves for the Ciliate + Streptomycin conditions on Plate 3. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 28: Growth curves for the Ciliate + Streptomycin conditions on Plate 4. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 29: Growth curves for Ciliate + Streptomycin conditions on Plate 5. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30: Growth curves for Ciliate + Streptomycin conditions on Plate 6. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 31: Growth curves for Ciliate + Streptomycin conditions on Plate 7. Orange solid line is raw data, blue line is 5-point rolling mean smooth.\n\n\n\n\n\n5.4.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 32: Growth curves for Ciliate + Streptomycin conditions on Plate 8. Orange solid line is raw data, blue line is 5-point rolling mean smooth.",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#functions",
    "href": "R/monoculture/20230112_clone_phenotyping/01_growth_curve_qc.html#functions",
    "title": "Formatting growth curves",
    "section": "2.3 Functions",
    "text": "2.3 Functions\n\nplotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, well, plate), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 1)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::geom_line(aes(y=OD600_smooth_avg), color = \"blue\", lty=2), \n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ well, nrow = rows, ncol = cols, page = page), #scales = \"free_y\"\n      ggplot2::theme(axis.text = element_text(size = 9))\n    )\n}",
    "crumbs": [
      "3. Clones monoculture growth",
      "i) Inspect and format growth curves"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html",
    "href": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html",
    "title": "Analysis of growth curves",
    "section": "",
    "text": "library(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nlibrary(growthrates)\n\nLoading required package: lattice\nLoading required package: deSolve\n\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"monocultures\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"monocultures\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n\n\n\n\nplotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, well, plate), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      ggplot2::geom_line(aes(y=OD600_smooth_avg), color = \"blue\"), \n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 2)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ well, nrow = rows, ncol = cols, page = page), #scales = \"free_y\"\n      ggplot2::theme(axis.text = element_text(size = 9))\n    )\n}",
    "crumbs": [
      "3. Clones monoculture growth",
      "ii) Estimate growth rates"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#load-required-packages",
    "href": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#load-required-packages",
    "title": "Analysis of growth curves",
    "section": "",
    "text": "library(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nlibrary(growthrates)\n\nLoading required package: lattice\nLoading required package: deSolve\n\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "3. Clones monoculture growth",
      "ii) Estimate growth rates"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#global-variables",
    "href": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#global-variables",
    "title": "Analysis of growth curves",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"monocultures\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"monocultures\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "3. Clones monoculture growth",
      "ii) Estimate growth rates"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#functions",
    "href": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#functions",
    "title": "Analysis of growth curves",
    "section": "",
    "text": "plotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, well, plate), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      ggplot2::geom_line(aes(y=OD600_smooth_avg), color = \"blue\"), \n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 2)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ well, nrow = rows, ncol = cols, page = page), #scales = \"free_y\"\n      ggplot2::theme(axis.text = element_text(size = 9))\n    )\n}",
    "crumbs": [
      "3. Clones monoculture growth",
      "ii) Estimate growth rates"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#metadata",
    "href": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#metadata",
    "title": "Analysis of growth curves",
    "section": "2.1 Metadata",
    "text": "2.1 Metadata\n\nmddf &lt;- read_tsv(\n  here::here(data_raw, \"metadata.tsv\"),\n  col_types = list(\n    plate = col_character(),\n    well = col_character(),\n    clone_id = col_double(),\n    experiment_treatment = col_character(),\n    LTCSE_treatment = col_character(),\n    replicate = col_character(),\n    lagtime = col_time(format = \"%T\"),\n    max_growth_death_rate = col_double(),\n    time_to_stationary = col_time(format = \"%T\")\n  )\n) %&gt;% mutate(Group = 1, Flag = 0, Subset = 1)\n\nWarning: The following named parsers don't match the column names:\nexperiment_treatment, LTCSE_treatment\n\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)",
    "crumbs": [
      "3. Clones monoculture growth",
      "ii) Estimate growth rates"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#previously-smoothed-growth-curves",
    "href": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#previously-smoothed-growth-curves",
    "title": "Analysis of growth curves",
    "section": "2.2 Previously smoothed growth curves",
    "text": "2.2 Previously smoothed growth curves\n\ngcurves_thin_sm &lt;- readr::read_tsv(here::here(data, \"gcurves_smoothed_thinned.tsv\"))\n\nRows: 445440 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): plate, well\ndbl (6): hours, seconds, OD600, OD600_smooth_md, OD600_smooth_avg, OD600_smo...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "3. Clones monoculture growth",
      "ii) Estimate growth rates"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#bact-conditions",
    "href": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#bact-conditions",
    "title": "Analysis of growth curves",
    "section": "4.1 Bact conditions",
    "text": "4.1 Bact conditions\n\n4.1.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Growth curves for the bacteria only conditions on Plate 1. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.1.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Growth curves for the bacteria only conditions on Plate 2. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.1.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Growth curves for the bacteria only conditions on Plate 3. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.1.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Growth curves for the bacteria only conditions on Plate 4. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.1.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Growth curves for bacteria only conditions on Plate 5. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.1.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Growth curves for bacteria only conditions on Plate 6. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.1.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Growth curves for bacteria only conditions on Plate 7. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.1.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Growth curves for bacteria only conditions on Plate 8. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "3. Clones monoculture growth",
      "ii) Estimate growth rates"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#predator-conditions",
    "href": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#predator-conditions",
    "title": "Analysis of growth curves",
    "section": "4.2 Predator conditions",
    "text": "4.2 Predator conditions\n\n4.2.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Growth curves for the ciliate conditions on Plate 1. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.2.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Growth curves for the ciliate conditions on Plate 2. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.2.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Growth curves for the ciliate conditions on Plate 3. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.2.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Growth curves for the ciliate conditions on Plate 4. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.2.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Growth curves for ciliate conditions on Plate 5. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.2.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Growth curves for ciliate conditions on Plate 6. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.2.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Growth curves for ciliate conditions on Plate 7. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.2.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Growth curves for ciliate conditions on Plate 8. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "3. Clones monoculture growth",
      "ii) Estimate growth rates"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#streptomycin-conditions",
    "href": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#streptomycin-conditions",
    "title": "Analysis of growth curves",
    "section": "4.3 Streptomycin conditions",
    "text": "4.3 Streptomycin conditions\n\n4.3.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17: Growth curves for the Streptomycin conditions on Plate 1. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.3.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: Growth curves for the Streptomycin conditions on Plate 2. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.3.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Growth curves for the Streptomycin conditions on Plate 3. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.3.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 20: Growth curves for the Streptomycin conditions on Plate 4. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.3.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 21: Growth curves for Streptomycin conditions on Plate 5. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.3.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 22: Growth curves for Streptomycin conditions on Plate 6. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.3.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 23: Growth curves for Streptomycin conditions on Plate 7. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.3.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 24: Growth curves for Streptomycin conditions on Plate 8. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "3. Clones monoculture growth",
      "ii) Estimate growth rates"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#predator-streptomycin-conditions",
    "href": "R/monoculture/20230112_clone_phenotyping/02_growth_rate_analysis.html#predator-streptomycin-conditions",
    "title": "Analysis of growth curves",
    "section": "4.4 Predator + Streptomycin conditions",
    "text": "4.4 Predator + Streptomycin conditions\n\n4.4.1 Plate 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 25: Growth curves for the Ciliate + Streptomycin conditions on Plate 1. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.4.2 Plate 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 26: Growth curves for the Ciliate + Streptomycin conditions on Plate 2. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.4.3 Plate 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 27: Growth curves for the Ciliate + Streptomycin conditions on Plate 3. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.4.4 Plate 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 28: Growth curves for the Ciliate + Streptomycin conditions on Plate 4. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.4.5 Plate 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 29: Growth curves for Ciliate + Streptomycin conditions on Plate 5. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.4.6 Plate 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30: Growth curves for Ciliate + Streptomycin conditions on Plate 6. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.4.7 Plate 7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 31: Growth curves for Ciliate + Streptomycin conditions on Plate 7. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.\n\n\n\n\n\n4.4.8 Plate 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 32: Growth curves for Ciliate + Streptomycin conditions on Plate 8. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.",
    "crumbs": [
      "3. Clones monoculture growth",
      "ii) Estimate growth rates"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "",
    "text": "library(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nlibrary(DescTools)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\n\n\n\ndata_raw &lt;- here::here(\"_data_raw\", \"monocultures\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"monocultures\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\n\n\n\n\n\nplotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, well, plate), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      ggplot2::geom_line(aes(y=OD600_smooth_avg), color = \"blue\"), \n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 2)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ well, nrow = rows, ncol = cols, page = page), #scales = \"free_y\"\n      ggplot2::theme(axis.text = element_text(size = 9))\n    )\n}",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#load-required-packages",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#load-required-packages",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "",
    "text": "library(here)\n\nhere() starts at /home/shane/Documents/projects/experiments/hambiYSKpleiotropy01\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(stringr)\nlibrary(stringi)\nlibrary(lubridate)\nlibrary(fs)\nlibrary(DescTools)\nsource(here::here(\"R\", \"utils_generic.R\"))",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#global-variables",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#global-variables",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "",
    "text": "data_raw &lt;- here::here(\"_data_raw\", \"monocultures\", \"20230112_clone_phenotyping\")\ndata &lt;- here::here(\"data\", \"monocultures\", \"20230112_clone_phenotyping\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#functions",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#functions",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "",
    "text": "plotplate &lt;- function(df, dfxy, unsmoothed=TRUE, predicted=FALSE, plate, rows, cols, page){\n  dffilt &lt;- dplyr::filter(df, plate == {{ plate }})\n  xyfilt &lt;- if (!is.null(dfxy)){ left_join(dfxy, distinct(dffilt, id, well, plate), by = join_by(id)) %&gt;% \n      drop_na()}\n  \n  ggplot(dffilt, aes(x = hours)) +\n    list(\n      ggplot2::geom_line(aes(y=OD600_smooth_avg), color = \"blue\"), \n      if (unsmoothed) {ggplot2::geom_line(aes(y=OD600), color = \"orange\", lty = 2)},\n      if (predicted) {ggplot2::geom_line(aes(y=predicted), color = \"orange\")}, \n      if (!is.null(dfxy)) {ggplot2::geom_point(data = xyfilt, aes(x = x, y = y), color = \"red\", size = 2)},\n      ggplot2::labs(x = \"Hours\", y = \"OD600\"), \n      ggplot2::scale_x_continuous(breaks = seq(0, 48, 12), labels = seq(0, 48, 12)), \n      ggforce::facet_wrap_paginate(~ well, nrow = rows, ncol = cols, page = page), #scales = \"free_y\"\n      ggplot2::theme(axis.text = element_text(size = 9))\n    )\n}",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#metadata",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#metadata",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "2.1 Metadata",
    "text": "2.1 Metadata\n\nmddf &lt;- read_tsv(\n  here::here(data_raw, \"metadata.tsv\"),\n  col_types = list(\n    plate = col_character(),\n    well = col_character(),\n    clone_id = col_double(),\n    experiment_treatment = col_character(),\n    LTCSE_treatment = col_character(),\n    replicate = col_character(),\n    lagtime = col_time(format = \"%T\"),\n    max_growth_death_rate = col_double(),\n    time_to_stationary = col_time(format = \"%T\")\n  )\n) %&gt;%\n  mutate(\n    measure_env_short = case_when(\n      measure_env == \"bact\" ~ \"Meas: B\",\n      measure_env == \"bact_pred\" ~ \"Meas: BP\",\n      measure_env == \"bact_strep\" ~ \"Meas: BS\",\n      measure_env == \"bact_pred_strep\" ~ \"Meas: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    home_env_short = case_when(\n      evolution_env == \"anc\" ~ \"Home: Anc\",\n      evolution_env == \"bact\" ~ \"Home: B\",\n      evolution_env == \"bact_pred\" ~ \"Home: BP\",\n      evolution_env == \"bact_strep\" ~ \"Home: BS\",\n      evolution_env == \"bact_pred_strep\" ~ \"Home: BPS\"\n    )\n  ) %&gt;%\n  mutate(\n    measure_env_short = factor(\n      measure_env_short,\n      levels = c(\"Meas: B\", \"Meas: BP\", \"Meas: BS\", \"Meas: BPS\")\n    ),\n    home_env_short = factor(\n      home_env_short,\n      levels = c(\"Home: Anc\", \"Home: B\", \"Home: BP\", \"Home: BS\", \"Home: BPS\")\n    ),\n    replicate = factor(replicate),\n    clone_id = factor(clone_id)\n  )",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#previously-smoothed-growth-curves",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#previously-smoothed-growth-curves",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "2.2 Previously smoothed growth curves",
    "text": "2.2 Previously smoothed growth curves\n\ngcurves_thin_sm &lt;- readr::read_tsv(here::here(data, \"gcurves_smoothed_thinned.tsv\"))",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#blacklist",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#blacklist",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "2.3 Blacklist",
    "text": "2.3 Blacklist\n\nblacklist &lt;- read_tsv(here::here(data, \"blacklist.tsv\"))",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#previous-growth-rates",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#previous-growth-rates",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "2.4 Previous growth rates",
    "text": "2.4 Previous growth rates\n\ngrates &lt;- readr::read_tsv(here::here(data, \"gcurve_spline_results.tsv\")) %&gt;% \n  anti_join(blacklist)",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#calculate-auc",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#calculate-auc",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "3.1 Calculate AUC",
    "text": "3.1 Calculate AUC\nCalculates AUC using DescTools package\n\nmany_auc_res &lt;- gcurves_thin_sm_filt %&gt;% \n  dplyr::summarize(auc = DescTools::AUC(hours, OD600_smooth_avg),\n            max_od = max(OD600_smooth_avg),\n            min_od = min(OD600_smooth_avg),\n            .by = c(plate, well))",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#combine-growth-rates-and-auc-and-metadata",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#combine-growth-rates-and-auc-and-metadata",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "3.2 Combine Growth rates and AUC and metadata",
    "text": "3.2 Combine Growth rates and AUC and metadata\n\nauc_gr_md &lt;- left_join(many_auc_res, mddf, by = join_by(plate, well)) %&gt;% \n  left_join(grates, by = join_by(plate, well))",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#z-score",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#z-score",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "3.3 Z score",
    "text": "3.3 Z score\n\nauc_gr_md_subset &lt;- auc_gr_md %&gt;%\n  dplyr::select(\n    auc,\n    mumax,\n    measure_env,\n    evolution_env,\n    measure_env_short,\n    home_env_short,\n    replicate,\n    clone_id\n  )\n\nauc_gr_md_subset_summary &lt;- auc_gr_md_subset %&gt;%\n  filter(measure_env == evolution_env) %&gt;%\n  summarize(\n    auc_mn = mean(auc),\n    auc_sd = sd(auc),\n    mu_mn = mean(mumax),\n    mu_sd = sd(mumax),\n    .by = c(measure_env)\n  )\n\nauc_gr_md_subset_summary_z &lt;- left_join(auc_gr_md_subset, auc_gr_md_subset_summary, by = join_by(measure_env)) %&gt;%\n  mutate(z_mu = (mumax - mu_mn), #/ mu_sd\n         z_auc = (auc - auc_mn)) %&gt;% #/auc_sd\n  pivot_longer(cols = starts_with(\"z\"),\n               names_to = \"metric\",\n               values_to = \"z\")",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  },
  {
    "objectID": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#plot",
    "href": "R/monoculture/20230112_clone_phenotyping/03_auc_analysis.html#plot",
    "title": "Analysis of Area Under the Curve (AUC)",
    "section": "3.4 Plot",
    "text": "3.4 Plot\n\ncloneplot &lt;- function(df, metric, ylab){\n  df %&gt;% \n    filter(metric == {{ metric }}) %&gt;% \n    ggplot2::ggplot() +\n    ggplot2::geom_hline(yintercept = 0) +\n    ggplot2::geom_boxplot(aes(y = z, x = home_env_short), color = \"red\", outliers = FALSE, position = position_dodge(width = 0.5)) +\n    ggplot2::geom_jitter(aes(y = z, x = home_env_short, color = replicate), width = 0.25, height = 0, alpha = 0.25) +\n    ggplot2::labs(x = \"Home environment\", y = ylab, fill=\"\") + \n    ggplot2::facet_grid(measure_env_short ~ ., scales = \"free_y\") +\n    ggplot2::theme_bw()\n}\n\npclone_auc &lt;- cloneplot(auc_gr_md_subset_summary_z, \"z_auc\", \"Meaurement env mean centered AUC\")\npclone_mu &lt;- cloneplot(auc_gr_md_subset_summary_z, \"z_mu\", \"Meaurement env mean centered μ\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Mean centered AUC (area under the growth curve) for 32 randomly picked clones from each replicate (A-F) of each home YSK environment and measurement condition pair. Points are individual measurements (colored by replicate) while boxplots represent the mean and 1-3 quartiles with whiskers representing 1.5 \\(\\times\\) the interquartile range. Heavy black line is the Measurement Environment mean.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Mean centered maximum specific growth rate (μ max) for 32 randomly picked clones from each replicate (A-F) of each home YSK environment and measurement condition pair. Points are individual measurements (colored by replicate) while boxplots represent the mean and 1-3 quartiles with whiskers representing 1.5 \\(\\times\\) the interquartile range. Heavy black line is the Measurement Environment mean.\n\n\n\n\nggplot2::ggsave(\n  here::here(\"figs\", \"monoculture_clone_phenotyping_auc.svg\"),\n  pclone_auc,\n  width = 7,\n  height = 8,\n  units = \"in\",\n  device = \"svg\"\n)\n\nggplot2::ggsave(\n  here::here(\"figs\", \"monoculture_clone_phenotyping_auc.png\"),\n  pclone_auc,\n  width = 7,\n  height = 8,\n  units = \"in\",\n  device = \"png\"\n)",
    "crumbs": [
      "3. Clones monoculture growth",
      "iii) AUC and growth rate plots"
    ]
  }
]